### [Continue](https://continue.dev) session transcript
 Exported: 3/25/2025, 12:05:28 AM

#### _Assistant_

> Always include the language and file name in the info string when you write code blocks, for example '```python file.py'.

#### _User_

> indigo: golang code for Bluesky's atproto services 
>  Some Bluesky software is developed in Typescript, and lives in the bluesky-social/atproto repository. Some is developed in Go, and lives here. 
>  
>  Everything in this repository is an work in progress. Features and "Lexicons" may be removed or updated, software interfaces broken, etc. 
>  We are developing in the open, but not ready to accept or review significant contributions. Keep checking back! 
>  
>  What is atproto? 
>  not to be confused with the AT command set or Adenosine triphosphate 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBLLC . Learn more at: 
>  
>  Protocol Documentation 
>  Overview Guide 👈 Good place to start 
>  Blogpost on self-authenticating data structures 
>  
>  Development 
>  First, you will need the Go toolchain installed. We develop using the latest stable version of the language. 
>  The Makefile provides wrapper commands for basic development: 
>  make build
> make test
> make fmt
> make lint
>  
>  Individual commands can be run like:
> 
> dholms 
> changed the title
>  
>  
>  
>  dholms 
> marked this pull request as ready for review
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Choose a reason for hiding this comment 
>  
> The reason will be displayed to describe this comment to others. Learn more .
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Choose a reason for hiding this comment 
>  
> The reason will be displayed to describe this comment to others. Learn more .
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * refactor pds tests to use dev env
> * refactor bsky tests
> * fix pds test
> * tidy bsky tests 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * switch takedown ids back to ints, consistent with live pds
> * tidy/fix migration
> * update migration for sqlite 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  edavis 
> added a commit
> to edavis/pds
> that referenced
> this pull request
>  
>  
>  
>  
>  
>  
>  
>  
>  mloar 
> pushed a commit
> to mloar/atproto
> that referenced
> this pull request
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * rm tables
> * rm event-stream &amp; proxied
> * Remove appview services, move label service to pds
> * only proxy appview stuff
> * delete more tables
> * Start removing message dispatched from pds
> * more syncing-up removal of message dispatcher in pds
> * merged
> * remove feedgens from pds, remove getPopular
> * remove unused image helper from pds
> * fixing compiler errors
> * clean up sharp
> * rm label service
> * first pass on cleaning up tests
> * fix up a bunch of tests
> * moderation view tests
> * last admin tests
> * got a lil overzealous in deletes
> * clean up unused cfg
> * clean up label table
> * simplify admin repo search query/logic
> * tidy pds entrypoint
> * in-progress pds config changes
> * cfg fiddling
> * finish cleaning up cfg/ctx
> * comments
> * building
> * pds prefix on env
> * test env
> * collapse pds migrations down into a single migration
> * fix up dev-env
> * tidy
> * cleanup
> * fix pds admin tests
> * fix handle test
> * fix pds proxy tests
> * fix subscribe repos test
> * fix sqlite config in pds tests
> * add sqlite clause in sequencer-leader
> * fix actor search w/ sqlite on pds
> * fixes
> * fix dev env build
> * update pds service entrypoint
> * simple env example
> * make takedown ids opaque identifiers in the pds
> * use pds routes for api tests
> * update pds dockerfile with volume and correct port env var
> * add a couple env vars to example
> * add comments to env example
> * @atproto/pds 0.2.0-beta.0
> * @atproto/aws 0.0.1-beta.0
> * appview did
> * @atproto/aws 0.0.1
> * enable logs by default
> * update env example
> * bugfixing sandbox issues
> * consistency in pds env var name for appview url
> * log on pds start and stop, configure version at runtime
> * @atproto/pds 0.2.0-beta.1
> * fix semver matching for pds beta version
> * v0.2.0-beta.2
> * default invites to being not required
> * fix flaky test
> * limit db connections in tests
> * publish 0.2.0-beta.d3
> * fix invite required parsing
> * @atproto/pds 0.2.0-beta.5
> * Proxy getPopularFeedGenerators on simplified pds ( bluesky-social#1222 )
> proxy getPopularFeedGenerators on pds
> Co-authored-by: dholms &lt;dtholmgren@gmail.com&gt;
> * tidy migrations
> * fix service entry
> * bump version
> * change auth order
> * bump version
> * bump version
> * add upgradeRepoVersion &amp; fallback url for cdn
> * bump version
> * merging
> * merge pds
> * building dev-env
> * merging tests
> * merge service entry
> * test fixing
> * tidy
> * fix admin search
> * tidy
> * tidy
> * add snap for getListFeed
> * add backup nameserver cfg
> * tidy + pr feedback
> * tidy
> * tidy env
> * bit more
> * re-add dotenv to root package.json
> * fix dep
> * build branch
> * fix tests
> * Refactor tests to make better use of dev-env ( bluesky-social#1690 )
> * refactor pds tests to use dev env
> * refactor bsky tests
> * fix pds test
> * tidy bsky tests
> * build pds correctly
> * fix entry point
> * default logging to false (for now)
> * format service entry
> * Switch takedown ids back to ints on pds distribution ( bluesky-social#1694 )
> * switch takedown ids back to ints, consistent with live pds
> * tidy/fix migration
> * update migration for sqlite
> * export moderation action reversal
> * takedown tests
> * dont build branch
> ---------
> Co-authored-by: Devin Ivy &lt;devinivy@gmail.com&gt;
> 
> indigo: atproto libraries and services in golang 
>  Some Bluesky software is developed in Typescript, and lives in the bluesky-social/atproto repository. Some is developed in Go, and lives here. 
>  What is in here? 
>  Go Services: 
>  
>  bigsky ( README ): "Big Graph Service" (BGS) reference implementation, running at bsky.network 
>  palomar ( README ): fulltext search service for https://bsky.app 
>  
>  Go Packages: 
>  
>  All the packages in this repository are under active development. Features and software interfaces have not stabilized and may break or be removed. 
>  
>  
>  
>  
>  Package 
>  Docs 
>  
>  
>  
>  
>  api/atproto : generated types for com.atproto.* Lexicons 
>  
>  
>  
>  api/bsky : generated types for app.bsky.* Lexicons 
>  
>  
>  
>  atproto/crypto : crytographic signing and key serialization 
>  
>  
>  
>  atproto/identity : DID and handle resolution 
>  
>  
>  
>  atproto/syntax : string types and parsers for identifiers 
>  
>  
>  
>  mst : Merkle Search Tree implementation 
>  
>  
>  
>  repo : account data storage 
>  
>  
>  
>  xrpc : HTTP API client 
>  
>  
>  
>  
>  The TypeScript reference implementation, including PDS and bsky AppView services, is at bluesky-social/atproto . Source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Development Quickstart 
>  First, you will need the Go toolchain installed. We develop using the latest stable version of the language. 
>  The Makefile provides wrapper commands for basic development: 
>  make build
> make test
> make fmt
> make lint
>  
>  Individual commands can be run like: 
>  The HACKING file has a list of commands and packages in this repository and some other development tips. 
>  What is atproto? 
>  not to be confused with the AT command set or Adenosine triphosphate 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  Issues are for bugs &amp; feature requests related to the golang implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or libraries used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> Autogenerated from lexicons, well type hinted, documented, sync and async SDK for Python 
>  
>  
> Examples
>  
> •
>  
> Documentation
>  
> •
>  
> Discord Bluesky API
>  
>  
>  The AT Protocol SDK 
>  
>  Under construction. Until the 1.0.0 release compatibility between versions is not guaranteed. 
>  
>  Code snippet: 
>  from atproto import Client , client_utils 
>  def main ():
>  client = Client ()
>  profile = client . login ( 'my-handle' , 'my-password' )
>  print ( 'Welcome,' , profile . display_name )
>  text = client_utils . TextBuilder (). text ( 'Hello World from ' ). link ( 'Python SDK' , 'https://atproto.blue' )
>  post = client . send_post ( text )
>  client . like ( post . uri , post . cid )
>  if __name__ == '__main__' :
>  main () 
>  💬 Direct Messages (Chats) 
>  🍿 Example project with custom feed generator 
>  🔥 Firehose data streaming is available 
>  🌐 Identity resolvers for DID and Handle 
>  Introduction 
>  This SDK attempts to implement everything that provides ATProto. There is support for Lexicon Schemes, XRPC clients, Firehose, Identity, DID keys, signatures, and more. All models, queries, and procedures are generated automatically. The main focus is on the lexicons of atproto.com and bsky.app, but it doesn't have a vendor lock on it. Feel free to use the code generator for your own lexicon schemes. SDK also provides utilities to work with CID, NSID, AT URI Schemes, DAG-CBOR, CAR files, DID Documents and more. 
>  Requirements 
>  
>  Python 3.8 or higher. 
>  
>  Installing 
>  Quick start 
>  First of all, you need to create the instance of the XRPC Client. To do so, you have two major options: asynchronous, and synchronous. The difference only in import and how you call the methods. If you are not familiar with async, use sync instead. 
>  For sync: 
>  from atproto import Client 
>  client = Client ()
>  # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor 
>  # Client('https://example.com') 
>  For async: 
>  from atproto import AsyncClient 
>  client = AsyncClient ()
>  # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor 
>  # AsyncClient('https://example.com') 
>  In the snippets below, only the sync version will be presented. 
>  Right after the creation of the Client instance, you probably want to access the full API and perform actions by profile. To achieve this, you should log in to the network using your handle and password. The password could be app-specific. 
>  from atproto import Client 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' ) 
>  You are awesome! Now you feel to pick any high-level method that you want and perform it! 
>  Code to send post: 
>  from atproto import Client 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  client . send_post ( text = 'Hello World!' ) 
>  Useful links to continue: 
>  
>  List of all methods with documentation . 
>  Examples of using the methods . 
>  
>  SDK structure 
>  The SDK is built upon the following components: 
>  
>  
>  
>  Package 
>  Description 
>  
>  
>  
>  
>  atproto 
>  Import shortcuts to other packages. 
>  
>  
>  atproto_cli 
>  CLI tool to generate code. 
>  
>  
>  atproto_client 
>  XRPC Client, data models, and utils like rich text helper. 
>  
>  
>  atproto_codegen 
>  Code generator of models, clients, and namespaces. 
>  
>  
>  atproto_core 
>  Tools to work with NSID, AT URI Schemes, CID, CAR files, and DID Documents. 
>  
>  
>  atproto_crypto 
>  Crypto utils like multibase, signature verification, work with DID keys. 
>  
>  
>  atproto_firehose 
>  Firehose (data streaming) client and models. 
>  
>  
>  atproto_identity 
>  Identity resolvers for DID, Handle, AT Protocol data, signing keys. 
>  
>  
>  atproto_lexicon 
>  Lexicon parser. 
>  
>  
>  atproto_server 
>  Server-side utils like JWT. 
>  
>  
>  
>  I highly recommend you to use the atproto package to import everything that you need.
> It contains shortcuts to all other packages. 
>  Documentation 
>  The documentation is live at atproto.blue . 
>  Getting help 
>  You can get help in several ways: 
>  
>  Report bugs, request new features by creating an issue . 
>  Ask questions by starting a discussion . 
>  Ask questions in Discord server . 
>  
>  Advanced usage 
>  I'll be honest. The high-level Client that was shown in the "Quick Start" section is not a real ATProto API. This is syntax sugar built upon the real XRPC methods! The high-level methods are not cover the full need of developers. To be able to do anything that you want, you should know to work with low-level API. Let's dive into it! 
>  The basics: 
>  
>  Namespaces – classes that group sub-namespaces and the XRPC queries and procedures. Built upon NSID ATProto semantic. 
>  Model – dataclasses for input, output, and params of the methods from namespaces. Models describe Record and all other types in the Lexicon Schemes. 
>  
>  Namespaces 
>  The client contains references to the root of all namespaces. It's com and app for now. 
>  from atproto import Client 
>  Client (). com 
>  Client (). app 
>  To dive deeper, you can navigate using hints from your IDE. Thanks to well-type hinted SDK, it's much easier. 
>  from atproto import Client 
>  Client (). com . atproto . server . create_session (...)
>  Client (). com . atproto . sync . get_blob (...)
>  Client (). app . bsky . feed . get_likes (...)
>  Client (). app . bsky . graph . get_follows (...) 
>  The endpoint of the path is always the method that you want to call. The method presents a query or procedure in XRPC. You should not care about it much. The only thing you need to know is that the procedures required data objects. Queries could be called with or without params. 
>  Records 
>  In some sub-namespaces, you can find records. Such record classes provide a syntax sugar not defined in the lexicon scheme. This sugar provides a more convenient way to work with repository operations. Such as creating a record, deleting a record, and so on. 
>  Here are some available records of Bluesky records: 
>  from atproto import Client 
>  Client (). app . bsky . feed . post 
>  Client (). app . bsky . feed . like 
>  Client (). app . bsky . graph . follow 
>  Client (). app . bsky . graph . block 
>  Client (). app . bsky . actor . profile 
>  # ... more 
>  Usage example with the post record: 
>  from atproto import AtUri , Client , models 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  posts = client . app . bsky . feed . post . list ( client . me . did , limit = 10 )
>  for uri , post in posts . records . items ():
>  print ( uri , post . text )
>  post = client . app . bsky . feed . post . get ( client . me . did , AtUri . from_str ( uri ). rkey )
>  print ( post . value . text )
>  post_record = models . AppBskyFeedPost . Record ( text = 'test record namespaces' , created_at = client . get_current_time_iso ())
>  new_post = client . app . bsky . feed . post . create ( client . me . did , post_record )
>  print ( new_post )
>  deleted_post = client . app . bsky . feed . post . delete ( client . me . did , AtUri . from_str ( new_post . uri ). rkey )
>  print ( deleted_post ) 
>  Please note that not all repository operations are covered by these syntax sugars. You can always use the low-level methods to perform any desired action. One such action is updating a record. 
>  Models 
>  To deal with methods, we need to deal with models! Models are available in the models module and have NSID-based aliases. Let's take a look at it. 
>  from atproto import models 
>  models . ComAtprotoIdentityResolveHandle 
>  models . AppBskyFeedPost 
>  models . AppBskyActorGetProfile 
>  # 90+ more... 
>  The model classes in the "models" aliases could be: 
>  
>  Data model 
>  Params model 
>  Response model 
>  Sugar response model 
>  Record model 
>  Type model 
>  
>  The only thing you need to know is how to create instances of models. Not with all models, you will work as model-creator. For example, SDK will create Response models for you. 
>  There are a few ways how to create the instance of a model: 
>  
>  Dict-based 
>  Class-based 
>  
>  The instances of data and params models should be passed as arguments to the methods that were described above. 
>  Dict-based: 
>  from atproto import Client 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  # The params model will be created automatically internally for you! 
>  print ( client . com . atproto . identity . resolve_handle ({ 'handle' : 'marshal.dev' })) 
>  Class-based: 
>  from atproto import Client , models 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  params = models . ComAtprotoIdentityResolveHandle . Params ( handle = 'marshal.dev' )
>  print ( client . com . atproto . identity . resolve_handle ( params )) 
>  Tip: look at typehint of the method to figure out the name and the path to the input/data model! 
>  Pro Tip: use IDE autocompletion to find necessary models! Just start typing the method name right after the dot ( models.{type method name in camel case ). 
>  Models could be nested as hell. Be ready for it! 
>  This is how we can send a post with the image using low-level XRPC Client: 
>  from atproto import Client , models 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  with open ( 'cat.jpg' , 'rb' ) as f :
>  img_data = f . read ()
>  upload = client . upload_blob ( img_data )
>  images = [ models . AppBskyEmbedImages . Image ( alt = 'Img alt' , image = upload . blob )]
>  embed = models . AppBskyEmbedImages . Main ( images = images )
>  client . com . atproto . repo . create_record (
>  models . ComAtprotoRepoCreateRecord . Data (
>  repo = client . me . did ,
>  collection = models . ids . AppBskyFeedPost ,
>  record = models . AppBskyFeedPost . Record (
>  created_at = client . get_current_time_iso (), text = 'Text of the post' , embed = embed 
> ),
> )
> )
>  # of course, you can use the syntax sugar here instead 
>  post = models . AppBskyFeedPost . Record ( text = 'Text of the post' , embed = embed , created_at = client . get_current_time_iso ())
>  client . app . bsky . feed . post . create ( client . me . did , post )
>  # or even high-level client 
>  client . send_image ( text = 'Text of the post' , image = img_data , image_alt = 'Img alt' )
>  # these three methods are equivalent 
>  I hope you are not scared. May the Force be with you. Good luck! 
>  Change log 
>  The full change log is available in CHANGES.md . 
>  Contributing 
>  Contributions of all sizes are welcome. The contribution guidelines will be presented later. 
>  License 
>  MIT
> 
> ATrium 
>  ATrium is a collection of Rust libraries designed to work with the AT Protocol , providing a versatile and coherent ecosystem for developers. The name is inspired by the concept of an "atrium" with a view of the open bluesky , reflecting the open nature of the project. 
>  Our goal is to provide a comprehensive, easy-to-use, and efficient library that caters to various use cases and scenarios involving the AT Protocol. 
>  Please note that ATrium is still under active development and many features may be subject to change or enhancement. We appreciate your understanding and patience during this phase. 
>  Overview 
>  ATrium is divided into several sub-projects to address different aspects of the AT Protocol and provide a modular design: 
>  atrium-api 
>  
>  
>  A library consisting of models and messaging definitions for XRPC, primarily generated using the codegen library. 
>  atrium-xrpc 
>  
>  
>  Definitions for XRPC request/response, and their associated errors. 
>  atrium-xrpc-client 
>  
>  
>  A library provides clients that implement the XrpcClient defined in atrium-xrpc 
>  atrium-cli 
>  
>  A command-line app using this API library. 
>  Code generation 
>  The models and messaging definitions for XRPC are generated with these crates: 
>  atrium-lex 
>  A library that provides type definitions for parsing the AT Protocol's Lexicon schema, ensuring compatibility with the lexicon. 
>  atrium-codegen 
>  A library that generates Rust code for the atrium-api based on the analyzed lexicon definitions. 
>  lexgen command 
>  cd lexicon &amp;&amp; cargo run -p lexgen -- --lexdir $HOME /.ghq/github.com/bluesky-social/atproto/lexicons 
>  Contribution 
>  We welcome contributions from the community to help us improve and expand ATrium. If you're interested in contributing, please feel free to submit issues or pull requests on the GitHub repository. We appreciate your support! 
>  License 
>  ATrium is released under the MIT License . 
>  Related works 
>  Below are some related projects that might be of interest: 
>  
>  atproto https://github.com/bluesky-social/atproto 
>  
>  The leading protocol implementation 
>  
>  
>  adenosine https://gitlab.com/bnewbold/adenosine 
>  atproto-rs https://github.com/ngerakines/atproto-rs 
>  atproto-rs https://github.com/Maaarcocr/atproto-rs 
>  bisky https://github.com/jesopo/bisky 
>  lexicon-rs https://github.com/Matrix89/lexicon-rs
> 
> AT Protocol Bluesky NextJS 13.4 Client 
>  This is a proof of concept NextJS client for AT Protocol / Bluesky that works with NextJS 13.4's App Router and React Server Components for server-side rendering. 
>  Start 
>  # Install the packages 
> npm i
>  # Start the dev server 
> npm run dev
>  # Open in browser: http://localhost:3000 
>  Auth Middleware 
>  The middleware handles automatic redirection of logged in and logged out users to the appropriate pages during server-request. 
>  The primary middleware function hasActiveAtpSessionMiddleware() which checks for a session cookie and gets the session from the AT Protocol server uses the fetch() function for server-side compatibility. 
>  The fetch function is used instead of the XRPC wrapper. See below for reasons. 
>  Cookies 
>  
>  Cookies are used to allow server-side functions to access the client's auth session tokens 
>  
>  Data Fetching 
>  The built-in @atproto/api package instantiates a BskyAgent for convenient access to Bluesky queries and procedures. 
>  Example: await bskyAgent.getTimeline() 
>  However, these methods do not appear to be compatible with NextJS server-side rendering and data fetching and will result in the following error 
>  ReferenceError: document is not defined 
>  In the cases of server-side data fetching, the XRPC wrapper is bypassed and we call the endpoint URL directly with the fetch() function. 
>  Areas for Continued Development / Left Off 
>  I have not spent much time troubleshooting the document is not defined errors when trying to execute BskyAgent calls on the server. 
>  The defaultFetchHandler() function at the root of the XRPC calls appears to use the fetch() method which should be server-side compatible. 
>  Possible Solutions 
>  
>  It's possible this is a simple packaging issue or a bug in my code pattern 
>  It's possible that the code-generator could be modified to generate NextJS server-side compatible agent functions for each of the lexicon defined endpoints
> 
> Have a question about this project? Sign up for a free GitHub account to open an issue and contact its maintainers and the community.
>  
>  
>  Sign up for GitHub
>  
>  
>  By clicking “Sign up for GitHub”, you agree to our terms of service and
>  privacy statement . We’ll occasionally send you account related emails. 
>  
> Already on GitHub?
>  Sign in 
> to your account
> 
> AT Protocol OpenAPI Types 
>  This repository contains OpenAPI types for the AT Protocol. They are generated
> according to the AT Protocol Specification 
> by converting/translating the lexicon specs into OpenAPI types. 
>  My hope is for this repository to serve as a live representation of the current
> state of the AT Protocol viewed through the lens of OpenAPI. This could enable
> the generation of client and server code for the AT Protocol in a variety of
> languages. 
>  How to use 
>  I want to see what it looks like 
>  A Swagger UI instance prepopulated with the current version of the OpenAPI types is available to preview .
> You can create a session (use an app password!), input your authentication token
> and experiment with authenticated queries. 
>  I want the types 
>  All you need is the spec/api.json file! You can reference it directly at this
> URL: 
>  https://raw.githubusercontent.com/rdmurphy/atproto-openapi-types/main/spec/api.json 
>  
>  Note: The path to this file is subject to change, at least for a little
> while. I'll try my best to not move it but cannot pretend it won't happen
> while this project is still young! 
>  
>  This file is regenerated every two hours
>  via a GitHub Action to keep it up to date with
> the latest changes to the AT Protocol. It sources the
>  bluesky-social/atproto repository
> directly. 
>  I want to generate code 
>  You'll need to use the OpenAPI generator of your choice. I've had luck with
>  openapi-typescript ! 
>  I want to generate the types locally 
>  You'll need to checkout this repository and
>  make sure Deno is installed .
> You'll also need to checkout a copy of the
>  bluesky-social/atproto repository
>  into this repo's directory. (Maybe one day I'll get fancy and set up
> submodules... but not today.) 
>  Then, run the following command: 
>  If you'd like to tweak the generator and see your changes live you can run the
> following command. It will watch for changes and re-run the script any time a
> file is updated: 
>  Known limitations 
>  It's currently not possible to represent the subscription type in OpenAPI. It
> appears the maintainers of the specification
>  have passed on the inclusion of any interfaces that are not strictly scoped to the HTTP protocol .
> (WebSockets are opened via a HTTP request, but I digress.)
>  AsyncAPI may be a better fit for this use case. 
>  Existing implementations 
>  
>  Bluesky-OpenAPI : Another AT
> Protocol to OpenAPI conversion by @trozzelle .
> It takes a slightly different approach to naming the schemas you may prefer! 
>  
>  License 
>  MIT
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  Explore 
>  
>  
> All features
>  
>  
>  
> Documentation
>  
>  
>  
> GitHub Skills
>  
>  
>  
> Blog
>  
>  
>  
>  
>  
>  
>  
>  
>  For 
>  
>  
> Enterprise
>  
>  
>  
> Teams
>  
>  
>  
> Startups
>  
>  
>  
> Education
>  
>  
>  
>  
>  By Solution 
>  
>  
> CI/CD &amp; Automation
>  
>  
>  
> DevOps
>  
>  
>  
> DevSecOps
>  
>  
>  
>  
>  Resources 
>  
>  
> Learning Pathways
>  
>  
>  
> White papers, Ebooks, Webinars
>  
>  
>  
> Customer Stories
>  
>  
>  
> Partners
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  Repositories 
>  
>  
> Topics
>  
>  
>  
> Trending
>  
>  
>  
> Collections
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  Available add-ons 
>  
>  
>  
>  Advanced Security 
> Enterprise-grade security features
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Enterprise-grade AI features
>  
>  
>  
>  
>  
>  Premium Support 
> Enterprise-grade 24/7 support
>  
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
> Sign up
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> BlushSocial
>  
>  / 
>  
>  atproto-tid 
>  
>  Public 
>  
>  
>  
>  
>  Notifications
>  
>  
>  
>  Fork
>  0 
>  
>  
>  
>  
>  
> Star
>  1 
>  
>  
>  
>  
>  
>  
>  
>  
>  
> Implementation of the AT Protocol Timestamp Identifiers (TIDs) in Clojure! 💙🌱
>  
>  
>  
>  1 
> star
>  
>  0 
> forks
>  
>  Branches 
>  
>  Tags 
>  
>  Activity 
>  
>  
>  
>  
> Star
>  
>  
>  
>  Notifications
>  
>  
>  
>  
>  
>  
>  
>  
>  Code 
>  
>  
>  
>  
>  Issues 
>  
>  
>  
>  Pull requests 
>  
>  
>  
>  Actions 
>  
>  
>  
>  
>  Projects 
>  
>  
>  
>  Security 
>  
>  
>  
>  Insights
> 
> AT Protocol Reference Implementation (TypeScript) 
>  Welcome friends! 
>  This repository contains Bluesky's reference implementation of AT Protocol, and of the app.bsky microblogging application service backend. 
>  What is in here? 
>  TypeScript Packages: 
>  
>  
>  
>  Package 
>  Docs 
>  NPM 
>  
>  
>  
>  
>  @atproto/api : client library 
>  README 
>  
>  
>  
>  @atproto/common-web : shared code and helpers which can run in web browsers 
>  README 
>  
>  
>  
>  @atproto/common : shared code and helpers which doesn't work in web browsers 
>  README 
>  
>  
>  
>  @atproto/crypto : cryptographic signing and key serialization 
>  README 
>  
>  
>  
>  @atproto/identity : DID and handle resolution 
>  README 
>  
>  
>  
>  @atproto/lexicon : schema definition language 
>  README 
>  
>  
>  
>  @atproto/repo : data storage structure, including MST 
>  README 
>  
>  
>  
>  @atproto/syntax : string parsers for identifiers 
>  README 
>  
>  
>  
>  @atproto/xrpc : client-side HTTP API helpers 
>  README 
>  
>  
>  
>  @atproto/xrpc-server : server-side HTTP API helpers 
>  README 
>  
>  
>  
>  
>  TypeScript Services: 
>  
>  pds : "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in packages/pds , with runtime wrapper in services/pds . See bluesky-social/pds for directions on self-hosting in the federation sandbox network . 
>  bsky : AppView implementation of the app.bsky.* API endpoints. Running on main network at api.bsky.app . Most implementation code in packages/bsky , with runtime wrapper in services/bsky . 
>  
>  Lexicons: for both the com.atproto.* and app.bsky.* are canonically versioned in this repo, for now, under ./lexicons/ . These are JSON files in the Lexicon schema definition language , similar to JSON Schema or OpenAPI. 
>  Interoperability Test Data: the language-neutral test files in ./interop-test-files/ may be useful for other protocol implementations to ensure that they follow the specification correctly 
>  The source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Go programming language source code is in bluesky-social/indigo , including the BGS implementation. 
>  Developer Quickstart 
>  We recommend nvm for managing Node.js installs. This project requires Node.js version 18. pnpm is used to manage the workspace of multiple packages. You can install it with npm install --global pnpm . 
>  There is a Makefile which can help with basic development tasks: 
>  # use existing nvm to install node 18 and pnpm 
> make nvm-setup
>  # pull dependencies and build all local packages 
> make deps
> make build
>  # run the tests, using Docker services as needed 
> make test 
>  # run a local PDS and AppView with fake test accounts and data 
>  # (this requires a global installation of `jq` and `docker`) 
> make run-dev-env
>  # show all other commands 
> make help 
>  About AT Protocol 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  If submitting a PR that includes a lexicon change, please get sign off on the lexicon change before doing the implementation. 
>  Issues are for bugs &amp; feature requests related to the TypeScript implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or frameworks used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team, and we'll respond promptly. See SECURITY.md for more info. 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT.txt or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE.txt or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> If you are using this library on the JVM platform, especially with Kotlin, we recommend that you migrate to kbsky . This library is being migrated to maintenance only. 
>  bsky4j 
>  
>  Java client library for the Bluesky /ATProtocol API. This can compile with google/j2objc to Objective-C library. (for iOS and Mac OS) 
>  How to use 
>  It is available with jitpack.io. 
>  allprojects {
> repositories {
> maven { url 'https://jitpack.io' }
> }
> }
> dependencies {
> compile 'com.github.uakihir0:bsky4j:x.y.z'
> }
>  
>  CreateSession 
>  Response &lt; ServerCreateSessionResponse &gt; response = BlueskyFactory 
> . getInstance ( Service . BSKY_SOCIAL . getUri ())
> . server (). createSession (
>  ServerCreateSessionRequest . builder ()
> . identifier ( "HANDLE" )
> . password ( "PASSWORD" )
> . build ()
> );
>  String accessJwt = response . get (). getAccessJwt (); 
>  SendFeed 
>  Response &lt; FeedPostResponse &gt; response = BlueskyFactory 
> . getInstance ( Service . BSKY_SOCIAL . getUri ())
> . feed (). post (
>  FeedPostRequest . builder ()
> . accessJwt ( accessJwt )
> . text ( "Hello World!!" )
> . build ()
> ); 
>  PLC Directory 
>  Response &lt; DIDDetails &gt; response = PLCDirectoryFactory 
> . getInstance (). getDIDDetails ( did );
>  System . out . println ( response . get (). getAlsoKnownAs (). get ( 0 )); 
>  Author 
>  
>  @uakihir0.com 
>  Twitter:@uakihir0 
>  
>  License 
>  This software is released under the MIT License, see LICENSE.txt.
> 
> atproto-website 
>  This repository contains the documentation for the AT Protocol, available to read at atproto.com . 
>  To read documentation for the Bluesky API, go to docs.bsky.app or this repo . 
>  Making edits to atproto.com 
>  
>  clone this repo 
>  run npm install 
>  run the development server with npm run dev or yarn dev 
>  open http://localhost:3000 with your browser. 
>  
>  
>  pages/index.js generates http://localhost:3000 -- start there if you'd like to make changes. 
>  The page auto-updates as you edit the file. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  Documentation text and the atproto specifications are under Creative Commons Attribution (CC-BY). 
>  Inline code examples, example data, and regular expressions are under Creative Commons Zero (CC-0, aka Public Domain) and copy/pasted without attribution. 
>  Please see LICENSE.txt with reminders about derivative works, and LICENSE-CC-BY.txt for a copy of license legal text.
> 
> $ bsky = new Bluesky (personalDataServer: 'https://bsky.social' );
>  // create a new account on the server 
>  $ sessionData = $ bsky -&gt; createAccount (
> email: 'nathanael.esayeas@protonmail.com' ,
> handle: 'codepoet.bsky.social' ,
> password: '************' 
> inviteCode: 'black-lives-matter',
> );
>  // if an existing session (accessed with 'bsky.session') was securely stored previously, then reuse that 
>  $ bsky -&gt; resumeSession (session: $ sessionData );
>  // if no old session was available, create a new one by logging in with password (App Password) 
>  $ sessionData = $ bsky -&gt; login (
> identifier: 'codepoet.bsky.social' ,
> password: '************' 
> );
>  $ bsky -&gt; post (text: 'My first post using ghostwriter/atprotocol for PHP.' );
>  // Feeds and content 
>  $ bsky -&gt; getTimeline ( $ params , $ opts )
>  $ bsky -&gt; getAuthorFeed ( $ params , $ opts )
>  $ bsky -&gt; getPostThread ( $ params , $ opts )
>  $ bsky -&gt; getPost ( $ params )
>  $ bsky -&gt; getPosts ( $ params , $ opts )
>  $ bsky -&gt; getLikes ( $ params , $ opts )
>  $ bsky -&gt; getRepostedBy ( $ params , $ opts )
>  $ bsky -&gt; post ( $ record )
>  $ bsky -&gt; deletePost ( $ postUri )
>  $ bsky -&gt; like ( $ uri , cid)
>  $ bsky -&gt; deleteLike ( $ likeUri )
>  $ bsky -&gt; repost ( $ uri , cid)
>  $ bsky -&gt; deleteRepost ( $ repostUri )
>  $ bsky -&gt; uploadBlob ( $ data , $ opts )
>  // Social graph 
>  $ bsky -&gt; getFollows ( $ params , $ opts )
>  $ bsky -&gt; getFollowers ( $ params , $ opts )
>  $ bsky -&gt; follow ( $ did )
>  $ bsky -&gt; deleteFollow ( $ followUri )
>  // Actors 
>  $ bsky -&gt; getProfile ( $ params , $ opts )
>  $ bsky -&gt; upsertProfile ( $ updateFn )
>  $ bsky -&gt; getProfiles ( $ params , $ opts )
>  $ bsky -&gt; getSuggestions ( $ params , $ opts )
>  $ bsky -&gt; searchActors ( $ params , $ opts )
>  $ bsky -&gt; mute ( $ did )
>  $ bsky -&gt; unmute ( $ did )
>  $ bsky -&gt; muteModList ( $ listUri )
>  $ bsky -&gt; unmuteModList ( $ listUri )
>  $ bsky -&gt; blockModList ( $ listUri )
>  $ bsky -&gt; unblockModList ( $ listUri )
>  // Notifications 
>  $ bsky -&gt; listNotifications ( $ params , $ opts )
>  $ bsky -&gt; countUnreadNotifications ( $ params , $ opts )
>  $ bsky -&gt; updateSeenNotifications ()
>  // Identity 
>  $ bsky -&gt; resolveHandle ( $ params , $ opts )
>  $ bsky -&gt; updateHandle ( $ params , $ opts )
>  // Session management 
>  $ bsky -&gt; createAccount ( $ params )
>  $ bsky -&gt; login ( $ params )
>  $ bsky -&gt; resumeSession ( $ session )
>  // Excepions 
>  // { "name": "InvalidHandle" }, 
>  // { "name": "InvalidPassword" }, 
>  // { "name": "InvalidInviteCode" }, 
>  // { "name": "HandleNotAvailable" }, 
>  // { "name": "UnsupportedDomain" }, 
>  // { "name": "UnresolvableDid" }, 
>  // { "name": "IncompatibleDidDoc" } 
>  // TODO: extract the headers from the lexicon objects If you discover any security-related issues, please use Security Advisories instead of using the issue tracker.
> 
> 1m 7s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 4m 33s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 2s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 2s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 57s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 15s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 11s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 4m 13s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 5s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 10s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 43s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 11s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 19s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 12s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 57s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 23s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 31s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 58s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 3m 53s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 47s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 11s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 26s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 2m 26s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 47s
>  
>  
>  
>  
>  
>  
>  
>  
>  
> 1m 52s
> 
> ozone 
>  Overview 
>  The Ozone project for the AT Protocol consists of 3 components: 
>  
>  A Gradle plugin to compile AT Protocol schemas into usable Kotlin classes. 
>  Multiplatform APIs for the AT Protocol spec that can be used with any compatible service, including Bluesky Social .
>  
>  Supports Android, JVM, JavaScript, and iOS. 
>  
>  
>  Example client apps that demonstrate usage of those APIs. 
>  
>  
>  Warning 
>  🚧 🚧 🚧 Everything in here is very much a work-in-progress!
> The upstream schemas are still subject to breaking
> changes and may break at any moment if used in production code. Use at your own risk! 
>  
>  Why "Ozone"? 
>  O 3 exists at all levels in the ATmosphere . 
>  No relation to the moderation tools also named Ozone . 
>  Bluesky Social Bindings 
>  Documentation is available at ozone.christian.sh . 
>  Java / Kotlin 
>  // build.gradle[.kts] 
> dependencies {
> api( " sh.christian.ozone:bluesky:0.1.0 " )
> } 
>  Swift / Objective-C 
>  In Xcode, select File &gt; Add Packages and enter https://github.com/christiandeange/BlueskyAPI 
>  Gradle Plugin 
>  In addition to shipping the lexicons that define the official Bluesky API, this project also includes a Gradle Plugin that allows you to bring your own lexicon definitions and generate any set of AT Protocol bindings from them. 
>  // build.gradle[.kts] 
> plugins {
> id( " sh.christian.ozone.generator " ) version " 0.1.0 " 
> }
> dependencies {
>  // This is where you have your schema files stored in your project. 
> lexicons(fileTree( " lexicons " ) { include( " **/*.json " ) })
> }
> lexicons {
>  // Generates an additional interface for the target schemas. 
>  // This method can be called more than once to generate multiple API interfaces. 
> generateApi( " BlueskyApi " ) {
>  // Determines the package name of the generated API. Defaults to "sh.christian.ozone". 
> packageName.set( " com.example.myapp " )
>  // Generates an additional class that implements this interface by sending corresponding 
>  // XRPC requests to a provided host conforming to the AT Protocol. 
>  // Inherits the same package name as the generated interface. 
> withKtorImplementation( " XrpcBlueskyApi " )
>  // Determines the return type for each generated API method. Defaults to Raw. 
>  // - Raw: the raw data type 
>  // - Result: Result&lt;T&gt; 
>  // - Response: AtpResponse&lt;T&gt; 
> returnType.set( ApiReturnType . Result )
>  // Determines whether the generated methods should be marked as suspend functions. 
>  // When generating a Ktor implementation as well, execution will block the current thread 
>  // for non-suspending methods. Defaults to true. 
> suspending.set( true )
> }
>  // File path where Kotlin source files will be written to. Defaults to "/build/generated/lexicons". 
> outputDirectory.set(project.layout.buildDirectory.dir( " out " ))
> }
> 
> ## Welcome to the Atmosphere
> 
> The AT Protocol is an open, decentralized network for building social applications.
> 
> ### Quickstart
> 
> Create an application and start building.
> 
> [Read more](/guides/applications)
> 
> ### Self-host
> 
> Learn how to set up your own personal data server.
> 
> [Read more](/guides/self-hosting)
> 
> ### Glossary
> 
> Definitions for all the terminology used in AT Protocol.
> 
> [Read more](/guides/glossary)
> 
> ### FAQ
> 
> Frequently Asked Questions about the Atmosphere.
> 
> [Read more](/guides/faq)
> 
> ### [Repository](/specs/repository)
> 
> Self-authenticating storage for public account content.
> 
> ### [Lexicon](/specs/lexicon)
> 
> A schema definition language for ATProto.
> 
> ### [URI Scheme](/specs/at-uri-scheme)
> 
> A URI scheme for addressing ATProto repository data.
> 
> Guide
> 
> What's a PDS? an AppView? a DID? If you're feeling a little bowled over by new concepts, give this glossary a look.
> 
> [Keep reading](/guides/glossary)
> 
> Guide
> 
> In this guide, we build a simple multi-user app that publishes your current "status" as an emoji.
> 
> [Keep reading](/guides/applications)
> 
> Article
> 
> In this article we explore AT Proto from the perspective of distributed backend engineering.
> 
> [Keep reading](/articles/atproto-for-distsys-engineers)
> 
> Guide
> 
> This guide will introduce you to Lexicon and get you started with building your own schemas.
> 
> [Keep reading](/guides/lexicon)
> 
> Go to [docs.bsky.app](https://docs.bsky.app/) for Bluesky-specific documentation.
> 
> ## AT Protocol Reference Implementation (TypeScript)
> 
> [](#at-protocol-reference-implementation-typescript)
> 
> Welcome friends!
> 
> This repository contains Bluesky's reference implementation of AT Protocol, and of the `app.bsky` microblogging application service backend.
> 
> ## What is in here?
> 
> [](#what-is-in-here)
> 
> **TypeScript Packages:**
> 
> | Package                                                                     | Docs                                                                       | NPM                                                                                                                                                                                                                                                                  |
> | --------------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | @atproto/api: client library                                                | [README](/bluesky-social/atproto/blob/main/packages/api/README.md)         | [![NPM](https://camo.githubusercontent.com/6327031e34807d5a06ce855d6d0e41383d3b6078e86dfad37d05b27db130ec99/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f617069)](https://www.npmjs.com/package/@atproto/api)                         |
> | @atproto/common-web: shared code and helpers which can run in web browsers  | [README](/bluesky-social/atproto/blob/main/packages/common-web/README.md)  | [![NPM](https://camo.githubusercontent.com/70d89e009507817dbf8da9d1c540817ee9b40f2a771b4aa9de10e0b9ce93ff56/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f636f6d6d6f6e2d776562)](https://www.npmjs.com/package/@atproto/common-web)    |
> | @atproto/common: shared code and helpers which doesn't work in web browsers | [README](/bluesky-social/atproto/blob/main/packages/common/README.md)      | [![NPM](https://camo.githubusercontent.com/a4254843e8a1ea731e231d395ce7dd3189e5eaf9456d456fd1cb73e0a7441435/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f636f6d6d6f6e)](https://www.npmjs.com/package/@atproto/common)                |
> | @atproto/crypto: cryptographic signing and key serialization                | [README](/bluesky-social/atproto/blob/main/packages/crypto/README.md)      | [![NPM](https://camo.githubusercontent.com/925a4f571cce4e38c30a609a50bbe95dadaceb69f57e823e2999b578a30d701b/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f63727970746f)](https://www.npmjs.com/package/@atproto/crypto)                |
> | @atproto/identity: DID and handle resolution                                | [README](/bluesky-social/atproto/blob/main/packages/identity/README.md)    | [![NPM](https://camo.githubusercontent.com/ad1ac05d36585c99e31447f39c8dabc228e2e417345330a19e7fdb151f79ee8f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f6964656e74697479)](https://www.npmjs.com/package/@atproto/identity)          |
> | @atproto/lexicon: schema definition language                                | [README](/bluesky-social/atproto/blob/main/packages/lexicon/README.md)     | [![NPM](https://camo.githubusercontent.com/e9cbd3c2860d659dc6459b84232144765ab12870470f36e2c916b462a81957b0/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f6c657869636f6e)](https://www.npmjs.com/package/@atproto/lexicon)             |
> | @atproto/repo: data storage structure, including MST                        | [README](/bluesky-social/atproto/blob/main/packages/repo/README.md)        | [![NPM](https://camo.githubusercontent.com/539b08001d75662650ad8e13e2c7d3a0b3d01e8f9de005e7e549f79757794e26/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f7265706f)](https://www.npmjs.com/package/@atproto/repo)                      |
> | @atproto/syntax: string parsers for identifiers                             | [README](/bluesky-social/atproto/blob/main/packages/syntax/README.md)      | [![NPM](https://camo.githubusercontent.com/21be3b53af18c9b5378e9bf17c2cf477fa9a87efa0a2bfdc510e8513f58c7902/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f73796e746178)](https://www.npmjs.com/package/@atproto/syntax)                |
> | @atproto/xrpc: client-side HTTP API helpers                                 | [README](/bluesky-social/atproto/blob/main/packages/xrpc/README.md)        | [![NPM](https://camo.githubusercontent.com/c34b17f0a5b255f0951a320171f339cdfcb4a520329f0bef5b787ec65a1f2f0f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f78727063)](https://www.npmjs.com/package/@atproto/xrpc)                      |
> | @atproto/xrpc-server: server-side HTTP API helpers                          | [README](/bluesky-social/atproto/blob/main/packages/xrpc-server/README.md) | [![NPM](https://camo.githubusercontent.com/4519890d16577ab0840d6975df83df18ea39e63ee6963eb2f71df9951d435d65/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f787270632d736572766572)](https://www.npmjs.com/package/@atproto/xrpc-server) |
> 
> **TypeScript Services:**
> 
> * `pds`: "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in `packages/pds`, with runtime wrapper in `services/pds`. See [bluesky-social/pds](https://github.com/bluesky-social/pds) for directions on self-hosting.
> * `bsky`: AppView implementation of the `app.bsky.*` API endpoints. Running on main network at `api.bsky.app`. Most implementation code in `packages/bsky`, with runtime wrapper in `services/bsky`.
> 
> **Lexicons:** for both the `com.atproto.*` and `app.bsky.*` are canonically versioned in this repo, for now, under `./lexicons/`. These are JSON files in the [Lexicon schema definition language](https://atproto.com/specs/lexicon), similar to JSON Schema or OpenAPI.
> 
> **Interoperability Test Data:** the language-neutral test files in `./interop-test-files/` may be useful for other protocol implementations to ensure that they follow the specification correctly
> 
> The source code for the Bluesky Social client app (for web and mobile) can be found at [bluesky-social/social-app](https://github.com/bluesky-social/social-app).
> 
> Go programming language source code is in [bluesky-social/indigo](https://github.com/bluesky-social/indigo), including the BGS implementation.
> 
> ## Developer Quickstart
> 
> [](#developer-quickstart)
> 
> We recommend [nvm](https://github.com/nvm-sh/nvm) for managing Node.js installs. This project requires Node.js version 18\. `pnpm` is used to manage the workspace of multiple packages. You can install it with `npm install --global pnpm`.
> 
> There is a Makefile which can help with basic development tasks:
> 
> # use existing nvm to install node 18 and pnpm
> make nvm-setup
> 
> # pull dependencies and build all local packages
> make deps
> make build
> 
> # run the tests, using Docker services as needed
> make test
> 
> # run a local PDS and AppView with fake test accounts and data
> # (this requires a global installation of `jq` and `docker`)
> make run-dev-env
> 
> # show all other commands
> make help
> 
> ## About AT Protocol
> 
> [](#about-at-protocol)
> 
> The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by [Bluesky PBC](https://bsky.social/). Learn more at:
> 
> * [Overview and Guides](https://atproto.com/guides/overview) 👈 Best starting point
> * [Github Discussions](https://github.com/bluesky-social/atproto/discussions) 👈 Great place to ask questions
> * [Protocol Specifications](https://atproto.com/specs/atp)
> * [Blogpost on self-authenticating data structures](https://bsky.social/about/blog/3-6-2022-a-self-authenticating-social-protocol)
> 
> The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is `app.bsky.*`.
> 
> ## Contributions
> 
> [](#contributions)
> 
> > While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review.
> 
> **Rules:**
> 
> * We may not respond to your issue or PR.
> * We may close an issue or PR without much feedback.
> * We may lock discussions or contributions if our attention is getting DDOSed.
> * We do not provide support for build issues.
> 
> **Guidelines:**
> 
> * Check for existing issues before filing a new one, please.
> * Open an issue and give some time for discussion before submitting a PR.
> * If submitting a PR that includes a lexicon change, please get sign off on the lexicon change _before_ doing the implementation.
> * Issues are for bugs & feature requests related to the TypeScript implementation of atproto and related services.  
>    * For high-level discussions, please use the [Discussion Forum](https://github.com/bluesky-social/atproto/discussions).  
>    * For client issues, please use the relevant [social-app](https://github.com/bluesky-social/social-app) repo.
> * Stay away from PRs that:  
>    * Refactor large parts of the codebase  
>    * Add entirely new features without prior discussion  
>    * Change the tooling or frameworks used without prior discussion  
>    * Introduce new unnecessary dependencies
> 
> Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth.
> 
> ## Are you a developer interested in building on atproto?
> 
> [](#are-you-a-developer-interested-in-building-on-atproto)
> 
> Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more.
> 
> ## Security disclosures
> 
> [](#security-disclosures)
> 
> If you discover any security issues, please send an email to [security@bsky.app](mailto:security@bsky.app). The email is automatically CCed to the entire team, and we'll respond promptly. See [SECURITY.md](https://github.com/bluesky-social/atproto/blob/main/SECURITY.md) for more info.
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> ## ATP API
> 
> [](#atp-api)
> 
> This API is a client for ATProtocol servers. It communicates using HTTP. It includes:
> 
> * ✔️ APIs for ATProto and Bluesky.
> * ✔️ Validation and complete typescript types.
> * ✔️ Session management.
> * ✔️ A RichText library.
> 
> ## Getting started
> 
> [](#getting-started)
> 
> First install the package:
> 
> Then in your application:
> 
> import { AtpAgent } from '@atproto/api'
> 
> const agent = new AtpAgent({ service: 'https://example.com' })
> 
> ## Usage
> 
> [](#usage)
> 
> ### Session management
> 
> [](#session-management)
> 
> You'll need an authenticated session for most API calls. There are two ways to manage sessions:
> 
> 1. [App password based session management](#app-password-based-session-management)
> 2. [OAuth based session management](#oauth-based-session-management)
> 
> #### App password based session management
> 
> [](#app-password-based-session-management)
> 
> Username / password based authentication can be performed using the `AtpAgent`class.
> 
> Caution
> 
> This method is deprecated in favor of OAuth based session management. It is recommended to use OAuth based session management (through the`@atproto/oauth-client-*` packages).
> 
> import { AtpAgent, AtpSessionEvent, AtpSessionData } from '@atproto/api'
> 
> // configure connection to the server, without account authentication
> const agent = new AtpAgent({
>   service: 'https://example.com',
>   persistSession: (evt: AtpSessionEvent, sess?: AtpSessionData) => {
>     // store the session-data for reuse
>   },
> })
> 
> // Change the agent state to an authenticated state either by:
> 
> // 1) creating a new account on the server.
> await agent.createAccount({
>   email: 'alice@mail.com',
>   password: 'hunter2',
>   handle: 'alice.example.com',
>   inviteCode: 'some-code-12345-abcde',
> })
> 
> // 2) if an existing session was securely stored previously, then reuse that to resume the session.
> await agent.resumeSession(savedSessionData)
> 
> // 3) if no old session was available, create a new one by logging in with password (App Password)
> await agent.login({
>   identifier: 'alice@mail.com',
>   password: 'hunter2',
> })
> 
> #### OAuth based session management
> 
> [](#oauth-based-session-management)
> 
> Depending on the environment used by your application, different OAuth clients are available:
> 
> * [@atproto/oauth-client-browser](https://www.npmjs.com/package/@atproto/oauth-client-browser): for the browser.
> * [@atproto/oauth-client-node](https://www.npmjs.com/package/@atproto/oauth-client-node): for Node.js.
> * [@atproto/oauth-client](https://www.npmjs.com/package/@atproto/oauth-client): Lower level; compatible with most JS engines.
> 
> Every `@atproto/oauth-client-*` implementation has a different way to obtain an`OAuthSession` instance that can be used to instantiate an `Agent` (from`@atproto/api`). Here is an example restoring a previously saved session:
> 
> import { Agent } from '@atproto/api'
> import { OAuthClient } from '@atproto/oauth-client'
> 
> const oauthClient = new OAuthClient({
>   // ...
> })
> 
> const oauthSession = await oauthClient.restore('did:plc:123')
> 
> // Instantiate the api Agent using an OAuthSession
> const agent = new Agent(oauthSession)
> 
> ### API calls
> 
> [](#api-calls)
> 
> The agent includes methods for many common operations, including:
> 
> // The DID of the user currently authenticated (or undefined)
> agent.did
> agent.accountDid // Throws if the user is not authenticated
> 
> // Feeds and content
> await agent.getTimeline(params, opts)
> await agent.getAuthorFeed(params, opts)
> await agent.getPostThread(params, opts)
> await agent.getPost(params)
> await agent.getPosts(params, opts)
> await agent.getLikes(params, opts)
> await agent.getRepostedBy(params, opts)
> await agent.post(record)
> await agent.deletePost(postUri)
> await agent.like(uri, cid)
> await agent.deleteLike(likeUri)
> await agent.repost(uri, cid)
> await agent.deleteRepost(repostUri)
> await agent.uploadBlob(data, opts)
> 
> // Social graph
> await agent.getFollows(params, opts)
> await agent.getFollowers(params, opts)
> await agent.follow(did)
> await agent.deleteFollow(followUri)
> 
> // Actors
> await agent.getProfile(params, opts)
> await agent.upsertProfile(updateFn)
> await agent.getProfiles(params, opts)
> await agent.getSuggestions(params, opts)
> await agent.searchActors(params, opts)
> await agent.searchActorsTypeahead(params, opts)
> await agent.mute(did)
> await agent.unmute(did)
> await agent.muteModList(listUri)
> await agent.unmuteModList(listUri)
> await agent.blockModList(listUri)
> await agent.unblockModList(listUri)
> 
> // Notifications
> await agent.listNotifications(params, opts)
> await agent.countUnreadNotifications(params, opts)
> await agent.updateSeenNotifications()
> 
> // Identity
> await agent.resolveHandle(params, opts)
> await agent.updateHandle(params, opts)
> 
> // Legacy: Session management should be performed through the SessionManager
> // rather than the Agent instance.
> if (agent instanceof AtpAgent) {
>   // AtpAgent instances support using different sessions during their lifetime
>   await agent.createAccount({ ... }) // session a
>   await agent.login({ ... }) // session b
>   await agent.resumeSession(savedSession) // session c
> }
> 
> ### Validation and types
> 
> [](#validation-and-types)
> 
> The package includes a complete types system which includes validation and type-guards. For example, to validate a post record:
> 
> import { AppBskyFeedPost } from '@atproto/api'
> 
> const post = {...}
> if (AppBskyFeedPost.isRecord(post)) {
>   // typescript now recognizes `post` as a AppBskyFeedPost.Record
>   // however -- we still need to validate it
>   const res = AppBskyFeedPost.validateRecord(post)
>   if (res.success) {
>     // a valid record
>   } else {
>     // something is wrong
>     console.log(res.error)
>   }
> }
> 
> ### Rich text
> 
> [](#rich-text)
> 
> Some records (ie posts) use the `app.bsky.richtext` lexicon. At the moment richtext is only used for links and mentions, but it will be extended over time to include bold, italic, and so on.
> 
> ℹ️ It is **strongly** recommended to use this package's `RichText` library. Javascript encodes strings in utf16 while the protocol (and most other programming environments) use utf8\. Converting between the two is challenging, but `RichText` handles that for you.
> 
> import { RichText } from '@atproto/api'
> 
> // creating richtext
> const rt = new RichText({
>   text: 'Hello @alice.com, check out this link: https://example.com',
> })
> await rt.detectFacets(agent) // automatically detects mentions and links
> const postRecord = {
>   $type: 'app.bsky.feed.post',
>   text: rt.text,
>   facets: rt.facets,
>   createdAt: new Date().toISOString(),
> }
> 
> // rendering as markdown
> let markdown = ''
> for (const segment of rt.segments()) {
>   if (segment.isLink()) {
>     markdown += `[${segment.text}](${segment.link?.uri})`
>   } else if (segment.isMention()) {
>     markdown += `[${segment.text}](https://my-bsky-app.com/user/${segment.mention?.did})`
>   } else {
>     markdown += segment.text
>   }
> }
> 
> // calculating string lengths
> const rt2 = new RichText({ text: 'Hello' })
> console.log(rt2.length) // => 5
> console.log(rt2.graphemeLength) // => 5
> const rt3 = new RichText({ text: '👨‍👩‍👧‍👧' })
> console.log(rt3.length) // => 25
> console.log(rt3.graphemeLength) // => 1
> 
> ### Moderation
> 
> [](#moderation)
> 
> Applying the moderation system is a challenging task, but we've done our best to simplify it for you. The Moderation API helps handle a wide range of tasks, including:
> 
> * Moderator labeling
> * User muting (including mutelists)
> * User blocking
> * Mutewords
> * Hidden posts
> 
> For more information, see the [Moderation Documentation](/bluesky-social/atproto/blob/main/packages/api/docs/moderation.md).
> 
> import { moderatePost } from '@atproto/api'
> 
> // First get the user's moderation prefs and their label definitions
> // =
> 
> const prefs = await agent.getPreferences()
> const labelDefs = await agent.getLabelDefinitions(prefs)
> 
> // We call the appropriate moderation function for the content
> // =
> 
> const postMod = moderatePost(postView, {
>   userDid: agent.session.did,
>   moderationPrefs: prefs.moderationPrefs,
>   labelDefs,
> })
> 
> // We then use the output to decide how to affect rendering
> // =
> 
> // in feeds
> if (postMod.ui('contentList').filter) {
>   // don't include in feeds
> }
> if (postMod.ui('contentList').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentList').blurs to explain)
>   if (postMod.ui('contentList').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> if (postMod.ui('contentList').alert || postMod.ui('contentList').inform) {
>   // render warnings on the post
>   // find the warnings in postMod.ui('contentList').alerts and postMod.ui('contentList').informs
> }
> 
> // viewed directly
> if (postMod.ui('contentView').filter) {
>   // don't include in feeds
> }
> if (postMod.ui('contentView').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentView').blurs to explain)
>   if (postMod.ui('contentView').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> if (postMod.ui('contentView').alert || postMod.ui('contentView').inform) {
>   // render warnings on the post
>   // find the warnings in postMod.ui('contentView').alerts and postMod.ui('contentView').informs
> }
> 
> // post embeds in all contexts
> if (postMod.ui('contentMedia').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentMedia').blurs to explain)
>   if (postMod.ui('contentMedia').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> 
> ## Advanced
> 
> [](#advanced)
> 
> ### Advanced API calls
> 
> [](#advanced-api-calls)
> 
> The methods above are convenience wrappers. It covers most but not all available methods.
> 
> The AT Protocol identifies methods and records with reverse-DNS names. You can use them on the agent as well:
> 
> const res1 = await agent.com.atproto.repo.createRecord({
>   did: alice.did,
>   collection: 'app.bsky.feed.post',
>   record: {
>     $type: 'app.bsky.feed.post',
>     text: 'Hello, world!',
>     createdAt: new Date().toISOString(),
>   },
> })
> const res2 = await agent.com.atproto.repo.listRecords({
>   repo: alice.did,
>   collection: 'app.bsky.feed.post',
> })
> 
> const res3 = await agent.app.bsky.feed.post.create(
>   { repo: alice.did },
>   {
>     text: 'Hello, world!',
>     createdAt: new Date().toISOString(),
>   },
> )
> const res4 = await agent.app.bsky.feed.post.list({ repo: alice.did })
> 
> ### Non-browser configuration
> 
> [](#non-browser-configuration)
> 
> If your environment doesn't have a built-in `fetch` implementation, you'll need to provide one. This will typically be done through a polyfill.
> 
> ### Bring your own fetch
> 
> [](#bring-your-own-fetch)
> 
> If you want to provide your own `fetch` implementation, you can do so by instantiating the sessionManager with a custom fetch implementation:
> 
> import { AtpAgent } from '@atproto/api'
> 
> const myFetch = (input: RequestInfo | URL, init?: RequestInit) => {
>   console.log('requesting', input)
>   const response = await globalThis.fetch(input, init)
>   console.log('got response', response)
>   return response
> }
> 
> const agent = new AtpAgent({
>   service: 'https://example.com',
>   fetch: myFetch,
> })
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> [![photo](https://camo.githubusercontent.com/bda2c3676213507b76185ad1b791584739dedea5aa13ddc971fd41143230c128/68747470733a2f2f7374617469632e626e6577626f6c642e6e65742f746d702f696e6469676f5f73657261632e6a706567)](https://camo.githubusercontent.com/bda2c3676213507b76185ad1b791584739dedea5aa13ddc971fd41143230c128/68747470733a2f2f7374617469632e626e6577626f6c642e6e65742f746d702f696e6469676f5f73657261632e6a706567)
> 
> ## indigo: atproto libraries and services in golang
> 
> [](#indigo-atproto-libraries-and-services-in-golang)
> 
> Some Bluesky software is developed in Typescript, and lives in the [bluesky-social/atproto](https://github.com/bluesky-social/atproto) repository. Some is developed in Go, and lives here.
> 
> ## What is in here?
> 
> [](#what-is-in-here)
> 
> **Go Services:**
> 
> * **bigsky** ([README](/bluesky-social/indigo/blob/main/cmd/bigsky/README.md)): relay reference implementation, running at `bsky.network`
> * **palomar** ([README](/bluesky-social/indigo/blob/main/cmd/palomar/README.md)): fulltext search service for [https://bsky.app](https://bsky.app/)
> * **hepa** ([README](/bluesky-social/indigo/blob/main/cmd/hepa/README.md)): auto-moderation bot for [Ozone](https://ozone.tools/)
> 
> **Go Packages:**
> 
> > ⚠️ All the packages in this repository are under active development. Features and software interfaces have not stabilized and may break or be removed.
> 
> | Package                                                    | Docs                                                                                                                                                                                                                                                                                                                                                      |
> | ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | api/atproto: generated types for com.atproto.\* Lexicons   | [![PkgGoDev](https://camo.githubusercontent.com/1632469fde5392f6b858e026a5be41969d8f563923a7ff1f3aedfdeddc607a6b/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f6170692f617470726f746f)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/api/atproto)                |
> | api/bsky: generated types for app.bsky.\* Lexicons         | [![PkgGoDev](https://camo.githubusercontent.com/eaf21e8f86ab5f8a7fc9241993ae5d5cccd10f5a2070e22a77fcc7fa5b88f875/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f6170692f62736b79)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/api/bsky)                         |
> | atproto/crypto: crytographic signing and key serialization | [![PkgGoDev](https://camo.githubusercontent.com/83e162c36fb08a306eb3a1e8c0a092b5f8ad9c5dd95c9ac15830e305c5cfb3e5/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f617470726f746f2f63727970746f)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/atproto/crypto)       |
> | atproto/identity: DID and handle resolution                | [![PkgGoDev](https://camo.githubusercontent.com/27d0da10955c6d294d5d1c1622b0897a44a33a44cfe3ad3d93d8e511ad76a92c/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f617470726f746f2f6964656e74697479)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/atproto/identity) |
> | atproto/syntax: string types and parsers for identifiers   | [![PkgGoDev](https://camo.githubusercontent.com/1ff3a5a270db861a1ee17940c3586752247a3b40eaad728c7247f5e42425af9e/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f617470726f746f2f73796e746178)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/atproto/syntax)       |
> | mst: Merkle Search Tree implementation                     | [![PkgGoDev](https://camo.githubusercontent.com/46a2a2d524bc7101010c93012d58f1faf86d6b4ed747c1f690e64033b3834927/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f6d7374)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/mst)                                        |
> | repo: account data storage                                 | [![PkgGoDev](https://camo.githubusercontent.com/d104d4090dd0d977545594a555d6a8ff82e2aa1bbced735696a10d9aacdc2b3a/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f7265706f)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/repo)                                     |
> | xrpc: HTTP API client                                      | [![PkgGoDev](https://camo.githubusercontent.com/3a54940458af732495e8d285f818157e61512c97ecaba5cbd9bbba867fddf5a0/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f78727063)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/xrpc)                                     |
> 
> The TypeScript reference implementation, including PDS and bsky AppView services, is at [bluesky-social/atproto](https://github.com/bluesky-social/atproto). Source code for the Bluesky Social client app (for web and mobile) can be found at [bluesky-social/social-app](https://github.com/bluesky-social/social-app).
> 
> ## Development Quickstart
> 
> [](#development-quickstart)
> 
> First, you will need the Go toolchain installed. We develop using the latest stable version of the language.
> 
> The Makefile provides wrapper commands for basic development:
> 
> ```
> make build
> make test
> make fmt
> make lint
> 
> ```
> 
> Individual commands can be run like:
> 
> The [HACKING](/bluesky-social/indigo/blob/main/HACKING.md) file has a list of commands and packages in this repository and some other development tips.
> 
> ## What is atproto?
> 
> [](#what-is-atproto)
> 
> _not to be confused with the [AT command set](https://en.wikipedia.org/wiki/Hayes%5Fcommand%5Fset) or [Adenosine triphosphate](https://en.wikipedia.org/wiki/Adenosine%5Ftriphosphate)_
> 
> The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by [Bluesky PBC](https://bsky.social/). Learn more at:
> 
> * [Overview and Guides](https://atproto.com/guides/overview) 👈 Best starting point
> * [Github Discussions](https://github.com/bluesky-social/atproto/discussions) 👈 Great place to ask questions
> * [Protocol Specifications](https://atproto.com/specs/atp)
> * [Blogpost on self-authenticating data structures](https://bsky.social/about/blog/3-6-2022-a-self-authenticating-social-protocol)
> 
> The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is `app.bsky.*`.
> 
> ## Contributions
> 
> [](#contributions)
> 
> > While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review.
> 
> **Rules:**
> 
> * We may not respond to your issue or PR.
> * We may close an issue or PR without much feedback.
> * We may lock discussions or contributions if our attention is getting DDOSed.
> * We do not provide support for build issues.
> 
> **Guidelines:**
> 
> * Check for existing issues before filing a new one, please.
> * Open an issue and give some time for discussion before submitting a PR.
> * Issues are for bugs & feature requests related to the golang implementation of atproto and related services.  
>    * For high-level discussions, please use the [Discussion Forum](https://github.com/bluesky-social/atproto/discussions).  
>    * For client issues, please use the relevant [social-app](https://github.com/bluesky-social/social-app) repo.
> * Stay away from PRs that:  
>    * Refactor large parts of the codebase  
>    * Add entirely new features without prior discussion  
>    * Change the tooling or libraries used without prior discussion  
>    * Introduce new unnecessary dependencies
> 
> Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth.
> 
> ## Are you a developer interested in building on atproto?
> 
> [](#are-you-a-developer-interested-in-building-on-atproto)
> 
> Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more.
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT](https://github.com/bluesky-social/indigo/blob/main/LICENSE-MIT) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE](https://github.com/bluesky-social/indigo/blob/main/LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> [ ![Logo of atproto SDK for Python by Midjourney'](https://github.com/MarshalX/atproto/raw/main/.github/images/logo.png) ](https://github.com/MarshalX/atproto)   
> **Autogenerated from lexicons, well type hinted, documented, sync and async SDK for Python**   
> [ Examples](https://github.com/MarshalX/atproto/tree/main/examples) •[ Documentation](https://atproto.blue/) •[ Discord Bluesky API](https://discord.gg/PCyVJXU9jN) 
> 
> ## The AT Protocol SDK
> 
> [](#the-at-protocol-sdk)
> 
> > ⚠️ Under construction. Until the 1.0.0 release compatibility between versions is not guaranteed.
> 
> Code snippet:
> 
> from atproto import Client, client_utils
> 
> 
> def main():
>     client = Client()
>     profile = client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
>     
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = client.send_post(text)
>     client.like(post.uri, post.cid)
> 
> 
> if __name__ == '__main__':
>     main()
> 
> Code snippet of async version 
> 
> import asyncio
> 
> from atproto import AsyncClient, client_utils
> 
> 
> async def main():
>     client = AsyncClient()
>     profile = await client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
> 
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = await client.send_post(text)
>     await client.like(post.uri, post.cid)
> 
>     
> if __name__ == '__main__':
>     # use run() for a higher Python version
>     asyncio.get_event_loop().run_until_complete(main())
> 
> 💬 [Direct Messages (Chats)](https://atproto.blue/en/latest/dm.html)
> 
> 🍿 [Example project with custom feed generator](https://github.com/MarshalX/bluesky-feed-generator)
> 
> 🔥 [Firehose data streaming is available](https://atproto.blue/en/latest/atproto%5Ffirehose/index.html)
> 
> 🌐 [Identity resolvers for DID and Handle](https://atproto.blue/en/latest/atproto%5Fidentity/index.html)
> 
> ### Introduction
> 
> [](#introduction)
> 
> This SDK attempts to implement everything that provides ATProto. There is support for Lexicon Schemes, XRPC clients, Firehose, Identity, DID keys, signatures, and more. All models, queries, and procedures are generated automatically. The main focus is on the lexicons of atproto.com and bsky.app, but it doesn't have a vendor lock on it. Feel free to use the code generator for your own lexicon schemes. The SDK also provides utilities to work with CID, NSID, AT URI Schemes, DAG-CBOR, CAR files, DID Documents and more.
> 
> ### Requirements
> 
> [](#requirements)
> 
> * Python 3.8 or higher.
> 
> ### Installing
> 
> [](#installing)
> 
> ### Quick start
> 
> [](#quick-start)
> 
> First of all, you need to create the instance of the XRPC Client. To do so, you have two major options: asynchronous and synchronous. The difference is only in the import and how you call the methods. If you are not familiar with async, use sync instead.
> 
> For sync:
> 
> from atproto import Client
> 
> client = Client()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # Client('https://example.com')
> 
> For async:
> 
> from atproto import AsyncClient
> 
> client = AsyncClient()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # AsyncClient('https://example.com')
> 
> In the snippets below, only the sync version will be presented.
> 
> Right after the creation of the Client instance, you will probably want to access the full API and perform actions by profile. To achieve this, you should log into the network using your handle and password. The password could be app-specific.
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> You are awesome! Now feel free to pick any high-level method that you want and try it out!
> 
> Code to send a post:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> client.send_post(text='Hello World!')
> 
> Useful links to continue:
> 
> * [List of all methods with documentation](https://atproto.readthedocs.io/en/latest/atproto%5Fclient/index.html).
> * [Examples of using the methods](https://github.com/MarshalX/atproto/tree/main/examples).
> 
> ### SDK structure
> 
> [](#sdk-structure)
> 
> The SDK is built upon the following components:
> 
> | Package           | Description                                                                 |
> | ----------------- | --------------------------------------------------------------------------- |
> | atproto           | Import shortcuts to other packages.                                         |
> | atproto\_cli      | CLI tool to generate code.                                                  |
> | atproto\_client   | XRPC Client, data models, and utils like rich text helper.                  |
> | atproto\_codegen  | Code generator of models, clients, and namespaces.                          |
> | atproto\_core     | Tools to work with NSID, AT URI Schemes, CID, CAR files, and DID Documents. |
> | atproto\_crypto   | Crypto utils like multibase, signature verification, work with DID keys.    |
> | atproto\_firehose | Firehose (data streaming) client and models.                                |
> | atproto\_identity | Identity resolvers for DID, Handle, AT Protocol data, signing keys.         |
> | atproto\_lexicon  | Lexicon parser.                                                             |
> | atproto\_server   | Server-side utils like JWT.                                                 |
> 
> I highly recommend that you use the `atproto` package to import everything that you need. It contains shortcuts to all other packages.
> 
> ### Documentation
> 
> [](#documentation)
> 
> The documentation is live at [atproto.blue](https://atproto.blue/).
> 
> ### Getting help
> 
> [](#getting-help)
> 
> You can get help in several ways:
> 
> * Report bugs, request new features by [creating an issue](https://github.com/MarshalX/atproto/issues/new).
> * Ask questions by [starting a discussion](https://github.com/MarshalX/atproto/discussions/new).
> * Ask questions in [Discord server](https://discord.gg/PCyVJXU9jN).
> 
> ### Advanced usage
> 
> [](#advanced-usage)
> 
> I'll be honest. The high-level Client that was shown in the "Quick Start" section is not a real ATProto API. This is syntax sugar built upon the real XRPC methods! The high-level methods do not cover the full needs of developers. To be able to do anything that you want, you should know how to work with low-level API. Let's dive into it!
> 
> The basics:
> 
> * Namespaces – classes that group sub-namespaces and the XRPC queries and procedures. Built upon NSID ATProto semantic.
> * Model – dataclasses for input, output, and params of the methods from namespaces. Models describe Record and all other types in the Lexicon Schemes.
> 
> #### Namespaces
> 
> [](#namespaces)
> 
> The client contains references to the root of all namespaces. It's `com` and `app` for now.
> 
> from atproto import Client
> 
> Client().com
> Client().app
> 
> To dive deeper, you can navigate using hints from your IDE. Thanks to a well-type hinted SDK, it's much easier.
> 
> from atproto import Client
> 
> Client().com.atproto.server.create_session(...)
> Client().com.atproto.sync.get_blob(...)
> Client().app.bsky.feed.get_likes(...)
> Client().app.bsky.graph.get_follows(...)
> 
> The endpoint of the path is always the method you want to call. The method presents a query or procedure in XRPC. You should not care about it much. The only thing you need to know is that the procedures require data objects. Queries could be called with or without params.
> 
> #### Records
> 
> [](#records)
> 
> In some sub-namespaces, you can find records. Such record classes provide a syntax sugar not defined in the lexicon scheme. This sugar provides a more convenient way to work with repository operations, such as creating a record, deleting a record, and so on.
> 
> Here are some available records of Bluesky records:
> 
> from atproto import Client
> 
> Client().app.bsky.feed.post
> Client().app.bsky.feed.like
> Client().app.bsky.graph.follow
> Client().app.bsky.graph.block
> Client().app.bsky.actor.profile
> # ... more
> 
> Usage example with the `post` record:
> 
> from atproto import AtUri, Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> posts = client.app.bsky.feed.post.list(client.me.did, limit=10)
> for uri, post in posts.records.items():
>     print(uri, post.text)
> 
> post = client.app.bsky.feed.post.get(client.me.did, AtUri.from_str(uri).rkey)
> print(post.value.text)
> 
> post_record = models.AppBskyFeedPost.Record(text='test record namespaces', created_at=client.get_current_time_iso())
> new_post = client.app.bsky.feed.post.create(client.me.did, post_record)
> print(new_post)
> 
> deleted_post = client.app.bsky.feed.post.delete(client.me.did, AtUri.from_str(new_post.uri).rkey)
> print(deleted_post)
> 
> Please note that not all repository operations are covered by these syntax sugars. You can always use the low-level methods to perform any desired action. One such action is updating a record.
> 
> #### Models
> 
> [](#models)
> 
> To deal with methods, we need to deal with models! Models are available in the `models` module and have NSID-based aliases. Let's take a look at it.
> 
> from atproto import models
> 
> models.ComAtprotoIdentityResolveHandle
> models.AppBskyFeedPost
> models.AppBskyActorGetProfile
> # 90+ more...
> 
> The model classes in the "models" aliases could be:
> 
> * Data model
> * Params model
> * Response model
> * Sugar response model
> * Record model
> * Type model
> 
> The only thing you need to know is how to create instances of models. You won't need to work as model-creator for all models. For example, the SDK will create Response models for you.
> 
> There are a few ways to create the instance of a model:
> 
> * Dict-based
> * Class-based
> 
> The instances of any data and params models should be passed as arguments to the methods that were described above.
> 
> Dict-based:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> # The params model will be created automatically internally for you!
> print(client.com.atproto.identity.resolve_handle({'handle': 'marshal.dev'}))
> 
> Class-based:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> params = models.ComAtprotoIdentityResolveHandle.Params(handle='marshal.dev')
> print(client.com.atproto.identity.resolve_handle(params))
> 
> Tip: look at the typehint of the method to figure out the name and the path to the input/data model!
> 
> Pro Tip: use IDE autocompletion to find necessary models! Just start typing the method name right after the dot (`models.{type method name in camel case`).
> 
> Models can be nested to the innermost rings of hell. Be ready for it!
> 
> This is how we can send a post with an image using low-level XRPC Client:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> with open('cat.jpg', 'rb') as f:
>     img_data = f.read()
> 
>     upload = client.upload_blob(img_data)
>     images = [models.AppBskyEmbedImages.Image(alt='Img alt', image=upload.blob)]
>     embed = models.AppBskyEmbedImages.Main(images=images)
> 
>     client.com.atproto.repo.create_record(
>         models.ComAtprotoRepoCreateRecord.Data(
>             repo=client.me.did,
>             collection=models.ids.AppBskyFeedPost,
>             record=models.AppBskyFeedPost.Record(
>                 created_at=client.get_current_time_iso(), text='Text of the post', embed=embed
>             ),
>         )
>     )
> 
>     # of course, you can use the syntax sugar here instead
>     post = models.AppBskyFeedPost.Record(text='Text of the post', embed=embed, created_at=client.get_current_time_iso())
>     client.app.bsky.feed.post.create(client.me.did, post)
>     # or even high-level client
>     client.send_image(text='Text of the post', image=img_data, image_alt='Img alt')
>     # these three methods are equivalent
> 
> I hope you are not scared. May the Force be with you. Good luck!
> 
> ### Change log
> 
> [](#change-log)
> 
> The full change log is available in [CHANGES.md](https://github.com/MarshalX/atproto/blob/main/CHANGES.md).
> 
> ### Contributing
> 
> [](#contributing)
> 
> Contributions of all sizes are welcome. The contribution guidelines will be presented later.
> 
> ### License
> 
> [](#license)
> 
> MIT
> 
> [ View this page ](https://github.com/MarshalX/atproto/blob/main/docs/source/index.rst?plain=true "View this page") 
> 
> [ Edit this page ](https://github.com/MarshalX/atproto/edit/main/docs/source/index.rst "Edit this page") 
> 
> Toggle table of contents sidebar
> 
> [ ![Logo of atproto SDK for Python by Midjourney'](https://github.com/MarshalX/atproto/raw/main/.github/images/logo.png) ](https://github.com/MarshalX/atproto)   
> **Autogenerated from lexicons, well type hinted, documented, sync and async SDK for Python**   
> [ Examples](https://github.com/MarshalX/atproto/tree/main/examples) •[ Documentation](https://atproto.blue/) •[ Discord Bluesky API](https://discord.gg/PCyVJXU9jN) 
> 
> ## The AT Protocol SDK[¶](#the-at-protocol-sdk "Permalink to this heading")
> 
> > ⚠️ Under construction. Until the 1.0.0 release compatibility between versions is not guaranteed.
> 
> Code snippet:
> 
> from atproto import Client, client_utils
> 
> 
> def main():
>     client = Client()
>     profile = client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
> 
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = client.send_post(text)
>     client.like(post.uri, post.cid)
> 
> 
> if __name__ == '__main__':
>     main()
> 
> Code snippet of async version 
> 
> import asyncio
> 
> from atproto import AsyncClient, client_utils
> 
> 
> async def main():
>     client = AsyncClient()
>     profile = await client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
> 
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = await client.send_post(text)
>     await client.like(post.uri, post.cid)
> 
> 
> if __name__ == '__main__':
>     # use run() for a higher Python version
>     asyncio.get_event_loop().run_until_complete(main())
> 
> 💬 [Direct Messages (Chats)](https://atproto.blue/en/latest/dm.html)
> 
> 🍿 [Example project with custom feed generator](https://github.com/MarshalX/bluesky-feed-generator)
> 
> 🔥 [Firehose data streaming is available](https://atproto.blue/en/latest/atproto%5Ffirehose/index.html)
> 
> 🌐 [Identity resolvers for DID and Handle](https://atproto.blue/en/latest/atproto%5Fidentity/index.html)
> 
> ### Introduction[¶](#introduction "Permalink to this heading")
> 
> This SDK attempts to implement everything that provides ATProto. There is support for Lexicon Schemes, XRPC clients, Firehose, Identity, DID keys, signatures, and more. All models, queries, and procedures are generated automatically. The main focus is on the lexicons of atproto.com and bsky.app, but it doesn’t have a vendor lock on it. Feel free to use the code generator for your own lexicon schemes. The SDK also provides utilities to work with CID, NSID, AT URI Schemes, DAG-CBOR, CAR files, DID Documents and more.
> 
> ### Requirements[¶](#requirements "Permalink to this heading")
> 
> * Python 3.8 or higher.
> 
> ### Installing[¶](#installing "Permalink to this heading")
> 
> ### Quick start[¶](#quick-start "Permalink to this heading")
> 
> First of all, you need to create the instance of the XRPC Client. To do so, you have two major options: asynchronous and synchronous. The difference is only in the import and how you call the methods. If you are not familiar with async, use sync instead.
> 
> For sync:
> 
> from atproto import Client
> 
> client = Client()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # Client('https://example.com')
> 
> For async:
> 
> from atproto import AsyncClient
> 
> client = AsyncClient()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # AsyncClient('https://example.com')
> 
> In the snippets below, only the sync version will be presented.
> 
> Right after the creation of the Client instance, you will probably want to access the full API and perform actions by profile. To achieve this, you should log into the network using your handle and password. The password could be app-specific.
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> You are awesome! Now feel free to pick any high-level method that you want and try it out!
> 
> Code to send a post:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> client.send_post(text='Hello World!')
> 
> Useful links to continue:
> 
> * [List of all methods with documentation](https://atproto.readthedocs.io/en/latest/atproto%5Fclient/index.html).
> * [Examples of using the methods](https://github.com/MarshalX/atproto/tree/main/examples).
> 
> ### SDK structure[¶](#sdk-structure "Permalink to this heading")
> 
> The SDK is built upon the following components:
> 
> | Package           | Description                                                                 |
> | ----------------- | --------------------------------------------------------------------------- |
> | atproto           | Import shortcuts to other packages.                                         |
> | atproto\_cli      | CLI tool to generate code.                                                  |
> | atproto\_client   | XRPC Client, data models, and utils like rich text helper.                  |
> | atproto\_codegen  | Code generator of models, clients, and namespaces.                          |
> | atproto\_core     | Tools to work with NSID, AT URI Schemes, CID, CAR files, and DID Documents. |
> | atproto\_crypto   | Crypto utils like multibase, signature verification, work with DID keys.    |
> | atproto\_firehose | Firehose (data streaming) client and models.                                |
> | atproto\_identity | Identity resolvers for DID, Handle, AT Protocol data, signing keys.         |
> | atproto\_lexicon  | Lexicon parser.                                                             |
> | atproto\_server   | Server-side utils like JWT.                                                 |
> 
> I highly recommend that you use the `atproto` package to import everything that you need. It contains shortcuts to all other packages.
> 
> ### Documentation[¶](#documentation "Permalink to this heading")
> 
> The documentation is live at [atproto.blue](https://atproto.blue/).
> 
> ### Getting help[¶](#getting-help "Permalink to this heading")
> 
> You can get help in several ways:
> 
> * Report bugs, request new features by [creating an issue](https://github.com/MarshalX/atproto/issues/new).
> * Ask questions by [starting a discussion](https://github.com/MarshalX/atproto/discussions/new).
> * Ask questions in [Discord server](https://discord.gg/PCyVJXU9jN).
> 
> ### Advanced usage[¶](#advanced-usage "Permalink to this heading")
> 
> I’ll be honest. The high-level Client that was shown in the “Quick Start” section is not a real ATProto API. This is syntax sugar built upon the real XRPC methods! The high-level methods do not cover the full needs of developers. To be able to do anything that you want, you should know how to work with low-level API. Let’s dive into it!
> 
> The basics:
> 
> * Namespaces – classes that group sub-namespaces and the XRPC queries and procedures. Built upon NSID ATProto semantic.
> * Model – dataclasses for input, output, and params of the methods from namespaces. Models describe Record and all other types in the Lexicon Schemes.
> 
> #### Namespaces[¶](#namespaces "Permalink to this heading")
> 
> The client contains references to the root of all namespaces. It’s `com` and `app` for now.
> 
> from atproto import Client
> 
> Client().com
> Client().app
> 
> To dive deeper, you can navigate using hints from your IDE. Thanks to a well-type hinted SDK, it’s much easier.
> 
> from atproto import Client
> 
> Client().com.atproto.server.create_session(...)
> Client().com.atproto.sync.get_blob(...)
> Client().app.bsky.feed.get_likes(...)
> Client().app.bsky.graph.get_follows(...)
> 
> The endpoint of the path is always the method you want to call. The method presents a query or procedure in XRPC. You should not care about it much. The only thing you need to know is that the procedures require data objects. Queries could be called with or without params.
> 
> #### Records[¶](#records "Permalink to this heading")
> 
> In some sub-namespaces, you can find records. Such record classes provide a syntax sugar not defined in the lexicon scheme. This sugar provides a more convenient way to work with repository operations, such as creating a record, deleting a record, and so on.
> 
> Here are some available records of Bluesky records:
> 
> from atproto import Client
> 
> Client().app.bsky.feed.post
> Client().app.bsky.feed.like
> Client().app.bsky.graph.follow
> Client().app.bsky.graph.block
> Client().app.bsky.actor.profile
> # ... more
> 
> Usage example with the `post` record:
> 
> from atproto import AtUri, Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> posts = client.app.bsky.feed.post.list(client.me.did, limit=10)
> for uri, post in posts.records.items():
>     print(uri, post.text)
> 
> post = client.app.bsky.feed.post.get(client.me.did, AtUri.from_str(uri).rkey)
> print(post.value.text)
> 
> post_record = models.AppBskyFeedPost.Record(text='test record namespaces', created_at=client.get_current_time_iso())
> new_post = client.app.bsky.feed.post.create(client.me.did, post_record)
> print(new_post)
> 
> deleted_post = client.app.bsky.feed.post.delete(client.me.did, AtUri.from_str(new_post.uri).rkey)
> print(deleted_post)
> 
> Please note that not all repository operations are covered by these syntax sugars. You can always use the low-level methods to perform any desired action. One such action is updating a record.
> 
> #### Models[¶](#models "Permalink to this heading")
> 
> To deal with methods, we need to deal with models! Models are available in the `models` module and have NSID-based aliases. Let’s take a look at it.
> 
> from atproto import models
> 
> models.ComAtprotoIdentityResolveHandle
> models.AppBskyFeedPost
> models.AppBskyActorGetProfile
> # 90+ more...
> 
> The model classes in the “models” aliases could be:
> 
> * Data model
> * Params model
> * Response model
> * Sugar response model
> * Record model
> * Type model
> 
> The only thing you need to know is how to create instances of models. You won’t need to work as model-creator for all models. For example, the SDK will create Response models for you.
> 
> There are a few ways to create the instance of a model:
> 
> * Dict-based
> * Class-based
> 
> The instances of any data and params models should be passed as arguments to the methods that were described above.
> 
> Dict-based:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> # The params model will be created automatically internally for you!
> print(client.com.atproto.identity.resolve_handle({'handle': 'marshal.dev'}))
> 
> Class-based:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> params = models.ComAtprotoIdentityResolveHandle.Params(handle='marshal.dev')
> print(client.com.atproto.identity.resolve_handle(params))
> 
> Tip: look at the typehint of the method to figure out the name and the path to the input/data model!
> 
> Pro Tip: use IDE autocompletion to find necessary models! Just start typing the method name right after the dot (`models.{type method name in camel case`).
> 
> Models can be nested to the innermost rings of hell. Be ready for it!
> 
> This is how we can send a post with an image using low-level XRPC Client:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> with open('cat.jpg', 'rb') as f:
>     img_data = f.read()
> 
>     upload = client.upload_blob(img_data)
>     images = [models.AppBskyEmbedImages.Image(alt='Img alt', image=upload.blob)]
>     embed = models.AppBskyEmbedImages.Main(images=images)
> 
>     client.com.atproto.repo.create_record(
>         models.ComAtprotoRepoCreateRecord.Data(
>             repo=client.me.did,
>             collection=models.ids.AppBskyFeedPost,
>             record=models.AppBskyFeedPost.Record(
>                 created_at=client.get_current_time_iso(), text='Text of the post', embed=embed
>             ),
>         )
>     )
> 
>     # of course, you can use the syntax sugar here instead
>     post = models.AppBskyFeedPost.Record(text='Text of the post', embed=embed, created_at=client.get_current_time_iso())
>     client.app.bsky.feed.post.create(client.me.did, post)
>     # or even high-level client
>     client.send_image(text='Text of the post', image=img_data, image_alt='Img alt')
>     # these three methods are equivalent
> 
> I hope you are not scared. May the Force be with you. Good luck!
> 
> ### Change log[¶](#change-log "Permalink to this heading")
> 
> The full change log is available in [CHANGES.md](https://github.com/MarshalX/atproto/blob/main/CHANGES.md).
> 
> ### Contributing[¶](#contributing "Permalink to this heading")
> 
> Contributions of all sizes are welcome. The contribution guidelines will be presented later.
> 
> ### License[¶](#license "Permalink to this heading")
> 
> MIT
> 
> * [Getting Started](readme.html)  
>    * [The AT Protocol SDK](about:blank/readme.html#the-at-protocol-sdk)  
>          * [Introduction](readme.content.html)  
>          * [Requirements](about:blank/readme.content.html#requirements)  
>          * [Installing](about:blank/readme.content.html#installing)  
>          * [Quick start](about:blank/readme.content.html#quick-start)  
>          * [SDK structure](about:blank/readme.content.html#sdk-structure)  
>          * [Documentation](about:blank/readme.content.html#documentation)  
>          * [Getting help](about:blank/readme.content.html#getting-help)  
>          * [Advanced usage](about:blank/readme.content.html#advanced-usage)  
>                   * [Namespaces](about:blank/readme.content.html#namespaces)  
>                   * [Records](about:blank/readme.content.html#records)  
>                   * [Models](about:blank/readme.content.html#models)
> * [Examples](https://github.com/MarshalX/atproto/tree/main/examples)
> 
> SDK
> 
> * [Direct Messages (Chats)](dm.html)  
>    * [Example](about:blank/dm.html#example)
> * [Client (API)](atproto%5Fclient/index.html)  
>    * [AsyncClient](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient)  
>          * [AsyncClient.AtprotoServiceType](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.AtprotoServiceType)  
>                   * [AsyncClient.AtprotoServiceType.ATPROTO\_LABELER](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.AtprotoServiceType.ATPROTO%5FLABELER)  
>                   * [AsyncClient.AtprotoServiceType.BSKY\_CHAT](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.AtprotoServiceType.BSKY%5FCHAT)  
>          * [AsyncClient.BSKY\_CHAT\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.BSKY%5FCHAT%5FDID)  
>          * [AsyncClient.BSKY\_LABELER\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.BSKY%5FLABELER%5FDID)  
>          * [AsyncClient.app](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.app)  
>          * [AsyncClient.chat](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.chat)  
>          * [AsyncClient.clone()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.clone)  
>          * [AsyncClient.com](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.com)  
>          * [AsyncClient.configure\_labelers\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.configure%5Flabelers%5Fheader)  
>          * [AsyncClient.configure\_proxy\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.configure%5Fproxy%5Fheader)  
>          * [AsyncClient.delete\_follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Ffollow)  
>          * [AsyncClient.delete\_like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Flike)  
>          * [AsyncClient.delete\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Fpost)  
>          * [AsyncClient.delete\_repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Frepost)  
>          * [AsyncClient.export\_session\_string()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.export%5Fsession%5Fstring)  
>          * [AsyncClient.follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.follow)  
>          * [AsyncClient.get\_author\_feed()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fauthor%5Ffeed)  
>          * [AsyncClient.get\_current\_time()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fcurrent%5Ftime)  
>          * [AsyncClient.get\_current\_time\_iso()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fcurrent%5Ftime%5Fiso)  
>          * [AsyncClient.get\_followers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ffollowers)  
>          * [AsyncClient.get\_follows()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ffollows)  
>          * [AsyncClient.get\_likes()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Flikes)  
>          * [AsyncClient.get\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fpost)  
>          * [AsyncClient.get\_post\_thread()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fpost%5Fthread)  
>          * [AsyncClient.get\_posts()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fposts)  
>          * [AsyncClient.get\_profile()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fprofile)  
>          * [AsyncClient.get\_profiles()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fprofiles)  
>          * [AsyncClient.get\_reposted\_by()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Freposted%5Fby)  
>          * [AsyncClient.get\_time\_from\_timestamp()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ftime%5Ffrom%5Ftimestamp)  
>          * [AsyncClient.get\_timeline()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ftimeline)  
>          * [AsyncClient.invoke\_procedure()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.invoke%5Fprocedure)  
>          * [AsyncClient.invoke\_query()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.invoke%5Fquery)  
>          * [AsyncClient.like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.like)  
>          * [AsyncClient.login()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.login)  
>          * [AsyncClient.mute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.mute)  
>          * [AsyncClient.on\_session\_change()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.on%5Fsession%5Fchange)  
>          * [AsyncClient.post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.post)  
>          * [AsyncClient.repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.repost)  
>          * [AsyncClient.request](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.request)  
>          * [AsyncClient.resolve\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.resolve%5Fhandle)  
>          * [AsyncClient.send\_image()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fimage)  
>          * [AsyncClient.send\_images()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fimages)  
>          * [AsyncClient.send\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fpost)  
>          * [AsyncClient.send\_video()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fvideo)  
>          * [AsyncClient.tools](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.tools)  
>          * [AsyncClient.unfollow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unfollow)  
>          * [AsyncClient.unlike()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unlike)  
>          * [AsyncClient.unmute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unmute)  
>          * [AsyncClient.unrepost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unrepost)  
>          * [AsyncClient.unsend()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unsend)  
>          * [AsyncClient.update\_base\_url()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.update%5Fbase%5Furl)  
>          * [AsyncClient.update\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.update%5Fhandle)  
>          * [AsyncClient.upload\_blob()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.upload%5Fblob)  
>          * [AsyncClient.with\_bsky\_chat\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Fbsky%5Fchat%5Fproxy)  
>          * [AsyncClient.with\_bsky\_labeler()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Fbsky%5Flabeler)  
>          * [AsyncClient.with\_labelers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Flabelers)  
>          * [AsyncClient.with\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Fproxy)  
>    * [Client](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client)  
>          * [Client.AtprotoServiceType](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.AtprotoServiceType)  
>                   * [Client.AtprotoServiceType.ATPROTO\_LABELER](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.AtprotoServiceType.ATPROTO%5FLABELER)  
>                   * [Client.AtprotoServiceType.BSKY\_CHAT](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.AtprotoServiceType.BSKY%5FCHAT)  
>          * [Client.BSKY\_CHAT\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.BSKY%5FCHAT%5FDID)  
>          * [Client.BSKY\_LABELER\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.BSKY%5FLABELER%5FDID)  
>          * [Client.app](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.app)  
>          * [Client.chat](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.chat)  
>          * [Client.clone()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.clone)  
>          * [Client.com](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.com)  
>          * [Client.configure\_labelers\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.configure%5Flabelers%5Fheader)  
>          * [Client.configure\_proxy\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.configure%5Fproxy%5Fheader)  
>          * [Client.delete\_follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Ffollow)  
>          * [Client.delete\_like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Flike)  
>          * [Client.delete\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Fpost)  
>          * [Client.delete\_repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Frepost)  
>          * [Client.export\_session\_string()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.export%5Fsession%5Fstring)  
>          * [Client.follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.follow)  
>          * [Client.get\_author\_feed()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fauthor%5Ffeed)  
>          * [Client.get\_current\_time()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fcurrent%5Ftime)  
>          * [Client.get\_current\_time\_iso()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fcurrent%5Ftime%5Fiso)  
>          * [Client.get\_followers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ffollowers)  
>          * [Client.get\_follows()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ffollows)  
>          * [Client.get\_likes()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Flikes)  
>          * [Client.get\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fpost)  
>          * [Client.get\_post\_thread()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fpost%5Fthread)  
>          * [Client.get\_posts()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fposts)  
>          * [Client.get\_profile()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fprofile)  
>          * [Client.get\_profiles()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fprofiles)  
>          * [Client.get\_reposted\_by()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Freposted%5Fby)  
>          * [Client.get\_time\_from\_timestamp()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ftime%5Ffrom%5Ftimestamp)  
>          * [Client.get\_timeline()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ftimeline)  
>          * [Client.invoke\_procedure()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.invoke%5Fprocedure)  
>          * [Client.invoke\_query()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.invoke%5Fquery)  
>          * [Client.like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.like)  
>          * [Client.login()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.login)  
>          * [Client.me](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.me)  
>          * [Client.mute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.mute)  
>          * [Client.on\_session\_change()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.on%5Fsession%5Fchange)  
>          * [Client.post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.post)  
>          * [Client.repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.repost)  
>          * [Client.request](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.request)  
>          * [Client.resolve\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.resolve%5Fhandle)  
>          * [Client.send\_image()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fimage)  
>          * [Client.send\_images()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fimages)  
>          * [Client.send\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fpost)  
>          * [Client.send\_video()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fvideo)  
>          * [Client.tools](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.tools)  
>          * [Client.unfollow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unfollow)  
>          * [Client.unlike()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unlike)  
>          * [Client.unmute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unmute)  
>          * [Client.unrepost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unrepost)  
>          * [Client.unsend()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unsend)  
>          * [Client.update\_base\_url()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.update%5Fbase%5Furl)  
>          * [Client.update\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.update%5Fhandle)  
>          * [Client.upload\_blob()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.upload%5Fblob)  
>          * [Client.with\_bsky\_chat\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Fbsky%5Fchat%5Fproxy)  
>          * [Client.with\_bsky\_labeler()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Fbsky%5Flabeler)  
>          * [Client.with\_labelers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Flabelers)  
>          * [Client.with\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Fproxy)  
>    * [Session](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session)  
>          * [Session.access\_jwt](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.access%5Fjwt)  
>          * [Session.access\_jwt\_payload](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.access%5Fjwt%5Fpayload)  
>          * [Session.copy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.copy)  
>          * [Session.decode()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.decode)  
>          * [Session.did](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.did)  
>          * [Session.encode()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.encode)  
>          * [Session.export()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.export)  
>          * [Session.handle](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.handle)  
>          * [Session.pds\_endpoint](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.pds%5Fendpoint)  
>          * [Session.refresh\_jwt](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.refresh%5Fjwt)  
>          * [Session.refresh\_jwt\_payload](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.refresh%5Fjwt%5Fpayload)  
>    * [SessionEvent](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent)  
>          * [SessionEvent.CREATE](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent.CREATE)  
>          * [SessionEvent.IMPORT](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent.IMPORT)  
>          * [SessionEvent.REFRESH](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent.REFRESH)  
>    * [Submodules](about:blank/atproto%5Fclient/index.html#submodules)  
>          * [Clients](atproto%5Fclient/clients.html)  
>                   * [Submodules](about:blank/atproto%5Fclient/clients.html#submodules)  
>          * [Namespace](atproto%5Fclient/namespace.html)  
>                   * [AppBskyActorNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyActorNamespace)  
>                   * [AppBskyActorProfileRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyActorProfileRecord)  
>                   * [AppBskyFeedGeneratorRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedGeneratorRecord)  
>                   * [AppBskyFeedLikeRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedLikeRecord)  
>                   * [AppBskyFeedNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedNamespace)  
>                   * [AppBskyFeedPostRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedPostRecord)  
>                   * [AppBskyFeedPostgateRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedPostgateRecord)  
>                   * [AppBskyFeedRepostRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedRepostRecord)  
>                   * [AppBskyFeedThreadgateRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedThreadgateRecord)  
>                   * [AppBskyGraphBlockRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphBlockRecord)  
>                   * [AppBskyGraphFollowRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphFollowRecord)  
>                   * [AppBskyGraphListRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphListRecord)  
>                   * [AppBskyGraphListblockRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphListblockRecord)  
>                   * [AppBskyGraphListitemRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphListitemRecord)  
>                   * [AppBskyGraphNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphNamespace)  
>                   * [AppBskyGraphStarterpackRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphStarterpackRecord)  
>                   * [AppBskyLabelerNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyLabelerNamespace)  
>                   * [AppBskyLabelerServiceRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyLabelerServiceRecord)  
>                   * [AppBskyNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyNamespace)  
>                   * [AppBskyNotificationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyNotificationNamespace)  
>                   * [AppBskyUnspeccedNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyUnspeccedNamespace)  
>                   * [AppBskyVideoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyVideoNamespace)  
>                   * [AppNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppNamespace)  
>                   * [ChatBskyActorDeclarationRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyActorDeclarationRecord)  
>                   * [ChatBskyActorNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyActorNamespace)  
>                   * [ChatBskyConvoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyConvoNamespace)  
>                   * [ChatBskyModerationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyModerationNamespace)  
>                   * [ChatBskyNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyNamespace)  
>                   * [ChatNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatNamespace)  
>                   * [ComAtprotoAdminNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoAdminNamespace)  
>                   * [ComAtprotoIdentityNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoIdentityNamespace)  
>                   * [ComAtprotoLabelNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoLabelNamespace)  
>                   * [ComAtprotoLexiconNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoLexiconNamespace)  
>                   * [ComAtprotoLexiconSchemaRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoLexiconSchemaRecord)  
>                   * [ComAtprotoModerationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoModerationNamespace)  
>                   * [ComAtprotoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoNamespace)  
>                   * [ComAtprotoRepoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoRepoNamespace)  
>                   * [ComAtprotoServerNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoServerNamespace)  
>                   * [ComAtprotoSyncNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoSyncNamespace)  
>                   * [ComAtprotoTempNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoTempNamespace)  
>                   * [ComNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComNamespace)  
>                   * [ToolsNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsNamespace)  
>                   * [ToolsOzoneCommunicationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneCommunicationNamespace)  
>                   * [ToolsOzoneModerationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneModerationNamespace)  
>                   * [ToolsOzoneNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneNamespace)  
>                   * [ToolsOzoneServerNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneServerNamespace)  
>                   * [ToolsOzoneSetNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneSetNamespace)  
>                   * [ToolsOzoneSettingNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneSettingNamespace)  
>                   * [ToolsOzoneSignatureNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneSignatureNamespace)  
>                   * [ToolsOzoneTeamNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneTeamNamespace)  
>          * [Models](atproto%5Fclient/models.html)  
>                   * [Submodules](about:blank/atproto%5Fclient/models.html#submodules)  
>          * [Auth](atproto%5Fclient/auth.html)  
>                   * [Login](about:blank/atproto%5Fclient/auth.html#login)  
>                   * [Session string](about:blank/atproto%5Fclient/auth.html#session-string)  
>          * [String Formats](atproto%5Fclient/string%5Fformats.html)  
>                   * [Overview](about:blank/atproto%5Fclient/string%5Fformats.html#overview)  
>                   * [Supported String Formats](about:blank/atproto%5Fclient/string%5Fformats.html#supported-string-formats)  
>                   * [Using Validation in Your Code](about:blank/atproto%5Fclient/string%5Fformats.html#using-validation-in-your-code)  
>          * [Utils](atproto%5Fclient/utils/index.html)  
>                   * [Text Builder (rich text)](atproto%5Fclient/utils/text%5Fbuilder.html)
> * [Core](atproto%5Fcore/index.html)  
>    * [Submodules](about:blank/atproto%5Fcore/index.html#submodules)  
>          * [NSID (NameSpaced ID)](atproto%5Fcore/nsid.html)  
>                   * [NSID](about:blank/atproto%5Fcore/nsid.html#atproto%5Fcore.nsid.NSID)  
>                   * [validate\_nsid()](about:blank/atproto%5Fcore/nsid.html#atproto%5Fcore.nsid.validate%5Fnsid)  
>          * [CID decoder](atproto%5Fcore/cid.html)  
>                   * [CID](about:blank/atproto%5Fcore/cid.html#atproto%5Fcore.cid.CID)  
>          * [AT URI Scheme](atproto%5Fcore/uri.html)  
>                   * [AtUri](about:blank/atproto%5Fcore/uri.html#atproto%5Fcore.uri.AtUri)  
>          * [CAR reader](atproto%5Fcore/car.html)  
>                   * [CAR](about:blank/atproto%5Fcore/car.html#atproto%5Fcore.car.CAR)  
>          * [DAG-CBOR](atproto%5Fcore/cbor.html)  
>                   * [decode\_dag()](about:blank/atproto%5Fcore/cbor.html#atproto%5Fcore.cbor.decode%5Fdag)  
>                   * [decode\_dag\_multi()](about:blank/atproto%5Fcore/cbor.html#atproto%5Fcore.cbor.decode%5Fdag%5Fmulti)  
>          * [DID Document](atproto%5Fcore/did%5Fdoc.html)  
>                   * [DidDocument](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.DidDocument)  
>                   * [Service](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.Service)  
>                   * [SigningKey](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.SigningKey)  
>                   * [VerificationMethod](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.VerificationMethod)  
>                   * [is\_valid\_did\_doc()](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.is%5Fvalid%5Fdid%5Fdoc)
> * [Firehose (data streaming)](atproto%5Ffirehose/index.html)  
>    * [AsyncFirehoseSubscribeLabelsClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient)  
>          * [AsyncFirehoseSubscribeLabelsClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient.start)  
>          * [AsyncFirehoseSubscribeLabelsClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient.stop)  
>          * [AsyncFirehoseSubscribeLabelsClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient.update%5Fparams)  
>    * [AsyncFirehoseSubscribeReposClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient)  
>          * [AsyncFirehoseSubscribeReposClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient.start)  
>          * [AsyncFirehoseSubscribeReposClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient.stop)  
>          * [AsyncFirehoseSubscribeReposClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient.update%5Fparams)  
>    * [FirehoseSubscribeLabelsClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient)  
>          * [FirehoseSubscribeLabelsClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient.start)  
>          * [FirehoseSubscribeLabelsClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient.stop)  
>          * [FirehoseSubscribeLabelsClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient.update%5Fparams)  
>    * [FirehoseSubscribeReposClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient)  
>          * [FirehoseSubscribeReposClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient.start)  
>          * [FirehoseSubscribeReposClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient.stop)  
>          * [FirehoseSubscribeReposClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient.update%5Fparams)  
>    * [parse\_subscribe\_labels\_message()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.parse%5Fsubscribe%5Flabels%5Fmessage)  
>    * [parse\_subscribe\_repos\_message()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.parse%5Fsubscribe%5Frepos%5Fmessage)  
>    * [Submodules](about:blank/atproto%5Ffirehose/index.html#submodules)  
>          * [Frame models](atproto%5Ffirehose/models.html)  
>                   * [ErrorFrame](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.ErrorFrame)  
>                   * [ErrorFrameBody](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.ErrorFrameBody)  
>                   * [ErrorFrameHeader](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.ErrorFrameHeader)  
>                   * [Frame](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.Frame)  
>                   * [FrameHeader](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.FrameHeader)  
>                   * [FrameType](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.FrameType)  
>                   * [MessageFrame](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.MessageFrame)  
>                   * [MessageFrameHeader](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.MessageFrameHeader)  
>                   * [parse\_frame()](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.parse%5Fframe)  
>                   * [parse\_frame\_header()](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.parse%5Fframe%5Fheader)
> * [Identity (DID and Handle resolvers)](atproto%5Fidentity/index.html)  
>    * [AsyncIdResolver](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.AsyncIdResolver)  
>          * [AsyncIdResolver.did](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.AsyncIdResolver.did)  
>          * [AsyncIdResolver.handle](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.AsyncIdResolver.handle)  
>    * [IdResolver](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.IdResolver)  
>          * [IdResolver.did](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.IdResolver.did)  
>          * [IdResolver.handle](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.IdResolver.handle)  
>    * [Submodules](about:blank/atproto%5Fidentity/index.html#submodules)  
>          * [ID Resolver](atproto%5Fidentity/id%5Fresolver.html)  
>                   * [AsyncIdResolver](about:blank/atproto%5Fidentity/id%5Fresolver.html#atproto%5Fidentity.resolver.AsyncIdResolver)  
>                   * [IdResolver](about:blank/atproto%5Fidentity/id%5Fresolver.html#atproto%5Fidentity.resolver.IdResolver)  
>          * [Handle Resolver](atproto%5Fidentity/handle%5Fresolver.html)  
>                   * [AsyncHandleResolver](about:blank/atproto%5Fidentity/handle%5Fresolver.html#atproto%5Fidentity.handle.resolver.AsyncHandleResolver)  
>                   * [HandleResolver](about:blank/atproto%5Fidentity/handle%5Fresolver.html#atproto%5Fidentity.handle.resolver.HandleResolver)  
>          * [DID Resolver](atproto%5Fidentity/did%5Fresolver.html)  
>                   * [AsyncDidResolver](about:blank/atproto%5Fidentity/did%5Fresolver.html#atproto%5Fidentity.did.resolver.AsyncDidResolver)  
>                   * [DidResolver](about:blank/atproto%5Fidentity/did%5Fresolver.html#atproto%5Fidentity.did.resolver.DidResolver)  
>          * [Cache](atproto%5Fidentity/cache.html)  
>                   * [AsyncDidInMemoryCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.in%5Fmemory%5Fcache.AsyncDidInMemoryCache)  
>                   * [DidInMemoryCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.in%5Fmemory%5Fcache.DidInMemoryCache)  
>                   * [AsyncDidBaseCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.base%5Fcache.AsyncDidBaseCache)  
>                   * [DidBaseCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.base%5Fcache.DidBaseCache)  
>          * [AT Protocol Data](atproto%5Fidentity/atproto%5Fdata.html)  
>                   * [AtprotoData](about:blank/atproto%5Fidentity/atproto%5Fdata.html#atproto%5Fidentity.did.atproto%5Fdata.AtprotoData)  
>                   * [ensure\_atproto\_document()](about:blank/atproto%5Fidentity/atproto%5Fdata.html#atproto%5Fidentity.did.atproto%5Fdata.ensure%5Fatproto%5Fdocument)  
>                   * [ensure\_atproto\_key()](about:blank/atproto%5Fidentity/atproto%5Fdata.html#atproto%5Fidentity.did.atproto%5Fdata.ensure%5Fatproto%5Fkey)
> * [Crypto](atproto%5Fcrypto/index.html)  
>    * [Submodules](about:blank/atproto%5Fcrypto/index.html#submodules)  
>          * [DID](atproto%5Fcrypto/did.html)  
>                   * [Multikey](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.Multikey)  
>                   * [format\_did\_key()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.format%5Fdid%5Fkey)  
>                   * [format\_did\_key\_multikey()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.format%5Fdid%5Fkey%5Fmultikey)  
>                   * [format\_multikey()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.format%5Fmultikey)  
>                   * [get\_did\_key()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.get%5Fdid%5Fkey)  
>                   * [get\_multikey\_alg()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.get%5Fmultikey%5Falg)  
>                   * [parse\_did\_key()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.parse%5Fdid%5Fkey)  
>                   * [parse\_multikey()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.parse%5Fmultikey)  
>          * [Multibase](atproto%5Fcrypto/multibase.html)  
>                   * [bytes\_to\_multibase()](about:blank/atproto%5Fcrypto/multibase.html#atproto%5Fcrypto.multibase.bytes%5Fto%5Fmultibase)  
>                   * [multibase\_to\_bytes()](about:blank/atproto%5Fcrypto/multibase.html#atproto%5Fcrypto.multibase.multibase%5Fto%5Fbytes)  
>          * [Verify signature](atproto%5Fcrypto/verify.html)  
>                   * [verify\_signature()](about:blank/atproto%5Fcrypto/verify.html#atproto%5Fcrypto.verify.verify%5Fsignature)
> * [Server](atproto%5Fserver/index.html)  
>    * [Submodules](about:blank/atproto%5Fserver/index.html#submodules)  
>          * [Auth](atproto%5Fserver/auth.html)  
>                   * [JwtPayload](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.JwtPayload)  
>                   * [decode\_jwt\_payload()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.decode%5Fjwt%5Fpayload)  
>                   * [get\_jwt\_payload()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.get%5Fjwt%5Fpayload)  
>                   * [parse\_jwt()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.parse%5Fjwt)  
>                   * [validate\_jwt\_payload()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.validate%5Fjwt%5Fpayload)  
>                   * [verify\_jwt()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.verify%5Fjwt)  
>                   * [verify\_jwt\_async()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.verify%5Fjwt%5Fasync)
> * [Lexicon](atproto%5Flexicon/index.html)  
>    * [Submodules](about:blank/atproto%5Flexicon/index.html#submodules)  
>          * [Parser](atproto%5Flexicon/parser.html)  
>                   * [lexicon\_parse()](about:blank/atproto%5Flexicon/parser.html#atproto%5Flexicon.parser.lexicon%5Fparse)  
>                   * [lexicon\_parse\_dir()](about:blank/atproto%5Flexicon/parser.html#atproto%5Flexicon.parser.lexicon%5Fparse%5Fdir)  
>                   * [lexicon\_parse\_file()](about:blank/atproto%5Flexicon/parser.html#atproto%5Flexicon.parser.lexicon%5Fparse%5Ffile)  
>          * [Models](atproto%5Flexicon/models.html)  
>                   * [LexArray](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexArray)  
>                   * [LexBase](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBase)  
>                   * [LexBlob](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBlob)  
>                   * [LexBoolean](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBoolean)  
>                   * [LexBytes](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBytes)  
>                   * [LexCidLink](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexCidLink)  
>                   * [LexDefinitionBase](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexDefinitionBase)  
>                   * [LexDefinitionType](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexDefinitionType)  
>                   * [LexInteger](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexInteger)  
>                   * [LexNumber](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexNumber)  
>                   * [LexObject](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexObject)  
>                   * [LexPrimitiveBase](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexPrimitiveBase)  
>                   * [LexPrimitiveType](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexPrimitiveType)  
>                   * [LexRecord](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexRecord)  
>                   * [LexRef](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexRef)  
>                   * [LexRefUnion](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexRefUnion)  
>                   * [LexString](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexString)  
>                   * [LexSubscription](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexSubscription)  
>                   * [LexToken](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexToken)  
>                   * [LexUnknown](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexUnknown)  
>                   * [LexXrpcBody](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcBody)  
>                   * [LexXrpcError](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcError)  
>                   * [LexXrpcParameters](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcParameters)  
>                   * [LexXrpcProcedure](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcProcedure)  
>                   * [LexXrpcQuery](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcQuery)  
>                   * [LexXrpcSubscriptionMessage](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcSubscriptionMessage)  
>                   * [LexiconDoc](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexiconDoc)
> * [Exceptions](exceptions.html)  
>    * [Core](about:blank/exceptions.html#module-atproto%5Fcore.exceptions)  
>          * [AtProtocolError](about:blank/exceptions.html#atproto%5Fcore.exceptions.AtProtocolError)  
>          * [DAGCBORDecodingError](about:blank/exceptions.html#atproto%5Fcore.exceptions.DAGCBORDecodingError)  
>          * [InvalidAtUriError](about:blank/exceptions.html#atproto%5Fcore.exceptions.InvalidAtUriError)  
>          * [InvalidCARFile](about:blank/exceptions.html#atproto%5Fcore.exceptions.InvalidCARFile)  
>          * [InvalidNsidError](about:blank/exceptions.html#atproto%5Fcore.exceptions.InvalidNsidError)  
>    * [Client](about:blank/exceptions.html#module-atproto%5Fclient.exceptions)  
>          * [BadRequestError](about:blank/exceptions.html#atproto%5Fclient.exceptions.BadRequestError)  
>          * [InvokeTimeoutError](about:blank/exceptions.html#atproto%5Fclient.exceptions.InvokeTimeoutError)  
>          * [LoginRequiredError](about:blank/exceptions.html#atproto%5Fclient.exceptions.LoginRequiredError)  
>          * [ModelError](about:blank/exceptions.html#atproto%5Fclient.exceptions.ModelError)  
>          * [ModelFieldNotFoundError](about:blank/exceptions.html#atproto%5Fclient.exceptions.ModelFieldNotFoundError)  
>          * [NetworkError](about:blank/exceptions.html#atproto%5Fclient.exceptions.NetworkError)  
>          * [RequestErrorBase](about:blank/exceptions.html#atproto%5Fclient.exceptions.RequestErrorBase)  
>          * [RequestException](about:blank/exceptions.html#atproto%5Fclient.exceptions.RequestException)  
>          * [UnauthorizedError](about:blank/exceptions.html#atproto%5Fclient.exceptions.UnauthorizedError)  
>    * [Firehose](about:blank/exceptions.html#module-atproto%5Ffirehose.exceptions)  
>          * [FirehoseDecodingError](about:blank/exceptions.html#atproto%5Ffirehose.exceptions.FirehoseDecodingError)  
>          * [FirehoseError](about:blank/exceptions.html#atproto%5Ffirehose.exceptions.FirehoseError)  
>    * [Identity](about:blank/exceptions.html#module-atproto%5Fidentity.exceptions)  
>          * [AtprotoDataParseError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.AtprotoDataParseError)  
>          * [DidNotFoundError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.DidNotFoundError)  
>          * [DidPlcResolverError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.DidPlcResolverError)  
>          * [DidWebResolverError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.DidWebResolverError)  
>          * [PoorlyFormattedDidDocumentError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.PoorlyFormattedDidDocumentError)  
>          * [PoorlyFormattedDidError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.PoorlyFormattedDidError)  
>          * [UnsupportedDidMethodError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.UnsupportedDidMethodError)  
>          * [UnsupportedDidWebPathError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.UnsupportedDidWebPathError)  
>    * [Crypto](about:blank/exceptions.html#module-atproto%5Fcrypto.exceptions)  
>          * [DidKeyError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.DidKeyError)  
>          * [IncorrectDidKeyPrefixError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.IncorrectDidKeyPrefixError)  
>          * [IncorrectMultikeyPrefixError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.IncorrectMultikeyPrefixError)  
>          * [InvalidCompressedPubkeyError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.InvalidCompressedPubkeyError)  
>          * [UnsupportedKeyTypeError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.UnsupportedKeyTypeError)  
>          * [UnsupportedSignatureAlgorithmError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.UnsupportedSignatureAlgorithmError)  
>    * [Server](about:blank/exceptions.html#module-atproto%5Fserver.exceptions)  
>          * [InvalidTokenError](about:blank/exceptions.html#atproto%5Fserver.exceptions.InvalidTokenError)  
>          * [TokenDecodeError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenDecodeError)  
>          * [TokenExpiredSignatureError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenExpiredSignatureError)  
>          * [TokenImmatureSignatureError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenImmatureSignatureError)  
>          * [TokenInvalidAudienceError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenInvalidAudienceError)  
>          * [TokenInvalidIssuedAtError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenInvalidIssuedAtError)  
>          * [TokenInvalidSignatureError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenInvalidSignatureError)  
>    * [Lexicon](about:blank/exceptions.html#module-atproto%5Flexicon.exceptions)  
>          * [LexiconParsingError](about:blank/exceptions.html#atproto%5Flexicon.exceptions.LexiconParsingError)
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Let resolvedTarget be the URL resolution of the concatenation of
> packageURL and target.
> Assert: packageURL is contained in resolvedTarget.
> If patternMatch is null, then
> 
> Return resolvedTarget.
> 
> 
> If patternMatch split on "/" or "\" contains any "", ".",
> "..", or "node_modules" segments, case insensitive and including
> percent encoded variants, throw an Invalid Module Specifier error.
> Return the URL resolution of resolvedTarget with every instance of
> "*" replaced with patternMatch.
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> > [日本語](/uakihir0/kbsky/blob/main/docs/README%5Fja.md)
> 
> ## kbsky
> 
> [](#kbsky)
> 
> [![Maven Central Version](https://camo.githubusercontent.com/01a864834cd5596b8fede4647b24640217a22a870c5e4c0a682d0068bb17995d/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f776f726b2e736f6369616c6875622e6b62736b792f616c6c)](https://camo.githubusercontent.com/01a864834cd5596b8fede4647b24640217a22a870c5e4c0a682d0068bb17995d/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f776f726b2e736f6369616c6875622e6b62736b792f616c6c)
> 
> [![badge](https://camo.githubusercontent.com/a14bdf13f54d05dd84487481c44f7d5a394c7738f846984d6dcd2c51b0749693/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6a766d2d4442343133442e737667)](https://camo.githubusercontent.com/a14bdf13f54d05dd84487481c44f7d5a394c7738f846984d6dcd2c51b0749693/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6a766d2d4442343133442e737667) [![badge](https://camo.githubusercontent.com/357a086606eb9c0372515b69e5b7845d6a66d7af22f38889e60a51cb44c43972/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d696f732d4344434443442e737667)](https://camo.githubusercontent.com/357a086606eb9c0372515b69e5b7845d6a66d7af22f38889e60a51cb44c43972/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d696f732d4344434443442e737667) [![badge](https://camo.githubusercontent.com/a34549acfbc29ada665ee0f59348b80a8db2492dfbbaf5a0fd862b7e9fafb4c6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6d61636f732d3131313131312e737667)](https://camo.githubusercontent.com/a34549acfbc29ada665ee0f59348b80a8db2492dfbbaf5a0fd862b7e9fafb4c6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6d61636f732d3131313131312e737667)
> 
> **This library is a Bluesky/ATProtocol client library compatible with [Kotlin Multiplatform](https://kotlinlang.org/docs/multiplatform.html).**It depends on [khttpclient](https://github.com/uakihir0/khttpclient) and uses Ktor Client internally. Therefore, this library can be used on any platform supported by Kotlin Multiplatform and Ktor Client. The behavior on each platform depends on [khttpclient](https://github.com/uakihir0/khttpclient).
> 
> ## Usage
> 
> [](#usage)
> 
> Below is how to use it with Kotlin on the supported platforms using Gradle.  
> **If you are using it on an Apple platform, please refer to [kbsky-cocoapods](https://github.com/uakihir0/kbsky-cocoapods).**  
> Additionally, please check the test code as well.
> 
> ### Stable (Maven Central)
> 
> [](#stable-maven-central)
> 
> repositories {
>     mavenCentral()
> }
> 
> dependencies {
> +   implementation("work.socialhub.kbsky:core:0.3.0")
> +   implementation("work.socialhub.kbsky:auth:0.3.0")
> +   implementation("work.socialhub.kbsky:stream:0.3.0")
> }
> 
> ### Snapshot
> 
> [](#snapshot)
> 
> repositories {
> +   maven { url = uri("https://repo.repsy.io/mvn/uakihir0/public") }
> }
> 
> dependencies {
> +   implementation("work.socialhub.kbsky:core:0.4.0-SNAPSHOT")
> +   implementation("work.socialhub.kbsky:auth:0.4.0-SNAPSHOT")
> +   implementation("work.socialhub.kbsky:stream:0.4.0-SNAPSHOT")
> }
> 
> ### Using as part of a regular Java project
> 
> [](#using-as-part-of-a-regular-java-project)
> 
> All of the above can be added to and used in regular Java projects, too. All you have to do is to use the suffix `-jvm` when listing the dependency.
> 
> Here is a sample Maven configuration:
> 
> <dependency>
>     <groupId>work.socialhub.kbsky</groupId>
>     <artifactId>core-jvm</artifactId>
>     <version>[VERSION]</version>
> </dependency>
> 
> ### Starting a Session
> 
> [](#starting-a-session)
> 
> #### Authentication with Password
> 
> [](#authentication-with-password)
> 
> To start a session by specifying a handle and password, do as follows:
> 
> val response = BlueskyFactory
>     .instance(BSKY_SOCIAL.uri)
>     .server()
>     .createSession(
>         ServerCreateSessionRequest().also {
>             it.identifier = HANDLE
>             it.password = PASSWORD
>         }
>     )
> 
> println(response.data.accessJwt)
> 
> To access various resources with the obtained access token, execute the following:
> 
> val auth = BearerTokenAuthProvider(accessJwt)
> 
> BlueskyFactory
>     .instance(BSKY_SOCIAL.uri)
>     .feed()
>     .post(
>         FeedPostRequest(auth).also {
>             it.text = "Hello World!"
>         }
>     )
> 
> #### Authentication with OAuth
> 
> [](#authentication-with-oauth)
> 
> Authentication using a password is gradually being replaced with OAuth. For more details on OAuth authentication, please refer to [Authentication via OAuth](/uakihir0/kbsky/blob/main/docs/OAUTH.md).
> 
> ### PLC Directory
> 
> [](#plc-directory)
> 
> val response = PLCDirectoryFactory
>     .instance()
>     .DIDDetails(did)
> 
> println(checkNotNull(response.data.alsoKnownAs)[0])
> 
> ### SubscribeRepos (stream)
> 
> [](#subscriberepos-stream)
> 
> val stream = ATProtocolStreamFactory
>     .instance(
>         apiUri = BSKY_SOCIAL.uri,
>         streamUri = BSKY_NETWORK.uri
>     )
>     .sync()
>     .subscribeRepos(
>         SyncSubscribeReposRequest().also {
>             it.filter = listOf(
>                 "app.bsky.feed.post"
>             )
>         }
>     )
> 
> stream.eventCallback(
>     object : EventCallback {
>         override fun onEvent(
>             cid: String?,
>             uri: String?,
>             record: RecordUnion
>         ) {
>             print(record)
>         }
>     })
> 
> ## License
> 
> [](#license)
> 
> MIT License
> 
> ## Author
> 
> [](#author)
> 
> [Akihiro Urushihara](https://github.com/uakihir0)
> 
> Creates a mutable Headers from the given headers with
>  the same header names and values.
> 
> java.io.InvalidClassException(String, String, Throwable)
> 19
> 
> Report an InvalidClassException for the reason and cause specified.
> 
> java.io.InvalidClassException(String, Throwable)
> 19
> 
> Report an InvalidClassException for the reason and cause specified.
> 
> java.io.InvalidObjectException(String, Throwable)
> 19
> 
> Constructs an InvalidObjectException with the given
>  reason and cause.
> 
> ineffectual. Do not use; no replacement.
> 
> java.security.interfaces.RSAPublicKey.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.security.Key.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.security.PrivateKey.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.security.PublicKey.serialVersionUID
> 
> Thrown when a structure violation is detected.
> 
> javax.crypto.DecapsulateException
> 21
> 
> An exception that is thrown by the
>  KEM.Decapsulator.decapsulate(byte[]) method to denote an
>  error during decapsulation.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Record Classes
> 
> 
> 
> 
> 
> 
> jdk.jshell.SourceCodeAnalysis.Highlight
> 19
> 
> Assigns attributes usable for coloring to spans inside a snippet.
> 
> jdk.net.UnixDomainPrincipal
> 16
> 
> Represents the credentials of a peer connected to a
>  
>  Unix domain socket.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Annotation Interfaces
> 
> java.io.ObjectStreamException(String, Throwable)
> 19
> 
> Create an ObjectStreamException with the specified message and
>  cause.
> 
> java.io.ObjectStreamException(Throwable)
> 19
> 
> Create an ObjectStreamException with the specified cause.
> 
> java.lang.IndexOutOfBoundsException(long)
> 16
> 
> Constructs a new IndexOutOfBoundsException class with an
>  argument indicating the illegal index.
> 
> java.net.ServerSocket(SocketImpl)
> 12
> 
> Creates a server socket with a user-specified SocketImpl.
> 
> An abstract class for service providers that
>  provide concrete implementations of the
>  NumberFormat class.
> 
> Provider
> 
> This class represents a "provider" for the
>  Java Security API, where a provider implements some or all parts of
>  Java Security.
> 
> ResourceBundleControlProvider
> 
> An interface for service providers that provide implementations of ResourceBundle.Control.
> 
> ResourceBundleProvider
> 
> ResourceBundleProvider is a service provider interface for
>  resource bundles.
> 
> SelectorProvider
> 
> Modules
> Packages
> Interfaces
> Classes
> Enum Classes
> Exception Classes
> Record Classes
> Annotation Interfaces
> Fields
> Methods
> Constructors
> Enum Constants
> 
> 
> 
> 
> New Modules
> 
> 
> 
> 
> 
> 
> jdk.jpackage
> 16
> 
> Defines the Java Packaging tool, jpackage.
> 
> jdk.nio.mapmode
> 14
> 
> Defines JDK-specific file mapping modes.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Packages
> 
> 
> 
> 
> 
> 
> java.lang.constant
> 12
> 
> Classes and interfaces to represent nominal descriptors for run-time
>  entities such as classes or method handles, and classfile entities such as
> 
> PSSParameterSpec(String, String, AlgorithmParameterSpec, int, int) constructor.
> 
> java.util.jar.Attributes.Name.EXTENSION_INSTALLATION
> 
> 
> Extension mechanism is no longer supported.
> 
> java.util.jar.Attributes.Name.IMPLEMENTATION_URL
> 
> 
> Extension mechanism is no longer supported.
> 
> java.util.jar.Attributes.Name.IMPLEMENTATION_VENDOR_ID
> 
> 
> Extension mechanism is no longer supported.
> 
> java.util.logging.Logger.global
> 
> 
> Initialization of this field is prone to deadlocks.
> 
> component of a record class.
> 
> java.lang.runtime.ObjectMethods
> 16
> 
> Bootstrap methods for state-driven implementations of core methods,
>  including Object.equals(Object), Object.hashCode(), and
>  Object.toString().
> 
> java.lang.runtime.SwitchBootstraps
> 21
> 
> Bootstrap methods for linking invokedynamic call sites that implement
>  the selection functionality of the switch statement.
> 
> java.lang.runtime.TemplateRuntimePREVIEW
> 21
> 
> Manages string template bootstrap methods.
> 
> java.lang.ScopedValuePREVIEW
> 21
> 
> A simple HTTP file server and its components (intended for testing,
>  development and debugging purposes only).
> 
> java.lang.constant.ConstantDescs
> 12
> 
> Predefined values of nominal descriptor
>  for common constants, including descriptors for primitive class types and
>  other common platform types, and descriptors for method handles for standard
>  bootstrap methods.
> 
> java.lang.constant.DynamicCallSiteDesc
> 12
> 
> A nominal descriptor for an
>  invokedynamic call site.
> 
> java.lang.constant.DynamicConstantDesc
> 
> constant pool entries or invokedynamic call sites.
> 
> java.lang.runtime
> 14
> 
> The java.lang.runtime package provides low-level runtime support
>  for the Java language.
> 
> java.util.random
> 17
> 
> This package contains classes and interfaces that support a generic API
>  for random number generation.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Interfaces
> 
> 
> 
> 
> 
> 
> com.sun.net.httpserver.Request
> 18
> 
> A view of the immutable request state of an HTTP exchange.
> 
> com.sun.source.doctree.EscapeTree
> 21
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> In this example, the sources are found in the parent directory ../src/main/java, and only Java files within a core package are included.
> The final result when building will look like this:
> /
> +- pom.xml
> +- src/
>    +- main/
>       +- java/
>           +- core/
>              +- Core.java
>           +- module/
>              +- Module.java
> +- core/
>    +- pom.xml
>    +- target/
>       +- my-core-1.0-SNAPSHOT.jar
> +- module/
>    +- pom.xml
>    +- target/
>       +- my-module-1.0-SNAPSHOT.jar
> 
> testThis scope indicates that the dependency is not required for normal use of the application, and is only available for the test compilation and execution phases. This scope is not transitive. Typically this scope is used for test libraries such as JUnit and Mockito. It is also used for non-test libraries such as Apache Commons IO if those libraries are used in unit tests (src/test/java) but not in the model code (src/main/java).
> 
> providedThis is much like compile, but indicates you expect the JDK or a container to provide the dependency at runtime. For example, when building a web application for the Java Enterprise Edition, you would set the dependency on the Servlet API and related Java EE APIs to scope provided because the web container provides those classes. A dependency with this scope is added to the classpath used for compilation and test, but not the runtime classpath. It is not transitive.
> 
> Application/Library sources
> 
> src/main/resources
> Application/Library resources
> 
> src/main/filters
> Resource filter files
> 
> src/main/webapp
> Web application sources
> 
> src/test/java
> Test sources
> 
> src/test/resources
> Test resources
> 
> src/test/filters
> Test resource filter files
> 
> src/it
> Integration Tests (primarily for plugins)
> 
> src/assembly
> Assembly descriptors
> 
> src/site
> Site
> 
> LICENSE.txt
> Project's license
> 
> NOTICE.txt
> Notices and attributions required by libraries that the project depends on
> 
> README.txt
> 
> API used in Surefire and Failsafe MOJO, Booter, Common and test framework providers.
> 
> Surefire Extensions API
> Surefire is a test framework project.
>     This is the aggregator POM in Apache Maven Surefire project.
> 
> Surefire Extensions SPI
> Surefire is a test framework project.
>     This is the aggregator POM in Apache Maven Surefire project.
> 
> Surefire Booter
> API and Facilities used by forked tests running in JVM sub-process.
> 
> Maven Surefire Test-Grouping Support
> 
> This causes the simple mojo to be executed whenever Java code is compiled. For more information on binding a mojo to phases in the lifecycle, see the Build Lifecycle document.
> Mojo archetype
> To create a new plugin project, you can use the Mojo archetype with the following command line:
> mvn archetype:generate \
>   -DgroupId=sample.plugin \
>   -DartifactId=hello-maven-plugin \
>   -DarchetypeGroupId=org.apache.maven.archetypes \
>   -DarchetypeArtifactId=maven-archetype-plugin
> Parameters
> 
> compile
> You may test the newly compiled and packaged JAR with the following command:
> java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App
> Which will print the quintessential:
> Hello World!
> Java 9 or later
> 
> 3.0
> jar
> BSD-3-Clause
> 
> org.htmlunit
> htmlunit
> 4.4.0
> jar
> Apache License, Version 2.0
> Project Transitive Dependencies
> The following is a list of transitive dependencies for this project. Transitive dependencies are the dependencies of the project dependencies.
> test
> The following is a list of test dependencies for this project. These dependencies are only required to compile and run unit tests for the application:
> 
> 
> GroupId
> ArtifactId
> Version
> Type
> Licenses
> 
> commons-codec
> commons-codec
> 1.17.1
> jar
> 
> Documentation
> Getting Started with Maven
> 
> Getting Started in 5 Minutes
> Getting Started in 30 Minutes
> Introductions
> 
> The Build Lifecycle
> The POM
> Profiles
> Repositories
> Standard Directory Layout
> The Dependency Mechanism
> 
>  Optional Dependencies and Dependency Exclusions
> Plugins
> 
> Plugin Development
> Configuring Plug-ins
> Plugin Prefix Resolution
> Developing Java Plugins
> Site
> 
> Creating a Site
> The APT Format
> Snippet Macro
> Archetypes
> 
> What is an Archetype
> Creating Archetypes
> Upgrading
> 
> Guide for New Committers
> Testing Development Versions of Plugins
> 3rd Party Resources
> Conventions
> 
> Maven Conventions
> Naming Conventions
> When You Can't Use the Conventions
> The Central Repository
> 
> Introduction to the Central Repository
> Uploading Artifacts to the Central Repository
> Improving the Repository
> References
> 
> POM Overview (Technical Project Descriptor)
> Settings Overview (Technical Settings Descriptor)
> Core Plug-ins List
> Mojo API
> Glossary
> Javadoc API
> 
> The following is a list of transitive dependencies for this project. Transitive dependencies are the dependencies of the project dependencies.
> test
> The following is a list of test dependencies for this project. These dependencies are only required to compile and run unit tests for the application:
> 
> 
> GroupId
> ArtifactId
> Version
> Type
> Licenses
> 
> net.bytebuddy
> byte-buddy
> 1.14.18
> jar
> Apache License, Version 2.0
> 
> org.hamcrest
> hamcrest
> 3.0
> jar
> BSD-3-Clause
> 
> org.hamcrest
> hamcrest-core
> 3.0
> jar
> 
> Within artifact producing source directories (ie. main and test), there is one directory for the language java (under which the normal package hierarchy exists), and one for resources (the structure which is copied to the target classpath given the default resource definition).
> If there are other contributing sources to the artifact build, they would be under other subdirectories. For example src/main/antlr would contain Antlr grammar definition files.
> 
> Git / GitHub
> GitHub Issues
> 
>  compiler
> B
> 3.13.0
> 2024-03-15
> Compiles Java sources.
> Git / GitHub
> Jira MCOMPILER
> 
>  deploy
> B
> 3.1.3
> 2024-08-19
> Deploy the built artifact to the remote repository.
> Git / GitHub
> Jira MDEPLOY
> 
>  failsafe
> B
> 3.5.2
> 2024-10-30
> Run the JUnit integration tests in an isolated classloader.
> Git / GitHub
> Jira SUREFIRE
> 
>  install
> B
> 3.1.3
> 2024-08-19
> Install the built artifact into the local repository.
> Git / GitHub
> Jira MINSTALL
> 
>  resources
> B
> 3.3.1
> 2023-03-21
> 
> <goal>java</goal>            </goals>          </execution>        </executions>        <configuration>          <models>            <model>src/main/mdo/archetype-descriptor.mdo</model>          </models>          <version>1.0.0</version>          <useJava5>true</useJava5>        </configuration>      </plugin>    </plugins>  </build>  ...</project>
> 
> `-- AppTest.java
> The src/main/java directory contains the project source code, the src/test/java directory contains the test source, and the pom.xml file is the project's Project Object Model, or POM.
> The POM
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> Here is a file tree of the current workspace:
> 
> LICENSE.md
> pom.xml
> README.md
> src/
>   main/
>     test/
>       resources/
>         lexicons/
>           test.json
>       java/
>         com/
>           atproto/
>             ClientTest.java
>             moderation/
>               ModerationActionTest.java
>             common/
>               AtUriTest.java
>             codegen/
>               ClientGeneratorMockingTest.java
>               ClientGeneratorTest.java
>               LexiconParserTest.java
>               ModelGeneratorTest.java
>               TestUtils.java
>             api/
>               AtpAgentTest.java
>               xrpc/
>                 XrpcClientTest.java
>     java/
>       com/
>         atproto/
>           RichText.java
>           moderation/
>             ModerationAction.java
>           codegen/
>             ClientGenerator.java
>             Generator.java
>             InMemoryCompiler.java
>             LexiconParser.java
>             ModelGenerator.java
>           api/
>             AtpAgent.java
>             AtpResponse.java
>             AtpSession.java
>             RichText.java
>             xrpc/
>               HttpUtil.java
>               XrpcClient.java
>               XrpcException.java
>               XrpcRequest.java
>               XrpcResponse.java
>               model/
>                 Params.java
>             typeguards/
>               AppBsktFeedDefs.java
>               AppBskyFeedPost.java
>             moderation/
>               ModerationAction.java
>             models/
>               com/
>                 bsky/
>                   feed/
>                     GetTimelineRequest.java
>                     GetTimelineResponse.java
>                     Post.java
>                 atpro/
>                   repo/
>                     CreateRecordRequest.java
>                     CreateRecordResponse.java
>                     ListRecordsRequest.java
>                     ListRecordsResponse.java
>             identity/
>               DidResolver.java
>               HandleResolver.java
>               IdentityResolver.java
>             crypto/
>               KeySerialization.java
>               SigningUtil.java
>             common/
>               AtProtoException.java
>               AtUri.java
>               Cid.java
>               Did.java
>               Handle.java
>               Nsid.java
> docs/
>   README.md
>   chats/
>     20250323T203205_session.md
>     20250323T213831_session.md
>     20250323T221653_session.md
>     20250324T223048_session.md
>     20250324T225544_session.md
>     20250324T231724_session.md
>     README.md
> 
> 
> * * [ GitHub Copilot Write better code with AI ](https://github.com/features/copilot)  
>    * [ Security Find and fix vulnerabilities ](https://github.com/features/security)  
>    * [ Actions Automate any workflow ](https://github.com/features/actions)  
>    * [ Codespaces Instant dev environments ](https://github.com/features/codespaces)  
>    * [ Issues Plan and track work ](https://github.com/features/issues)  
>    * [ Code Review Manage code changes ](https://github.com/features/code-review)  
>    * [ Discussions Collaborate outside of code ](https://github.com/features/discussions)  
>    * [ Code Search Find more, search less ](https://github.com/features/code-search)
> * Explore  
>    * [ Learning Pathways](https://resources.github.com/learn/pathways)  
>    * [ Events & Webinars](https://resources.github.com/)  
>    * [ Ebooks & Whitepapers](https://github.com/resources/whitepapers)  
>    * [ Customer Stories](https://github.com/customer-stories)  
>    * [ Partners](https://partner.github.com/)  
>    * [ Executive Insights](https://github.com/solutions/executive-insights)
> * * [ GitHub Sponsors Fund open source developers ](/sponsors)  
>    * [ The ReadME Project GitHub community articles ](https://github.com/readme)
> * * [ Enterprise platform AI-powered developer platform ](/enterprise)
> * [Pricing](https://github.com/pricing)
> 
> ##  Provide feedback
> 
> ##  Saved searches
> 
> ## Use saved searches to filter your results more quickly
> 
> [ Sign up](/signup?ref%5Fcta=Sign+up&ref%5Floc=header+logged+out&ref%5Fpage=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source%5Frepo=bluesky-social%2Fatproto) 
> 
> * * [ GitHub Copilot Write better code with AI ](https://github.com/features/copilot)  
>    * [ Security Find and fix vulnerabilities ](https://github.com/features/security)  
>    * [ Actions Automate any workflow ](https://github.com/features/actions)  
>    * [ Codespaces Instant dev environments ](https://github.com/features/codespaces)  
>    * [ Issues Plan and track work ](https://github.com/features/issues)  
>    * [ Code Review Manage code changes ](https://github.com/features/code-review)  
>    * [ Discussions Collaborate outside of code ](https://github.com/features/discussions)  
>    * [ Code Search Find more, search less ](https://github.com/features/code-search)
> * Explore  
>    * [ Learning Pathways](https://resources.github.com/learn/pathways)  
>    * [ Events & Webinars](https://resources.github.com/)  
>    * [ Ebooks & Whitepapers](https://github.com/resources/whitepapers)  
>    * [ Customer Stories](https://github.com/customer-stories)  
>    * [ Partners](https://partner.github.com/)  
>    * [ Executive Insights](https://github.com/solutions/executive-insights)
> * * [ GitHub Sponsors Fund open source developers ](/sponsors)  
>    * [ The ReadME Project GitHub community articles ](https://github.com/readme)
> * * [ Enterprise platform AI-powered developer platform ](/enterprise)
> * [Pricing](https://github.com/pricing)
> 
> ##  Provide feedback
> 
> ##  Saved searches
> 
> ## Use saved searches to filter your results more quickly
> 
> [ Sign up](/signup?ref%5Fcta=Sign+up&ref%5Floc=header+logged+out&ref%5Fpage=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source%5Frepo=bluesky-social%2Fatproto) 
> 
> * * [ GitHub Copilot Write better code with AI ](https://github.com/features/copilot)  
>    * [ Security Find and fix vulnerabilities ](https://github.com/features/security)  
>    * [ Actions Automate any workflow ](https://github.com/features/actions)  
>    * [ Codespaces Instant dev environments ](https://github.com/features/codespaces)  
>    * [ Issues Plan and track work ](https://github.com/features/issues)  
>    * [ Code Review Manage code changes ](https://github.com/features/code-review)  
>    * [ Discussions Collaborate outside of code ](https://github.com/features/discussions)  
>    * [ Code Search Find more, search less ](https://github.com/features/code-search)
> * Explore  
>    * [ Learning Pathways](https://resources.github.com/learn/pathways)  
>    * [ Events & Webinars](https://resources.github.com/)  
>    * [ Ebooks & Whitepapers](https://github.com/resources/whitepapers)  
>    * [ Customer Stories](https://github.com/customer-stories)  
>    * [ Partners](https://partner.github.com/)  
>    * [ Executive Insights](https://github.com/solutions/executive-insights)
> * * [ GitHub Sponsors Fund open source developers ](/sponsors)  
>    * [ The ReadME Project GitHub community articles ](https://github.com/readme)
> * * [ Enterprise platform AI-powered developer platform ](/enterprise)
> * [Pricing](https://github.com/pricing)
> 
> ##  Provide feedback
> 
> ##  Saved searches
> 
> ## Use saved searches to filter your results more quickly
> 
> [ Sign up](/signup?ref%5Fcta=Sign+up&ref%5Floc=header+logged+out&ref%5Fpage=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source%5Frepo=bluesky-social%2Fatproto) 
> 
> * * [ GitHub Copilot Write better code with AI ](https://github.com/features/copilot)  
>    * [ Security Find and fix vulnerabilities ](https://github.com/features/security)  
>    * [ Actions Automate any workflow ](https://github.com/features/actions)  
>    * [ Codespaces Instant dev environments ](https://github.com/features/codespaces)  
>    * [ Issues Plan and track work ](https://github.com/features/issues)  
>    * [ Code Review Manage code changes ](https://github.com/features/code-review)  
>    * [ Discussions Collaborate outside of code ](https://github.com/features/discussions)  
>    * [ Code Search Find more, search less ](https://github.com/features/code-search)
> * Explore  
>    * [ Learning Pathways](https://resources.github.com/learn/pathways)  
>    * [ Events & Webinars](https://resources.github.com/)  
>    * [ Ebooks & Whitepapers](https://github.com/resources/whitepapers)  
>    * [ Customer Stories](https://github.com/customer-stories)  
>    * [ Partners](https://partner.github.com/)  
>    * [ Executive Insights](https://github.com/solutions/executive-insights)
> * * [ GitHub Sponsors Fund open source developers ](/sponsors)  
>    * [ The ReadME Project GitHub community articles ](https://github.com/readme)
> * * [ Enterprise platform AI-powered developer platform ](/enterprise)
> * [Pricing](https://github.com/pricing)
> 
> ##  Provide feedback
> 
> ##  Saved searches
> 
> ## Use saved searches to filter your results more quickly
> 
> [ Sign up](/signup?ref%5Fcta=Sign+up&ref%5Floc=header+logged+out&ref%5Fpage=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source%5Frepo=bluesky-social%2Fatproto) 
> 
> * * [ GitHub Copilot Write better code with AI ](https://github.com/features/copilot)  
>    * [ Security Find and fix vulnerabilities ](https://github.com/features/security)  
>    * [ Actions Automate any workflow ](https://github.com/features/actions)  
>    * [ Codespaces Instant dev environments ](https://github.com/features/codespaces)  
>    * [ Issues Plan and track work ](https://github.com/features/issues)  
>    * [ Code Review Manage code changes ](https://github.com/features/code-review)  
>    * [ Discussions Collaborate outside of code ](https://github.com/features/discussions)  
>    * [ Code Search Find more, search less ](https://github.com/features/code-search)
> * Explore  
>    * [ Learning Pathways](https://resources.github.com/learn/pathways)  
>    * [ Events & Webinars](https://resources.github.com/)  
>    * [ Ebooks & Whitepapers](https://github.com/resources/whitepapers)  
>    * [ Customer Stories](https://github.com/customer-stories)  
>    * [ Partners](https://partner.github.com/)  
>    * [ Executive Insights](https://github.com/solutions/executive-insights)
> * * [ GitHub Sponsors Fund open source developers ](/sponsors)  
>    * [ The ReadME Project GitHub community articles ](https://github.com/readme)
> * * [ Enterprise platform AI-powered developer platform ](/enterprise)
> * [Pricing](https://github.com/pricing)
> 
> ##  Provide feedback
> 
> ##  Saved searches
> 
> ## Use saved searches to filter your results more quickly
> 
> [ Sign up](/signup?ref%5Fcta=Sign+up&ref%5Floc=header+logged+out&ref%5Fpage=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source%5Frepo=bluesky-social%2Fatproto) 
> 
> * * [ GitHub Copilot Write better code with AI ](https://github.com/features/copilot)  
>    * [ Security Find and fix vulnerabilities ](https://github.com/features/security)  
>    * [ Actions Automate any workflow ](https://github.com/features/actions)  
>    * [ Codespaces Instant dev environments ](https://github.com/features/codespaces)  
>    * [ Issues Plan and track work ](https://github.com/features/issues)  
>    * [ Code Review Manage code changes ](https://github.com/features/code-review)  
>    * [ Discussions Collaborate outside of code ](https://github.com/features/discussions)  
>    * [ Code Search Find more, search less ](https://github.com/features/code-search)
> * Explore  
>    * [ Learning Pathways](https://resources.github.com/learn/pathways)  
>    * [ Events & Webinars](https://resources.github.com/)  
>    * [ Ebooks & Whitepapers](https://github.com/resources/whitepapers)  
>    * [ Customer Stories](https://github.com/customer-stories)  
>    * [ Partners](https://partner.github.com/)  
>    * [ Executive Insights](https://github.com/solutions/executive-insights)
> * * [ GitHub Sponsors Fund open source developers ](/sponsors)  
>    * [ The ReadME Project GitHub community articles ](https://github.com/readme)
> * * [ Enterprise platform AI-powered developer platform ](/enterprise)
> * [Pricing](https://github.com/pricing)
> 
> ##  Provide feedback
> 
> ##  Saved searches
> 
> ## Use saved searches to filter your results more quickly
> 
> [ Sign up](/signup?ref%5Fcta=Sign+up&ref%5Floc=header+logged+out&ref%5Fpage=%2F%3Cuser-name%3E%2F%3Crepo-name%3E%2Ffiles%2Fdisambiguate&source=header-repo&source%5Frepo=bluesky-social%2Fatproto) 
> 
> ## @atproto/xrpc: atproto HTTP API Client
> 
> [](#atprotoxrpc-atproto-http-api-client)
> 
> TypeScript client library for talking to [atproto](https://atproto.com/) services, with Lexicon schema validation.
> 
> [![NPM](https://camo.githubusercontent.com/c34b17f0a5b255f0951a320171f339cdfcb4a520329f0bef5b787ec65a1f2f0f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f78727063)](https://www.npmjs.com/package/@atproto/xrpc) [![Github CI Status](https://github.com/bluesky-social/atproto/actions/workflows/repo.yaml/badge.svg)](https://github.com/bluesky-social/atproto/actions/workflows/repo.yaml)
> 
> ## Usage
> 
> [](#usage)
> 
> import { LexiconDoc } from '@atproto/lexicon'
> import { XrpcClient } from '@atproto/xrpc'
> 
> const pingLexicon = {
>   lexicon: 1,
>   id: 'io.example.ping',
>   defs: {
>     main: {
>       type: 'query',
>       description: 'Ping the server',
>       parameters: {
>         type: 'params',
>         properties: { message: { type: 'string' } },
>       },
>       output: {
>         encoding: 'application/json',
>         schema: {
>           type: 'object',
>           required: ['message'],
>           properties: { message: { type: 'string' } },
>         },
>       },
>     },
>   },
> } satisfies LexiconDoc
> 
> const xrpc = new XrpcClient('https://ping.example.com', [
>   // Any number of lexicon here
>   pingLexicon,
> ])
> 
> const res1 = await xrpc.call('io.example.ping', {
>   message: 'hello world',
> })
> res1.encoding // => 'application/json'
> res1.body // => {message: 'hello world'}
> 
> ### With a custom fetch handler
> 
> [](#with-a-custom-fetch-handler)
> 
> import { XrpcClient } from '@atproto/xrpc'
> 
> const session = {
>   serviceUrl: 'https://ping.example.com',
>   token: '<my-token>',
>   async refreshToken() {
>     const { token } = await fetch('https://auth.example.com/refresh', {
>       method: 'POST',
>       headers: { Authorization: `Bearer ${this.token}` },
>     }).then((res) => res.json())
> 
>     this.token = token
> 
>     return token
>   },
> }
> 
> const sessionBasedFetch: FetchHandler = async (
>   url: string,
>   init: RequestInit,
> ) => {
>   const headers = new Headers(init.headers)
> 
>   headers.set('Authorization', `Bearer ${session.token}`)
> 
>   const response = await fetch(new URL(url, session.serviceUrl), {
>     ...init,
>     headers,
>   })
> 
>   if (response.status === 401) {
>     // Refresh token, then try again.
>     const newToken = await session.refreshToken()
>     headers.set('Authorization', `Bearer ${newToken}`)
>     return fetch(new URL(url, session.serviceUrl), { ...init, headers })
>   }
> 
>   return response
> }
> 
> const xrpc = new XrpcClient(sessionBasedFetch, [
>   // Any number of lexicon here
>   pingLexicon,
> ])
> 
> //
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> ```java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java> 
> > 
> package com.atproto.codegen;> 
> > 
> import static org.junit.jupiter.api.Assertions.*;> 
> import static org.mockito.Mockito.*;> 
> > 
> import com.atproto.api.AtpResponse;> 
> import com.atproto.api.xrpc.XRPCException;> 
> import com.atproto.lexicon.models.*;> 
> > 
> import java.io.IOException;> 
> import java.lang.annotation.Annotation;> 
> import java.lang.reflect.Field;> 
> import java.time.Instant;> 
> import java.util.ArrayList;> 
> import java.util.HashMap;> 
> import java.util.List;> 
> import java.util.Map;> 
> import java.util.Optional;> 
> import java.util.stream.Stream;> 
> > 
> import javax.validation.constraints.*;> 
> > 
> import org.junit.jupiter.api.BeforeEach;> 
> import org.junit.jupiter.api.Test;> 
> import org.junit.jupiter.params.ParameterizedTest;> 
> import org.junit.jupiter.params.provider.Arguments;> 
> import org.junit.jupiter.params.provider.MethodSource;> 
> import org.mockito.junit.jupiter.MockitoExtension;> 
> import org.junit.jupiter.api.extension.ExtendWith;> 
> import org.mockito.Mock;> 
> > 
> @ExtendWith(MockitoExtension.class)> 
> public class ClientGeneratorTest {> 
> > 
>     @Mock> 
>     private XrpcClient mockXrpcClient;> 
> > 
>     private ClientGenerator generator;> 
> > 
>     @BeforeEach> 
>     public void setUp() {> 
>         generator = new ClientGenerator();> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForSimpleQuery() throws Exception {> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         assertTrue(generatedCode.contains("package com.example;"));> 
>         assertTrue(generatedCode.contains("public class SimpleQueryClient"));> 
>         assertTrue(generatedCode.contains("public AtpResponse"));> 
>         assertTrue(generatedCode.contains("simpleQuery("));> 
>         assertTrue(generatedCode.contains("xrpcClient.sendQuery"));> 
>         assertFalse(> 
>                 generatedCode.contains("import com.atproto.api.xrpc.XRPCException;")); // No params, no> 
>         // XRPCException import> 
> > 
>         // --- Compilation and Reflection ---> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",> 
>                 generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Stub the mockXrpcClient to return a successful response> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
> > 
>         // Invoke and check return type.> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");> 
>         Object result = method.invoke(clientInstance);> 
>         assertInstanceOf(AtpResponse.class, result);> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForQueryWithParams()> 
>             throws Exception { // Added Exception> 
>         // Test params Client> 
>         LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon(); // Create Lexicon> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate> 
> > 
>         // Basic checks> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name> 
>         assertTrue(generatedCode.contains("public class ParamsQueryClient")); // Class Name.> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "paramsQuery(ParamsQueryParams params")); // Query method with parameters and type> 
>         assertTrue(generatedCode.contains("xrpcClient.sendQuery")); // Use XRPC> 
> > 
>         // --- Compilation and Reflection ---> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient",> 
>                 generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Stub> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
> > 
>         Class<?> paramClass = Class.forName("com.example.ParamsQueryParams");> 
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();> 
> > 
>         // Invoke and check return type> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("paramsQuery", paramClass);> 
>         Object result = method.invoke(clientInstance, paramInstance); // Pass the parameter instance> 
>         assertInstanceOf(AtpResponse.class, result);> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForProcedure() throws Exception { // Added Exception> 
>         // Test Procedure> 
>         LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon(); // Create Lexicon> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate> 
> > 
>         // Basic checks> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name> 
>         assertTrue(generatedCode.contains("public class ProcedureClient")); // Class name> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Return AtpResponse> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "procedure(ProcedureProcedureInput input")); // Proper params> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "xrpcClient.sendProcedure")); // Check for XRPC call (should be checked in its own test)> 
> > 
>         // --- Compilation and Reflection ---> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient",> 
>                 generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Stub> 
>         when(mockXrpcClient.sendProcedure(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
> > 
>         Class<?> inputClass = Class.forName("com.example.ProcedureProcedureInput");> 
>         Object inputInstance = inputClass.getDeclaredConstructor().newInstance();> 
> > 
>         // Execute and test> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method> 
>         // signature> 
>         Object result = method.invoke(clientInstance, inputInstance); // Invoke with parameter> 
>         assertInstanceOf(AtpResponse.class, result);> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForSubscription() throws IOException {> 
>         // Test Subscription> 
>         LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon(); // Create Lexicon> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate> 
> > 
>         // Basic checks (subscriptions might have a very different structure)> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "public class SubscriptionClient")); // Class exists (name should automatically be generated> 
>                                                              // from the> 
>         // name)> 
>         assertTrue(generatedCode.contains("public void")); // void return type.> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "subscription(")); // Subscription Method. (name should automatically be generated> 
>         // from the name)> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "throw new UnsupportedOperationException")); // Subscription not implemented> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientWithMultipleMethods() throws IOException {> 
>         // Multiple Definitions> 
>         LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon(); // Create Lexicon> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator Instance> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate> 
> > 
>         // Check for multiple methods> 
>         assertTrue(generatedCode.contains("queryMethod(")); // Query exists> 
>         assertTrue(generatedCode.contains("procedureMethod(")); // Procedure Exists> 
>     }> 
> > 
>     // Test for duplicate method names. Should de-dupe> 
>     @Test> 
>     public void testGenerateClientWithDuplicateMethods() throws IOException {> 
>         LexiconDoc lexiconDoc = TestUtils.createDuplicateMethodLexicon();> 
>         ClientGenerator generator = new ClientGenerator();> 
> > 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate> 
> > 
>         // Check for multiple methods> 
>         assertEquals(1, countOccurrences(generatedCode, "queryMethod")); // Query exists> 
>     }> 
> > 
>     // Helper Method. (Need to find something more formal; maybe write one of my> 
>     // own)> 
>     public int countOccurrences(String text, String word) {> 
> > 
>         int count = 0; // Initialize a counter variable> 
> > 
>         int fromIndex = 0; // Start from the beginning> 
> > 
>         while ((fromIndex = text.indexOf(word, fromIndex)) != -1) {> 
>             count++;> 
>             fromIndex++; // Move past the word> 
>         }> 
> > 
>         return count;> 
>     }> 
> > 
>     // Test that XRPC Exception gets thrown.> 
>     @Test> 
>     public void testXRPCException() throws Exception {> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         assertTrue(generatedCode.contains("import com.atproto.api.xrpc.XRPCException;"));> 
> > 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",> 
>                 generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Stub the mock to throw the exception> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenThrow(new XRPCException(null, null));> 
> > 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");> 
> > 
>         // Assert that the method call throws the expected exception> 
>         assertThrows(> 
>                 XRPCException.class,> 
>                 () -> {> 
>                     method.invoke(clientInstance);> 
>                 });> 
>     }> 
> > 
>     // Test that AtpResponse gets imported.> 
>     @Test> 
>     public void testAtpResponseType() throws IOException {> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which> 
>         // Lexicon> 
>         // we make, just need one)> 
> > 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate> 
> > 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "import com.atproto.api.AtpResponse;")); // Should import AtpResponse> 
>     }> 
> > 
>     // Helper methods for creating Lexicon structures (for test readability)> 
>     // These would ideally be in a separate test utility class.> 
> > 
>     @ParameterizedTest> 
>     @MethodSource("provideLexiconsForAllParameterTypes")> 
>     public void testGenerateClientForVariousParameterTypes(> 
>             LexiconDoc lexiconDoc, String paramName, String expectedType)> 
>             throws Exception { // Added Exception> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // General checks (package, class name, etc.)> 
>         assertTrue(generatedCode.contains("package com.example;"));> 
> > 
>         // More specific checks based on parameter type. This is where we use the> 
>         // paramName.> 
>         assertTrue(generatedCode.contains(paramName)); // Very basic, does the parameter exist?> 
> > 
>         // Check that parameter type is correct> 
>         assertTrue(generatedCode.contains(expectedType + " " + paramName));> 
> > 
>         // --- Compilation and Reflection to check return type ---> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         // Inject mockXrpcClient> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Find the method and its return type. This assumes the method name is "main"> 
>         java.lang.reflect.Method method = null;> 
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {> 
>             if (m.getName().equals("main")) { // Or whatever the method name is in your generated code> 
>                 method = m;> 
>                 break;> 
>             }> 
>         }> 
>         assertNotNull(method, "Method 'main' not found in generated class");> 
> > 
>         // Get Return Type from Lexicon, create expected type from this> 
>         String expectedReturnType = "AtpResponse"; // Default> 
>         if (lexiconDoc.getDefs().get("main") instanceof LexXrpcQuery) {> 
>             LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");> 
>             if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {> 
>                 expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";> 
>             } else {> 
>                 expectedReturnType = "AtpResponse<Void>";> 
>             }> 
>         } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcProcedure) {> 
>             LexXrpcProcedure procedure = (LexXrpcProcedure) lexiconDoc.getDefs().get("main");> 
>             if (procedure.getOutput().isPresent() && procedure.getOutput().get().getSchema().isPresent()) {> 
>                 expectedReturnType = "AtpResponse<"> 
>                         + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get())> 
>                         + ">";> 
> > 
>             } else {> 
>                 expectedReturnType = "AtpResponse<Void>";> 
>             }> 
>         } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcSubscription) {> 
>             expectedReturnType = "void";> 
>         }> 
> > 
>         // Now we assert that the return type from code gen is as expected> 
>         String actualReturnType = method.getGenericReturnType().getTypeName()> 
>                 .replace(> 
>                         "java.util.concurrent.CompletableFuture",> 
>                         "AtpResponse"); // Simplify for testing> 
>         assertEquals(expectedReturnType, actualReturnType);> 
> > 
>         // Stub Mockito for the method call (added)> 
>         if (method.getParameterCount() > 0) { // For parameters> 
>             when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                     .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
>         } else { // No Parameters> 
>             when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                     .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
>         }> 
>     }> 
> > 
>     // Helper function to return expected Java type String from Lexicon definition.> 
>     private String getExpectedJavaType(LexXrpcBody xrpcBody) {> 
> > 
>         if (xrpcBody.getSchema().isEmpty()) {> 
>             return "Void";> 
>         }> 
> > 
>         LexXrpcBody schema = xrpcBody;> 
>         if (schema.getSchema().get() instanceof LexObject) {> 
>             return "Object"; // Placeholder, replace with generated class name if using nested objects.> 
>         } else if (schema.getSchema().get() instanceof LexArray) {> 
>             LexArray lexArray = (LexArray) schema.getSchema().get();> 
>             // Handle nested arrays> 
>             return getExpectedArrayType(lexArray);> 
>         } else if (schema.getSchema().get() instanceof LexPrimitive) {> 
>             return getExpectedPrimitiveType((LexPrimitive) schema.getSchema().get());> 
>         } else if (schema.getSchema().get() instanceof LexXrpcBody) {> 
>             return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());> 
>         } else if (schema.getSchema().get() instanceof LexRef) {> 
>             // Resolve references, including repository refs vs. defs refs. This is very> 
>             // basic.> 
>             LexRef ref = (LexRef) schema.getSchema().get();> 
>             String refStr = ref.getRef();> 
>             if (refStr.startsWith("#")) {> 
>                 return refStr.substring(refStr.lastIndexOf(".") + 1); // Local ref> 
>             } else {> 
>                 return refStr.replace(".", ""); // External ref> 
>             }> 
>         } else if (schema.getSchema().get() instanceof LexString) {> 
>             LexString lexString = (LexString) schema.getSchema().get();> 
>             if (lexString.getFormat().isPresent()) {> 
>                 if (lexString.getFormat().get().equals("datetime")) {> 
>                     return "java.time.Instant";> 
>                 } else if (lexString.getFormat().get().equals("cid")) {> 
>                     return "com.atproto.common.Cid";> 
>                 } else if (lexString.getFormat().get().equals("did")) {> 
>                     return "com.atproto.syntax.Did";> 
>                 } else if (lexString.getFormat().get().equals("handle")) {> 
>                     return "com.atproto.syntax.Handle";> 
>                 } else if (lexString.getFormat().get().equals("at-uri")) {> 
>                     return "com.atproto.syntax.AtUri";> 
>                 } else if (lexString.getFormat().get().equals("nsid")) {> 
>                     return "com.atproto.syntax.Nsid";> 
>                 } else if (lexString.getFormat().get().equals("uri")) {> 
>                     return "java.net.URI";> 
>                 } else if (lexString.getFormat().get().equals("language")) {> 
>                     return "java.util.Locale";> 
>                 } else if (lexString.getFormat().get().equals("uri-reference")) {> 
>                     return "java.net.URI"; // Assuming URI for uri-reference> 
>                 } else if (lexString.getFormat().get().equals("uri-template")) {> 
>                     return "java.lang.String"; // Assuming String for uri-template (no built-in type)> 
>                 } else if (lexString.getFormat().get().equals("email")) {> 
>                     return "java.lang.String"; // Assuming String for email> 
>                 } else if (lexString.getFormat().get().equals("hostname")) {> 
>                     return "java.lang.String"; // Assuming String for hostname> 
>                 } else if (lexString.getFormat().get().equals("ipv4")) {> 
>                     return "java.net.InetAddress"; // Assuming InetAddress for IPv4> 
>                 } else if (lexString.getFormat().get().equals("ipv6")) {> 
>                     return "java.net.InetAddress"; // Assuming InetAddress for IPv6> 
>                 }> 
>             }> 
>             return "String";> 
>         } else if (schema.getSchema().get() instanceof LexRefUnion) {> 
>             return "Object";> 
>         }> 
> > 
>         return "Object"; // Unreachable? Error?> 
>     }> 
> > 
>     private String getExpectedArrayType(LexArray lexArray) {> 
>         StringBuilder sb = new StringBuilder();> 
>         sb.append("java.util.List<");> 
>         LexType itemType = lexArray.getItems();> 
> > 
>         if (itemType instanceof LexPrimitive) {> 
>             sb.append(getExpectedPrimitiveType((LexPrimitive) itemType));> 
>         } else if (itemType instanceof LexArray) {> 
>             sb.append(getExpectedArrayType((LexArray) itemType)); // Recurse for nested arrays> 
>         } else if (itemType instanceof LexRef) {> 
>             // Resolve references> 
>             LexRef ref = (LexRef) itemType;> 
>             String refStr = ref.getRef();> 
>             if (refStr.startsWith("#")) {> 
>                 sb.append(refStr.substring(refStr.lastIndexOf(".") + 1));> 
>             } else {> 
>                 sb.append(refStr.replace(".", ""));> 
>             }> 
>         } else if (itemType instanceof LexRefUnion) {> 
>             sb.append("Object"); // No specific type in a refUnion> 
>         } else if (itemType instanceof LexObject) { // Nested object not allowed as Array> 
>             return "Object";> 
>         }> 
> > 
>         sb.append(">");> 
>         return sb.toString();> 
>     }> 
> > 
>     private String getExpectedPrimitiveType(LexPrimitive prim) {> 
>         if (prim instanceof LexBoolean) {> 
>             return "Boolean";> 
>         } else if (prim instanceof LexInteger) {> 
>             return "Integer";> 
>         } else if (prim instanceof LexString) {> 
>             return "String";> 
>         } else if (prim instanceof LexNumber) {> 
>             return "Float";> 
>         } else if (prim instanceof LexBytes) {> 
>             return "byte[]";> 
>         } else if (prim instanceof LexUnknown) {> 
>             return "java.util.Map<String, Object>";> 
>         }> 
>         return "Object"; // Should not happen in valid Lexicon> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForNestedObject() throws Exception { // Added Exception> 
>         LexiconDoc lexiconDoc = TestUtils.createNestedObjectLexicon();> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // Basic checks> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name> 
>         assertTrue(generatedCode.contains("public class NestedObjectClient")); // Class Name.> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "nestedObject(")); // Query method with parameters and type> 
> > 
>         // --- Compilation and Reflection, as before, BUT: ---> 
>         // 1. Compile and Get Class:> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient",> 
>                 generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         // 2. Inject Mock:> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // 3. Stub Mockito> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
> > 
>         // 4. Get and Invoke Method, Assert Return Type> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");> 
>         Object result = method.invoke(clientInstance);> 
>         assertInstanceOf(AtpResponse.class, result); // Very basic check> 
> > 
>         // You could add in more specific checks with Mockito here to check call> 
>         // parameters> 
>     }> 
> > 
>     @ParameterizedTest> 
>     @MethodSource("provideLexiconsForInvalidLexicons")> 
>     public void testInvalidLexiconStructure(> 
>             LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {> 
>         ClientGenerator generator = new ClientGenerator();> 
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));> 
>     }> 
> > 
>     @Test> 
>     public void testMultipleDefs() throws IOException {> 
>         LexiconDoc lexiconDoc = TestUtils.createLexiconWithMultipleDefs();> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
>         assertTrue(generatedCode.contains("class Query1Client"));> 
>         assertTrue(generatedCode.contains("class Query2Client"));> 
>         assertTrue(generatedCode.contains("class Record1Record")); // Check for records.> 
>     }> 
> > 
>     @ParameterizedTest // Enhanced to be parameterized> 
>     @MethodSource("provideLexiconsForRefUnionParams")> 
>     public void testGenerateClientForRefUnionParams(> 
>             LexiconDoc lexiconDoc, String methodName, String expectedParamType) throws Exception {> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         assertTrue(generatedCode.contains("package com.example;"));> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";> 
> > 
>         assertTrue(generatedCode.contains("public class " + className));> 
> > 
>         // Dynamic method name check> 
>         assertTrue(> 
>                 generatedCode.contains(> 
>                         "public AtpResponse " + methodName + "(" + expectedParamType + " params)"));> 
> > 
>         // --- Compilation, Reflection, and Mockito Stubbing ---> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
>         Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Find the method dynamically> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod(methodName, Class.forName(expectedParamType));> 
>         assertNotNull(method, "Method '" + methodName + "' not found in generated class");> 
> > 
>         // Basic stubbing (you'd expand this for specific test cases)> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
>     }> 
> > 
>     @Test> 
>     public void testJavadocGeneration() throws Exception { // Added Exception> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // Basic Javadoc checks> 
>         assertTrue(generatedCode.contains("/**"));> 
>         assertTrue(generatedCode.contains("* This is a test query.")); // Check for the description.> 
>         assertTrue(generatedCode.contains("*/"));> 
>         assertTrue(generatedCode.contains("public class SimpleQueryClientWithDescription"));> 
> > 
>         // Compile and load the class, then verify with reflection> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile(> 
>                 "com.example.SimpleQueryClientWithDescription", generatedCode);> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");> 
>         assertNotNull(> 
>                 method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more> 
>         // thorough.> 
>     }> 
> > 
>     @ParameterizedTest> 
>     @MethodSource("provideLexiconsForStringConstraints")> 
>     public void testStringConstraints(> 
>             LexiconDoc lexiconDoc,> 
>             String paramName,> 
>             String expectedType,> 
>             Integer maxLength,> 
>             Integer minLength,> 
>             String constValue,> 
>             String pattern)> 
>             throws Exception {> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // General checks, compilation, method retrieval (as before)> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         java.lang.reflect.Method method = null;> 
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {> 
>             if (m.getName().equals("main")) {> 
>                 method = m;> 
>                 break;> 
>             }> 
>         }> 
>         Class<?> paramClass = method.getParameterTypes()[0];> 
>         // Now using reflection> 
>         java.lang.reflect.Field paramField = null;> 
>         try {> 
>             paramField = paramClass.getDeclaredField(paramName);> 
> > 
>         } catch (Exception e) {> 
> > 
>             fail("parameter not found in parameters of generated class.");> 
>         }> 
> > 
>         // maxLength constraint> 
>         if (maxLength != null) {> 
>             Annotation maxLengthAnnotation = paramField.getAnnotation(MaxLength.class);> 
>             assertNotNull(maxLengthAnnotation, "MaxLength annotation not found");> 
>             assertEquals(> 
>                     maxLength.intValue(), ((MaxLength) maxLengthAnnotation).value(), "MaxLength value mismatch");> 
>         }> 
> > 
>         // minLength constraint> 
>         if (minLength != null) {> 
>             Annotation minLengthAnnotation = paramField.getAnnotation(MinLength.class);> 
>             assertNotNull(minLengthAnnotation, "MinLength annotation not found");> 
>             assertEquals(> 
>                     minLength.intValue(), ((MinLength) minLengthAnnotation).value(), "MinLength value mismatch");> 
>         }> 
> > 
>         // const constraint> 
>         if (constValue != null) {> 
>             assertTrue(> 
>                     generatedCode.contains(> 
>                             "public static final String "> 
>                                     + paramName.toUpperCase()> 
>                                     + " = \""> 
>                                     + constValue> 
>                                     + "\";"));> 
>         }> 
> > 
>         // Regex pattern (using annotation value)> 
>         if (pattern != null) {> 
>             Annotation patternAnnotation = paramField.getAnnotation(Pattern.class);> 
>             assertNotNull(patternAnnotation, "Pattern annotation not found.");> 
>             assertEquals(pattern, ((Pattern) patternAnnotation).regexp(), "Pattern regexp() value mismatch.");> 
>         }> 
> > 
>         // Test constraint violations by *attempting* to set bad values.> 
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();> 
> > 
>         // Test maxLength violation> 
>         if (maxLength != null) {> 
>             String longString = "a".repeat(maxLength + 1);> 
>             assertThrows(> 
>                     ConstraintViolationException.class,> 
>                     () -> {> 
>                         paramField.setAccessible(true); // Make it accessible.> 
>                         paramField.set(paramInstance, longString); // Set the parameter, throw if invalid.> 
>                     });> 
>         }> 
> > 
>         // Test minLength violation> 
>         if (minLength != null) {> 
>             String shortString = "a".repeat(minLength - 1);> 
>             assertThrows(> 
>                     ConstraintViolationException.class,> 
>                     () -> {> 
>                         paramField.setAccessible(true); // Make it accessible.> 
>                         paramField.set(paramInstance, shortString); // Set the parameter, throw if invalid.> 
>                     });> 
>         }> 
> > 
>         // Test const violation (we set to the valid, and then an invalid value)> 
> > 
>         if (constValue != null) {> 
>             String validValue = constValue;> 
>             paramField.setAccessible(true); // Make field accessible.> 
>             paramField.set(paramInstance, validValue); // Set GOOD.> 
>             String invalidValue = validValue + "_INVALID";> 
> > 
>             assertThrows(> 
>                     ConstraintViolationException.class,> 
>                     () -> {> 
>                         paramField.setAccessible(true); // Make it accessible.> 
>                         paramField.set(paramInstance, invalidValue); // Try set invalid value.> 
>                     });> 
>         }> 
>         // Test pattern violation> 
>         if (pattern != null) {> 
>             // Try setting invalid input.> 
>             assertThrows(> 
>                     ConstraintViolationException.class,> 
>                     () -> {> 
>                         paramField.setAccessible(true); // Make it accessible.> 
>                         paramField.set(paramInstance, "123"); // Try set invalid numerical value.> 
>                     });> 
>         }> 
>     }> 
> > 
>     // Data Providers (Continued)> 
> > 
>     // Parameterized Test for Ref Union Params: Now provides Lexicons, Method Name,> 
>     // and expected Parameter Type.> 
>     private static Stream<Arguments> provideLexiconsForRefUnionParams() {> 
>         return Stream.of(> 
>                 Arguments.of(> 
>                         TestUtils.createLexiconWithRefUnionParams(),> 
>                         "refUnionParams",> 
>                         "java.lang.Object") // Object> 
>         // for> 
>         // now,> 
>         // may> 
>         // be> 
>         // refined> 
>         );> 
>     }> 
> > 
>     // Added Invalid Lex Version Test> 
>     @ParameterizedTest> 
>     @MethodSource("provideLexiconsForInvalidLexVersions")> 
>     public void testInvalidLexiconVersion(> 
>             LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {> 
>         ClientGenerator generator = new ClientGenerator();> 
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc)); // Expect an exception> 
>     }> 
> > 
>     private static Stream<Arguments> provideLexiconsForInvalidLexVersions() {> 
>         List<LexDefinition> defs = new ArrayList<>();> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),> 
>                 Optional.of(output), new ArrayList<>()); // Added description> 
>         defs.add(new LexDefinition("main", "query", query));> 
> > 
>         return Stream.of(> 
>                 // lex value of 0 is invalid> 
>                 Arguments.of(new LexiconDoc(0, "com.example.invalidVersion", Optional.of(0), Optional.empty(),> 
>                         defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                 java.util.function.Function.identity()))),> 
>                         IllegalArgumentException.class) // Invalid Version> 
> > 
>         );> 
>     }> 
> > 
>     // Added Valid Lex Version test> 
>     @ParameterizedTest> 
>     @MethodSource("provideLexiconsForValidLexVersions")> 
>     public void testValidLexiconVersion(LexiconDoc lexiconDoc) throws Exception {> 
>         // Valid Lex Version> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // --- Compilation and Reflection ---> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         // Inject mockXrpcClient> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
>     }> 
> > 
>     private static Stream<Arguments> provideLexiconsForValidLexVersions() {> 
>         List<LexDefinition> defs = new ArrayList<>();> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>         LexXrpcQuery query = new LexXrpcQuery(> 
>                 Optional.empty(),> 
>                 Optional.of("This is a test query."),> 
>                 Optional.empty(),> 
>                 Optional.of(output),> 
>                 new ArrayList<>()); // Added description> 
>         defs.add(new LexDefinition("main", "query", query));> 
> > 
>         return Stream.of(> 
>                 // lex value of 1> 
>                 Arguments.of(> 
>                         new LexiconDoc(> 
>                                 1,> 
>                                 "com.example.validversion",> 
>                                 Optional.of(0),> 
>                                 Optional.empty(),> 
>                                 defs.stream()> 
>                                         .collect(> 
>                                                 java.util.stream.Collectors.toMap(> 
>                                                         LexDefinition::getId,> 
>                                                         java.util.function.Function.identity())))));> 
>     }> 
> > 
>     private static Stream<Arguments> provideLexiconsForAllParameterTypes() {> 
>         List<Arguments> argList = new ArrayList<>();> 
> > 
>         // Integer types> 
>         Map<String, LexPrimitive> intParams = new HashMap<>();> 
>         intParams.put("intParam",> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.intParams", intParams), "intParam",> 
>                 "Integer"));> 
> > 
>         // Number types (float/double) part of LexNumber> 
>         Map<String, LexPrimitive> numberParams = new HashMap<>();> 
>         numberParams.put("floatParam",> 
>                 new LexNumber(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.floatParams", numberParams),> 
>                 "floatParam", "Float")); // Double, double> 
> > 
>         // String types> 
>         Map<String, LexPrimitive> stringParams = new HashMap<>();> 
>         stringParams.put("stringParam", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                 Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.stringParams", stringParams),> 
>                 "stringParam", "String"));> 
> > 
>         // Boolean types> 
>         Map<String, LexPrimitive> boolParams = new HashMap<>();> 
>         boolParams.put("boolParam", new LexBoolean(Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.boolParams", boolParams), "boolParam",> 
>                 "Boolean"));> 
> > 
>         // Bytes type> 
>         Map<String, LexPrimitive> bytesParams = new HashMap<>();> 
>         bytesParams.put("bytesParam",> 
>                 new LexBytes(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.bytesParams", bytesParams),> 
>                 "bytesParam", "byte[]"));> 
> > 
>         // CidLink> 
>         Map<String, LexPrimitive> cidLinkParams = new HashMap<>();> 
>         cidLinkParams.put("cidLinkParam", new LexCidLink(Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.cidLinkParams", cidLinkParams),> 
>                 "cidLinkParam", "com.atproto.common.Cid"));> 
> > 
>         // Array of primitives> 
>         Map<String, LexType> arrayParams = new HashMap<>();> 
>         arrayParams.put("intArrayParam", new LexArray(> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()),> 
>                 Optional.empty(), Optional.empty(), Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.arrayParams", arrayParams),> 
>                 "intArrayParam", "java.util.List<Integer>"));> 
> > 
>         // Unknown> 
>         Map<String, LexPrimitive> unknownParams = new HashMap<>();> 
>         unknownParams.put("unknownParam", new LexUnknown(Optional.empty()));> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.unknownParams", unknownParams),> 
>                 "unknownParam", "java.util.Map<String, Object>"));> 
> > 
>         // String Formats.> 
>         Map<String, LexPrimitive> stringFormatParams = new HashMap<>();> 
>         stringFormatParams.put("atUriParam", new LexString(Optional.of("at-uri"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("cidParam", new LexString(Optional.of("cid"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("didParam", new LexString(Optional.of("did"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("handleParam", new LexString(Optional.of("handle"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("nsidParam", new LexString(Optional.of("nsid"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("datetimeParam", new LexString(Optional.of("datetime"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("languageParam", new LexString(Optional.of("language"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("uriParam", new LexString(Optional.of("uri"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("uriRefParam", new LexString(Optional.of("uri-reference"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("uriTemplateParam", new LexString(Optional.of("uri-template"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("emailParam", new LexString(Optional.of("email"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("hostnameParam", new LexString(Optional.of("hostname"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("ipv4Param", new LexString(Optional.of("ipv4"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         stringFormatParams.put("ipv6Param", new LexString(Optional.of("ipv6"),> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "atUriParam", "com.atproto.syntax.AtUri"));> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "cidParam", "com.atproto.common.Cid")); // Assuming you have a Cid class.> 
> > 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "didParam", "com.atproto.syntax.Did")); // Assuming you have a Did class> 
> > 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "handleParam", "com.atproto.syntax.Handle")); // Assuming you have a Handle class> 
> > 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "nsidParam", "com.atproto.syntax.Nsid")); // Assuming you have an NSID class.> 
> > 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "datetimeParam", "java.time.Instant"));> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "languageParam", "java.util.Locale"));> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "uriParam", "java.net.URI"));> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "uriRefParam", "java.net.URI")); // Assuming URI for uri-reference> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "uriTemplateParam", "java.lang.String")); // Assuming String for uri-template (no built-in type)> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "emailParam", "java.lang.String")); // Assuming String for email> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "hostnameParam", "java.lang.String")); // Assuming String for hostname> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "ipv4Param", "java.net.InetAddress")); // Assuming InetAddress for IPv4> 
>         argList.add(> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),> 
>                         "ipv6Param", "java.net.InetAddress")); // Assuming InetAddress for IPv6> 
> > 
>         return argList.stream();> 
>     }> 
> > 
>     @ParameterizedTest> 
>     @MethodSource("provideLexiconsForNoOutput")> 
>     public void testNoOutputSchema(LexiconDoc lexiconDoc, String expectedReturnType) throws Exception {> 
>         ClientGenerator generator = new ClientGenerator();> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // --- Compilation and Reflection to check return type ---> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
>         // Inject mockXrpcClient> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // Find the method and its return type. This assumes the method name is "main"> 
>         java.lang.reflect.Method method = null;> 
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {> 
>             if (m.getName().equals("main")) { // Or whatever the method name is in your generated code> 
>                 method = m;> 
>                 break;> 
>             }> 
>         }> 
>         assertNotNull(method, "Method 'main' not found in generated class");> 
> > 
>         String actualReturnType = method.getGenericReturnType().getTypeName()> 
>                 .replace("java.util.concurrent.CompletableFuture", "AtpResponse"); // Simplify for testing> 
>         assertEquals(expectedReturnType, actualReturnType);> 
> > 
>         // Basic stub (no parameters in this case)> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))> 
>                 .thenReturn(new AtpResponse<>(null, Optional.empty()));> 
> > 
>     }> 
> > 
>     private static Stream<Arguments> provideLexiconsForNoOutput() {> 
>         return Stream.of(> 
>                 Arguments.of(TestUtils.createLexiconQueryNoOutput(), "AtpResponse<Void>"),> 
>                 Arguments.of(TestUtils.createLexiconProcedureNoOutput(), "AtpResponse<Void>")> 
> > 
>         );> 
>     }> 
> > 
>     // Parameterized test for invalid Lexicon structures> 
>     @ParameterizedTest> 
>     @MethodSource("provideInvalidLexicons")> 
>     public void testInvalidLexiconStructure(> 
>             LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {> 
>         ClientGenerator generator = new ClientGenerator();> 
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));> 
>     }> 
> > 
>     private static Stream<Arguments> provideInvalidLexicons() {> 
>         return Stream.of(> 
>                 Arguments.of(> 
>                         TestUtils.createLexiconWithoutDefs(),> 
>                         IllegalArgumentException.class), // Or a custom exception type> 
>                 Arguments.of(> 
>                         TestUtils.createLexiconWithInvalidIdFormat(),> 
>                         IllegalArgumentException.class), // Or a custom exception type> 
>                 Arguments.of(> 
>                         TestUtils.createLexiconWithConflictingDefinitions(),> 
>                         IllegalArgumentException.class), // Or a custom exception type.> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidArrayDefinition_Nested(),> 
>                         IllegalArgumentException.class),> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidArrayDefinition_MissingItems(),> 
>                         NullPointerException.class),> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidRefTarget(), IllegalArgumentException.class),> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidRefUnionTarget(), IllegalArgumentException.class),> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidStringFormat(), IllegalArgumentException.class),> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidType(), IllegalArgumentException.class));> 
>     }> 
> > 
> }
> ```
> 
> ```java
> // src/main/test/java/com/atproto/codegen/TestUtils.java
> //src/main/test/java/com/atproto/codegen/TestUtils.java> 
> > 
> package com.atproto.codegen;> 
> > 
> import com.atproto.lexicon.models.*;> 
> > 
> import javax.tools.*;> 
> import java.io.ByteArrayInputStream;> 
> import java.io.IOException;> 
> import java.io.InputStream;> 
> import java.io.OutputStream;> 
> import java.net.URI;> 
> import java.net.URISyntaxException;> 
> import java.nio.CharBuffer;> 
> import java.nio.charset.StandardCharsets;> 
> import java.util.*;> 
> import java.util.stream.Stream;> 
> > 
> import org.junit.jupiter.params.provider.Arguments;> 
> > 
> public class TestUtils {> 
>         // Existing methods (createSimpleQueryLexicon, etc.) remain unchanged...> 
>         public static LexiconDoc createSimpleQueryLexicon() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
>                 return new LexiconDoc(1, "com.example.simpleQuery", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createSimpleQueryLexiconWithDescription() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."),> 
>                                 Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>()); // Added description> 
>                 defs.add(new LexDefinition("main", "query", query));> 
>                 return new LexiconDoc(1, "com.example.simpleQueryWithDescription", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createQueryWithParamsLexicon() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexPrimitive> params = new HashMap<>();> 
>                 params.put("p_string",> 
>                                 new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                                 Optional.empty()));> 
>                 params.put("p_int",> 
>                                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
> > 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.paramsQuery", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createProcedureLexicon() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
> > 
>                 Map<String, LexPrimitive> properties = new HashMap<>();> 
>                 properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty()));> 
> > 
>                 LexXrpcBody input = new LexXrpcBody("application/json", Optional.of(new LexObject(> 
>                                 Optional.empty(), Optional.empty(), properties,> 
>                                 new ArrayList<>())), Optional.empty());> 
> > 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(),> 
>                                 Optional.empty());> 
> > 
>                 LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(input), Optional.empty(),> 
>                                 Optional.of(output),> 
>                                 new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "procedure", procedure));> 
> > 
>                 return new LexiconDoc(1, "com.example.procedure", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createSubscriptionLexicon() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
> > 
>                 Map<String, LexPrimitive> properties = new HashMap<>(); // Properties, for message> 
>                 properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty())); // Add string property> 
> > 
>                 LexXrpcSubscription subscription = new LexXrpcSubscription(Optional.empty(), Optional.empty()); // Declare> 
>                 // subscription> 
> > 
>                 defs.add(new LexDefinition("main", "subscription", subscription)); // Add to Definitions.> 
> > 
>                 return new LexiconDoc(1, "com.example.subscription", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createMultiMethodLexicon() { // Multiple Method Lexicon.> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
> > 
>                 // Query> 
>                 LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),> 
>                                 Optional.empty()); // Create Output> 
> > 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(outputQuery), new ArrayList<>()); // Create Query> 
>                 defs.add(new LexDefinition("queryMethod", "query", query)); // Add Definition> 
> > 
>                 // Procedure> 
>                 LexXrpcBody inputProcedure = new LexXrpcBody("application/json", Optional.empty(), Optional.empty()); // Create> 
>                 // input> 
>                 LexXrpcBody outputProcedure = new LexXrpcBody("application/json", Optional.empty(), Optional.empty()); // Create> 
>                 // output> 
> > 
>                 LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(inputProcedure), Optional.empty(),> 
>                                 Optional.of(outputProcedure), new ArrayList<>()); // Create Procedure> 
> > 
>                 defs.add(new LexDefinition("procedureMethod", "procedure", procedure)); // Add Definition> 
> > 
>                 return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity()))); // Convert Def List to Map> 
>         }> 
> > 
>         private static LexiconDoc createDuplicateMethodLexicon() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),> 
>                                 Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(outputQuery), new ArrayList<>());> 
>                 defs.add(new LexDefinition("queryMethod", "query", query));> 
>                 defs.add(new LexDefinition("queryMethod", "query", query)); // Duplicate> 
> > 
>                 return new LexiconDoc(1, "com.example.duplicateMethod", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createNestedObjectLexicon() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
> > 
>                 // Define the nested object type> 
>                 Map<String, LexPrimitive> nestedProperties = new HashMap<>();> 
>                 nestedProperties.put("innerString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty()));> 
>                 LexObject nestedObject = new LexObject(Optional.empty(), Optional.empty(), nestedProperties,> 
>                                 new ArrayList<>());> 
> > 
>                 // Main query with an object containing the nested object> 
>                 Map<String, LexType> properties = new HashMap<>();> 
>                 properties.put("outerObject", nestedObject);> 
> > 
>                 LexXrpcBody output = new LexXrpcBody("application/json",> 
>                                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), properties,> 
>                                                 new ArrayList<>())),> 
>                                 Optional.empty());> 
> > 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output),> 
>                                 new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.nestedObject", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithParams(String id, Map<String, ? extends LexType> params) {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
>                 return new LexiconDoc(1, id, Optional.of(0), Optional.empty(), defs.stream().collect(> 
>                                 java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithRefUnionParams() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
> > 
>                 // Define the referenced types> 
>                 Map<String, LexPrimitive> recordDef1Props = new HashMap<>();> 
>                 recordDef1Props.put("name1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty()));> 
>                 LexRecord recordDef1 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef1Props,> 
>                                                 new ArrayList<>())),> 
>                                 Optional.empty());> 
> > 
>                 Map<String, LexPrimitive> recordDef2Props = new HashMap<>();> 
>                 recordDef2Props.put("name2",> 
>                                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 LexRecord recordDef2 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef2Props,> 
>                                                 new ArrayList<>())),> 
>                                 Optional.empty());> 
> > 
>                 defs.add(new LexDefinition("recordDef1", "record", recordDef1));> 
>                 defs.add(new LexDefinition("recordDef2", "record", recordDef2));> 
> > 
>                 // Main query with a ref-union parameter> 
>                 Map<String, LexType> params = new HashMap<>();> 
>                 List<String> refs = List.of("#recordDef1", "#recordDef2");> 
>                 params.put("refUnionParam", new LexRefUnion(refs, Optional.empty()));> 
> > 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.refUnionParams", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithMultipleDefs() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
> > 
>                 LexXrpcBody output1 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query1 = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output1), new ArrayList<>());> 
>                 defs.add(new LexDefinition("query1", "query", query1));> 
> > 
>                 Map<String, LexPrimitive> params2 = new HashMap<>();> 
>                 params2.put("param1",> 
>                                 new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                                 Optional.empty()));> 
>                 LexXrpcParameters xrpcParams2 = new LexObject(Optional.of("params"), Optional.empty(), params2,> 
>                                 new ArrayList<>());> 
> > 
>                 LexXrpcBody output2 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query2 = new LexXrpcQuery(Optional.of(xrpcParams2), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output2), new ArrayList<>());> 
>                 defs.add(new LexDefinition("query2", "query", query2));> 
> > 
>                 Map<String, LexPrimitive> recordProperties = new HashMap<>();> 
>                 recordProperties.put("name", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty()));> 
>                 LexRecord recordDef = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordProperties,> 
>                                                 new ArrayList<>())),> 
>                                 Optional.empty());> 
>                 defs.add(new LexDefinition("record1", "record", recordDef));> 
> > 
>                 return new LexiconDoc(1, "com.example.multipleDefs", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithStringConstraints() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexPrimitive> params = new HashMap<>();> 
> > 
>                 // String with maxLength> 
>                 params.put("maxLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.of(10),> 
>                                 Optional.empty(), Optional.empty()));> 
> > 
>                 // String with minLength> 
>                 params.put("minLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(5), Optional.empty()));> 
> > 
>                 // String with const> 
>                 params.put("constString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.of(List.of("constantValue"))));> 
> > 
>                 // String with pattern> 
>                 params.put("patternString", new LexString(Optional.empty(), Optional.of("[a-zA-Z]+"), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty()));> 
>                 // String with enum> 
> > 
>                 List<String> enumValues = Arrays.asList("value1", "value2", "value3");> 
>                 params.put("enumString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.of(enumValues)));> 
> > 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.stringConstraints", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static Stream<Arguments> provideLexiconsForStringConstraints() {> 
>                 return Stream.of(> 
>                                 Arguments.of(createLexiconWithStringConstraints(), "maxLengthString", "String", 10,> 
>                                                 null, null,> 
>                                                 null), // maxLength> 
>                                 Arguments.of(createLexiconWithStringConstraints(), "minLengthString", "String", null, 5,> 
>                                                 null,> 
>                                                 null), // minLength> 
>                                 Arguments.of(createLexiconWithStringConstraints(), "constString", "String", null, null,> 
>                                                 "constantValue",> 
>                                                 null), // const value> 
>                                 Arguments.of(createLexiconWithStringConstraints(), "patternString", "String", null,> 
>                                                 null, null,> 
>                                                 "[a-zA-Z]+") // Regex pattern> 
>                 // Arguments.of(createLexiconWithStringConstraints(), "enumString", "String",> 
>                 // null, null, null,enumValues)> 
>                 );> 
>         }> 
> > 
>         public static LexiconDoc createLexiconQueryNoOutput() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
>                 return new LexiconDoc(1, "com.example.NoOutputQuery", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
> > 
>         }> 
> > 
>         public static LexiconDoc createLexiconProcedureNoOutput() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcProcedure proc = new LexXrpcProcedure(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "procedure", proc));> 
>                 return new LexiconDoc(1, "com.example.NoOutputProcedure", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
> > 
>         }> 
>         // ---------- INVALID LEXICON CREATION METHODS ----------> 
> > 
>         public static LexiconDoc createLexiconWithoutDefs() {> 
>                 // Create a LexiconDoc without 'defs'. This is invalid.> 
>                 return new LexiconDoc(1, "com.example.invalid.nodefs", Optional.of(0), Optional.empty(), Map.of());> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidIdFormat() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 // Invalid ID format (missing parts)> 
>                 return new LexiconDoc(1, "invalid-id", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithConflictingDefinitions() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 // Add the *same* definition twice (same ID).> 
>                 defs.add(new LexDefinition("main", "query", query));> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.conflictingdefs", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId, // This> 
>                                                                                                               // will> 
>                                                                                                               // NOW> 
>                                                                                                               // fail!!!!> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidArrayDefinition_Nested() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexType> params = new HashMap<>();> 
>                 // Nested array of arrays (invalid). Lexicon only supports top-level arrays.> 
>                 params.put("nestedArray", new LexArray(> 
>                                 new LexArray(new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                                 Optional.empty()),> 
>                                                 Optional.empty(), Optional.empty(), Optional.empty()),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.invalidarray.nested", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidArrayDefinition_MissingItems() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexType> params = new HashMap<>();> 
> > 
>                 // Create an invalid LexArray - items are required (should not allow an empty> 
>                 // Optional)> 
>                 LexArray invalidArray = mock(LexArray.class);> 
>                 when(invalidArray.getItems()).thenThrow(new NullPointerException("Items cannot be null")); // Simulate> 
>                                                                                                            // missing> 
>                                                                                                            // field.> 
>                 when(invalidArray.getType()).thenReturn("array");> 
> > 
>                 params.put("invalidArray", invalidArray);> 
> > 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
>                 return new LexiconDoc(1, "com.example.invalidarray.missingitems", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidRefTarget() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexType> params = new HashMap<>();> 
>                 // Ref to a non-existent definition> 
>                 params.put("invalidRef", new LexRef("#missing", Optional.empty()));> 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.invalidref", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidRefUnionTarget() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexType> params = new HashMap<>();> 
>                 // RefUnion with a reference to a non-existent type.> 
>                 params.put("invalidRefUnion", new LexRefUnion(List.of("#missingType"), Optional.empty()));> 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.invalidrefunion", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidStringFormat() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexPrimitive> params = new HashMap<>();> 
>                 // String with an invalid format> 
>                 params.put("invalidFormatString", new LexString(Optional.of("invalid-format"), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return new LexiconDoc(1, "com.example.invalidstringformat", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         // Utility to create a LexiconDoc from a raw (potentially invalid) Map.> 
>         public static LexiconDoc createLexiconFromRawMap(Map<String, Object> rawLexicon) {> 
>                 return LexiconDoc.fromJson(rawLexicon);> 
>         }> 
> > 
>         public static InputStream stringToInputStream(String str) {> 
>                 return new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8));> 
>         }> 
> > 
>         public static class InMemoryCompiler {> 
>                 private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();> 
> > 
>                 public static Class<?> compile(String className, String sourceCode)> 
>                                 throws URISyntaxException, ClassNotFoundException {> 
>                         // Use try-with-resources to ensure closure> 
>                         try (JavaFileManager fileManager = new ClassFileManager(> 
>                                         compiler.getStandardFileManager(null, null, null))) {> 
> > 
>                                 List<JavaFileObject> compilationUnits = new ArrayList<>();> 
>                                 compilationUnits.add(new SourceFileObject(className, sourceCode));> 
> > 
>                                 // Create a compilation task> 
>                                 JavaCompiler.CompilationTask task = compiler.getTask(> 
>                                                 null, // No writer, write to memory.> 
>                                                 fileManager,> 
>                                                 null, // No diagnostics listener> 
>                                                 null, // No options> 
>                                                 null, // No classes to be processed (for annotation processing)> 
>                                                 compilationUnits);> 
> > 
>                                 // Perform the compilation> 
>                                 boolean success = task.call();> 
> > 
>                                 if (!success) {> 
>                                         // For proper error reporting, we need to collect the diagnostics.> 
>                                         DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();> 
>                                         JavaFileManager fileManager2 = new ClassFileManager(> 
>                                                         compiler.getStandardFileManager(diagnostics, null, null));> 
>                                         compiler.getTask(> 
>                                                         null, // No writer, write to memory.> 
>                                                         fileManager2,> 
>                                                         diagnostics,> 
>                                                         null, // No options> 
>                                                         null, // No classes to be processed> 
>                                                         compilationUnits).call(); // Don't check success; we want to see> 
>                                                                                   // the diagnostics in either case.> 
> > 
>                                         StringBuilder errorMsg = new StringBuilder();> 
>                                         errorMsg.append("Compilation failed:\n");> 
>                                         for (Diagnostic<? extends JavaFileObject> diagnostic : diagnostics> 
>                                                         .getDiagnostics()) {> 
>                                                 errorMsg.append(diagnostic.toString()).append("\n");> 
> > 
>                                         }> 
>                                         throw new RuntimeException(errorMsg.toString());> 
>                                 }> 
> > 
>                                 // Load the compiled class> 
>                                 return fileManager.getClassLoader(null).loadClass(className);> 
>                         } catch (IOException e) {> 
>                                 throw new RuntimeException("IOException during in-memory compilation", e);> 
>                         }> 
>                 }> 
> > 
>                 private static class SourceFileObject extends SimpleJavaFileObject {> 
>                         private final String sourceCode;> 
> > 
>                         SourceFileObject(String name, String sourceCode) throws URISyntaxException {> 
>                                 super(new URI("string:///" + name.replace('.', '/') + Kind.SOURCE.extension),> 
>                                                 Kind.SOURCE);> 
>                                 this.sourceCode = sourceCode;> 
>                         }> 
> > 
>                         @Override> 
>                         public CharSequence getCharContent(boolean ignoreEncodingErrors) {> 
>                                 return CharBuffer.wrap(sourceCode);> 
>                         }> 
>                 }> 
> > 
>                 private static class ClassFileObject extends SimpleJavaFileObject {> 
>                         private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();> 
> > 
>                         ClassFileObject(String name, Kind kind) throws URISyntaxException {> 
>                                 super(new URI("byte:///" + name.replace('.', '/') + kind.extension), kind);> 
>                         }> 
> > 
>                         byte[] getBytes() {> 
>                                 return outputStream.toByteArray();> 
>                         }> 
> > 
>                         @Override> 
>                         public OutputStream openOutputStream() {> 
>                                 return outputStream;> 
>                         }> 
>                 }> 
> > 
>                 private static class ClassFileManager extends ForwardingJavaFileManager<JavaFileManager> {> 
>                         private final Map<String, ClassFileObject> compiledClasses = new HashMap<>();> 
> > 
>                         ClassFileManager(JavaFileManager fileManager) {> 
>                                 super(fileManager);> 
>                         }> 
> > 
>                         @Override> 
>                         public ClassLoader getClassLoader(Location location) {> 
>                                 return new ClassLoader() {> 
>                                         @Override> 
>                                         protected Class<?> findClass(String name) throws ClassNotFoundException {> 
>                                                 ClassFileObject classFile = compiledClasses.get(name);> 
>                                                 if (classFile == null) {> 
>                                                         throw new ClassNotFoundException(name);> 
>                                                 }> 
>                                                 byte[] bytes = classFile.getBytes();> 
>                                                 return defineClass(name, bytes, 0, bytes.length);> 
>                                         }> 
>                                 };> 
>                         }> 
> > 
>                         @Override> 
>                         public JavaFileObject getJavaFileForOutput(Location location, String className,> 
>                                         JavaFileObject.Kind kind,> 
>                                         FileObject sibling) throws IOException {> 
>                                 try {> 
>                                         ClassFileObject fileObject = new ClassFileObject(className, kind);> 
>                                         compiledClasses.put(className, fileObject); // Store the compiled class> 
> > 
>                                         return fileObject;> 
>                                 } catch (URISyntaxException ex) {> 
>                                         throw new RuntimeException(ex);> 
>                                 }> 
>                         }> 
>                 }> 
>         }> 
> > 
>         public static LexiconDoc createLexiconWithInvalidType() {> 
>                 // Create a LexiconDoc with an invalid parameter type within a query.> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 Map<String, LexPrimitive> params = new HashMap<>();> 
>                 // Add an invalid type.> 
>                 params.put("invalidParam", new LexString(Optional.of("invalidtype"), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty())); // invalid type> 
>                 LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,> 
>                                 new ArrayList<>());> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
> > 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>());> 
>                 defs.add(new LexDefinition("main", "query", query)); //> 
> > 
>                 return new LexiconDoc(1, "com.example.invalidType", Optional.of(0), Optional.empty(),> 
>                                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                 java.util.function.Function.identity())));> 
>         }> 
> > 
>         private static Stream<Arguments> provideLexiconsForInvalidLexVersions() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."),> 
>                                 Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>()); // Added description> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return Stream.of(> 
>                                 // lex value of 0 is invalid> 
>                                 Arguments.of(new LexiconDoc(0, "com.example.invalidVersion", Optional.of(0),> 
>                                                 Optional.empty(),> 
>                                                 defs.stream().collect(> 
>                                                                 java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                                                                                 java.util.function.Function> 
>                                                                                                 .identity()))),> 
>                                                 IllegalArgumentException.class) // Invalid Version> 
> > 
>                 );> 
>         }> 
> > 
>         // Added Valid Lex Version test> 
> > 
>         private static Stream<Arguments> provideLexiconsForValidLexVersions() {> 
>                 List<LexDefinition> defs = new ArrayList<>();> 
>                 LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>                 LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."),> 
>                                 Optional.empty(),> 
>                                 Optional.of(output), new ArrayList<>()); // Added description> 
>                 defs.add(new LexDefinition("main", "query", query));> 
> > 
>                 return Stream.of(> 
>                                 // lex value of 1> 
>                                 Arguments.of(new LexiconDoc(1, "com.example.validversion", Optional.of(0),> 
>                                                 Optional.empty(),> 
>                                                 defs.stream().collect(java.util.stream.Collectors.toMap(> 
>                                                                 LexDefinition::getId,> 
>                                                                 java.util.function.Function.identity()))))> 
> > 
>                 );> 
>         }> 
> > 
>         private static Stream<Arguments> provideLexiconsForAllParameterTypes() {> 
>                 List<Arguments> argList = new ArrayList<>();> 
> > 
>                 // Integer types> 
>                 Map<String, LexPrimitive> intParams = new HashMap<>();> 
>                 intParams.put("intParam",> 
>                                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.intParams", intParams),> 
>                                 "intParam",> 
>                                 "Integer"));> 
> > 
>                 // Number types (float/double) part of LexNumber> 
>                 Map<String, LexPrimitive> numberParams = new HashMap<>();> 
>                 numberParams.put("floatParam",> 
>                                 new LexNumber(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.floatParams", numberParams),> 
>                                 "floatParam", "Float")); // Double, double> 
> > 
>                 // String types> 
>                 Map<String, LexPrimitive> stringParams = new HashMap<>();> 
>                 stringParams.put("stringParam", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),> 
>                                 Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.stringParams", stringParams),> 
>                                 "stringParam", "String"));> 
> > 
>                 // Boolean types> 
>                 Map<String, LexPrimitive> boolParams = new HashMap<>();> 
>                 boolParams.put("boolParam", new LexBoolean(Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.boolParams", boolParams),> 
>                                 "boolParam",> 
>                                 "Boolean"));> 
> > 
>                 // Bytes type> 
>                 Map<String, LexPrimitive> bytesParams = new HashMap<>();> 
>                 bytesParams.put("bytesParam",> 
>                                 new LexBytes(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.bytesParams", bytesParams),> 
>                                 "bytesParam", "byte[]"));> 
> > 
>                 // CidLink> 
>                 Map<String, LexPrimitive> cidLinkParams = new HashMap<>();> 
>                 cidLinkParams.put("cidLinkParam", new LexCidLink(Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.cidLinkParams", cidLinkParams),> 
>                                 "cidLinkParam", "com.atproto.common.Cid"));> 
> > 
>                 // Array of primitives> 
>                 Map<String, LexType> arrayParams = new HashMap<>();> 
>                 arrayParams.put("intArrayParam", new LexArray(> 
>                                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.arrayParams", arrayParams),> 
>                                 "intArrayParam", "java.util.List<Integer>"));> 
> > 
>                 // Unknown> 
>                 Map<String, LexPrimitive> unknownParams = new HashMap<>();> 
>                 unknownParams.put("unknownParam", new LexUnknown(Optional.empty()));> 
>                 argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.unknownParams", unknownParams),> 
>                                 "unknownParam", "java.util.Map<String, Object>"));> 
> > 
>                 // String Formats.> 
>                 Map<String, LexPrimitive> stringFormatParams = new HashMap<>();> 
>                 stringFormatParams.put("atUriParam", new LexString(Optional.of("at-uri"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("cidParam", new LexString(Optional.of("cid"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("didParam", new LexString(Optional.of("did"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("handleParam", new LexString(Optional.of("handle"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("nsidParam", new LexString(Optional.of("nsid"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("datetimeParam", new LexString(Optional.of("datetime"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("languageParam", new LexString(Optional.of("language"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("uriParam", new LexString(Optional.of("uri"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("uriRefParam", new LexString(Optional.of("uri-reference"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("uriTemplateParam", new LexString(Optional.of("uri-template"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("emailParam", new LexString(Optional.of("email"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("hostnameParam", new LexString(Optional.of("hostname"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("ipv4Param", new LexString(Optional.of("ipv4"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 stringFormatParams.put("ipv6Param", new LexString(Optional.of("ipv6"),> 
>                                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "atUriParam", "com.atproto.syntax.AtUri"));> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "cidParam", "com.atproto.common.Cid")); // Assuming you have a Cid> 
>                                                                                         // class.> 
> > 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "didParam", "com.atproto.syntax.Did")); // Assuming you have a Did class> 
> > 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "handleParam", "com.atproto.syntax.Handle")); // Assuming you have a> 
>                                                                                               // Handle class> 
> > 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "nsidParam", "com.atproto.syntax.Nsid")); // Assuming you have an NSID> 
>                                                                                           // class.> 
> > 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "datetimeParam", "java.time.Instant"));> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "languageParam", "java.util.Locale"));> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "uriParam", "java.net.URI"));> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "uriRefParam", "java.net.URI")); // Assuming URI for uri-reference> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "uriTemplateParam", "java.lang.String")); // Assuming String for> 
>                                                                                           // uri-template (no built-in> 
>                                                                                           // type)> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "emailParam", "java.lang.String")); // Assuming String for email> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "hostnameParam", "java.lang.String")); // Assuming String for hostname> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "ipv4Param", "java.net.InetAddress")); // Assuming InetAddress for IPv4> 
>                 argList.add(> 
>                                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams",> 
>                                                 stringFormatParams),> 
>                                                 "ipv6Param", "java.net.InetAddress")); // Assuming InetAddress for IPv6> 
> > 
>                 return argList.stream();> 
>         }> 
> > 
>         private static Stream<Arguments> provideLexiconsForRefUnionParams() {> 
>                 return Stream.of(> 
>                                 Arguments.of(TestUtils.createLexiconWithRefUnionParams(), "refUnionParams",> 
>                                                 "java.lang.Object") // Object> 
>                                                                     // for> 
>                                                                     // now,> 
>                                                                     // may> 
>                                                                     // be> 
>                                                                     // refined> 
>                 );> 
>         }> 
> }> 
> 
> ```
> 
> ```java
> // src/main/java/com/atproto/codegen/InMemoryCompiler.java
> package com.atproto.codegen;> 
> > 
> import javax.tools.*;> 
> import java.net.URI;> 
> import java.util.*;> 
> > 
> import javax.tools.*;> 
> import java.io.ByteArrayOutputStream;> 
> import java.io.IOException;> 
> import java.io.OutputStream;> 
> import java.net.URI;> 
> import java.net.URISyntaxException;> 
> import java.nio.CharBuffer;> 
> import java.util.HashMap;> 
> import java.util.List;> 
> import java.util.Map;> 
> > 
> public class InMemoryCompiler {> 
> > 
>     private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();> 
> > 
>     public static Class<?> compile(String className, String sourceCode)> 
>             throws URISyntaxException, ClassNotFoundException {> 
>         JavaFileManager fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));> 
> > 
>         List<JavaFileObject> compilationUnits = List.of(> 
>                 new SourceFileObject(className, sourceCode));> 
> > 
>         // Create a compilation task> 
>         JavaCompiler.CompilationTask task = compiler.getTask(> 
>                 null, // No writer, write to memory.> 
>                 fileManager,> 
>                 null, // No diagnostics listener> 
>                 null, // No options> 
>                 null, // No classes to be processed (for annotation processing)> 
>                 compilationUnits);> 
> > 
>         // Perform the compilation> 
>         boolean success = task.call();> 
> > 
>         if (!success) {> 
>             throw new RuntimeException("Compilation failed");> 
>         }> 
> > 
>         // Load the compiled class> 
>         return fileManager.getClassLoader(null).loadClass(className);> 
>     }> 
> > 
>     private static class SourceFileObject extends SimpleJavaFileObject {> 
>         private final String sourceCode;> 
> > 
>         SourceFileObject(String name, String sourceCode) throws URISyntaxException {> 
>             super(new URI("string:///" + name.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);> 
>             this.sourceCode = sourceCode;> 
>         }> 
> > 
>         @Override> 
>         public CharSequence getCharContent(boolean ignoreEncodingErrors) {> 
>             return CharBuffer.wrap(sourceCode);> 
>         }> 
>     }> 
> > 
>     private static class ClassFileObject extends SimpleJavaFileObject {> 
>         private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();> 
> > 
>         ClassFileObject(String name, Kind kind) throws URISyntaxException {> 
>             super(new URI("byte:///" + name.replace('.', '/') + kind.extension), kind);> 
>         }> 
> > 
>         byte[] getBytes() {> 
>             return outputStream.toByteArray();> 
>         }> 
> > 
>         @Override> 
>         public OutputStream openOutputStream() {> 
>             return outputStream;> 
>         }> 
>     }> 
> > 
>     private static class ClassFileManager extends ForwardingJavaFileManager<JavaFileManager> {> 
>         private final Map<String, ClassFileObject> compiledClasses = new HashMap<>();> 
> > 
>         ClassFileManager(JavaFileManager fileManager) {> 
>             super(fileManager);> 
>         }> 
> > 
>         @Override> 
>         public ClassLoader getClassLoader(Location location) {> 
>             return new ClassLoader() {> 
>                 @Override> 
>                 protected Class<?> findClass(String name) throws ClassNotFoundException {> 
>                     ClassFileObject classFile = compiledClasses.get(name);> 
>                     if (classFile == null) {> 
>                         throw new ClassNotFoundException(name);> 
>                     }> 
>                     byte[] bytes = classFile.getBytes();> 
>                     return defineClass(name, bytes, 0, bytes.length);> 
>                 }> 
>             };> 
>         }> 
> > 
>         @Override> 
>         public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,> 
>                 FileObject sibling) throws IOException {> 
>             try {> 
>                 ClassFileObject fileObject = new ClassFileObject(className, kind);> 
>                 compiledClasses.put(className, fileObject); // Store the compiled class> 
> > 
>                 return fileObject;> 
>             } catch (URISyntaxException ex) {> 
>                 throw new RuntimeException(ex);> 
>             }> 
>         }> 
>     }> 
> }> 
> 
> ```
> 
> Git shows no current changes.
> 
> ```java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorMockingTest.java
> // src/test/java/com/atproto/codegen/ClientGeneratorMockingTest.java> 
> > 
> package com.atproto.codegen;> 
> > 
> import static org.junit.jupiter.api.Assertions.*;> 
> import static org.mockito.Mockito.*;> 
> > 
> import com.atproto.api.AtpResponse;> 
> import com.atproto.api.xrpc.XrpcClient;> 
> import com.atproto.api.xrpc.XrpcException;> 
> import com.atproto.lexicon.models.LexDefinition;> 
> import com.atproto.lexicon.models.LexXrpcBody;> 
> import com.atproto.lexicon.models.LexXrpcQuery;> 
> import com.atproto.lexicon.models.LexiconDoc;> 
> import java.io.IOException;> 
> import java.util.ArrayList;> 
> import java.util.List;> 
> import java.util.Map;> 
> import java.util.Optional;> 
> import java.util.concurrent.CompletableFuture;> 
> import org.junit.jupiter.api.BeforeEach;> 
> import org.junit.jupiter.api.Test;> 
> import org.junit.jupiter.api.extension.ExtendWith;> 
> import org.mockito.Mock;> 
> import org.mockito.junit.jupiter.MockitoExtension;> 
> > 
> @ExtendWith(MockitoExtension.class) // Use MockitoExtension for JUnit 5 integration> 
> public class ClientGeneratorMockingTest {> 
> > 
>     @Mock> 
>     private XrpcClient mockXrpcClient; // Mock the XrpcClient> 
> > 
>     private ClientGenerator generator;> 
> > 
>     @BeforeEach> 
>     public void setUp() {> 
>         generator = new ClientGenerator(); // Initialize in setup for each test> 
>     }> 
> > 
>     private LexiconDoc createSimpleQueryLexicon() {> 
>         // Helper method from ClientGeneratorTest - make sure it or a similar utility> 
>         // is accessible. For now, I'm assuming it's in a common test utility class.> 
>         // We can refactor this later if needed.> 
> > 
>         List<LexDefinition> defs = new ArrayList<>();> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),> 
>                 Optional.empty(), Optional.of(output), new ArrayList<>());> 
>         defs.add(new LexDefinition("main", "query", query));> 
> > 
>         return new LexiconDoc(> 
>                 1,> 
>                 "com.example.simpleQuery",> 
>                 Optional.of(0),> 
>                 Optional.empty(),> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                         java.util.function.Function.identity())));> 
>     }> 
> > 
>     private LexiconDoc createSimpleProcedureLexicon() {> 
>         List<LexDefinition> defs = new ArrayList<>();> 
> > 
>         // Define request body (if any)> 
>         Map<String, com.atproto.lexicon.models.LexPrimitive> properties = new java.util.HashMap<>();> 
>         properties.put("message", new com.atproto.lexicon.models.LexString(Optional.empty(), Optional.empty(),> 
>                 Optional.empty(), Optional.empty(), Optional.empty()));> 
> > 
>         com.atproto.lexicon.models.LexXrpcBody input = new com.atproto.lexicon.models.LexXrpcBody("application/json",> 
>                 Optional.of(new com.atproto.lexicon.models.LexObject(Optional.empty(), Optional.empty(), properties,> 
>                         new ArrayList<>())),> 
>                 Optional.empty());> 
> > 
>         // Define response body (if any).> 
>         com.atproto.lexicon.models.LexXrpcBody output = new com.atproto.lexicon.models.LexXrpcBody("application/json",> 
>                 Optional.empty(),> 
>                 Optional.empty());> 
> > 
>         com.atproto.lexicon.models.LexXrpcProcedure procedure = new com.atproto.lexicon.models.LexXrpcProcedure(> 
>                 Optional.of(input),> 
>                 Optional.empty(),> 
>                 Optional.of(output),> 
>                 new ArrayList<>());> 
> > 
>         defs.add(new LexDefinition("main", "procedure", procedure));> 
> > 
>         return new LexiconDoc(> 
>                 1,> 
>                 "com.example.simpleProcedure",> 
>                 Optional.of(0),> 
>                 Optional.empty(),> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,> 
>                         java.util.function.Function.identity())));> 
> > 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForSimpleQuery_Success() throws Exception {> 
>         LexiconDoc lexiconDoc = createSimpleQueryLexicon();> 
> > 
>         // Create a mock AtpResponse with expected data> 
>         AtpResponse<String> mockResponse = new AtpResponse<>(200, "{\"message\": \"success\"}", Map.of());// Use a map> 
> > 
>         // Stub the sendQuery method to return the mock response> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any()))> 
>                 .thenReturn(CompletableFuture.completedFuture(mockResponse));> 
> > 
>         // Generate the client code> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // --- Compilation and Reflection (Important) ---> 
>         // 1. Compile the generated code. This is the CRUCIAL step> 
>         Class<?> generatedClientClass = InMemoryCompiler.compile("com.example.SimpleQueryClient", generatedCode);> 
> > 
>         // 2. Create an instance of the generated client.> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         // 3. Inject the mockXrpcClient into the generated client instance.> 
>         // This is where we replace the *real* XrpcClient with our *mock*.> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true); // Allow access to the private field> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // 4. Invoke the generated method (using reflection).> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery"); // Get the method.> 
>         Object result = method.invoke(clientInstance); // Invoke the method.> 
> > 
>         // --- Assertions ---> 
>         // Verify that sendQuery was called *exactly once* with the expected arguments.> 
>         verify(mockXrpcClient, times(1)).sendQuery(eq("com.example.simpleQuery"), eq(Optional.empty()),> 
>                 eq(Optional.empty()));> 
> > 
>         // Assert on the result from calling client's method (using the mocked repsonse)> 
>         assertInstanceOf(AtpResponse.class, result); // The result is of type AtpResponse of Map.> 
>         AtpResponse<?> atpResponse = (AtpResponse<?>) result; // Cast to AtpResponse> 
> > 
>         assertEquals(200, atpResponse.getStatusCode());> 
>         assertEquals("{\"message\": \"success\"}", atpResponse.getResponse()); // Check for mocked return.> 
> > 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForSimpleQuery_Error() throws Exception { // Test XRPC error cases> 
>         LexiconDoc lexiconDoc = createSimpleQueryLexicon();> 
> > 
>         // Stub the sendQuery method to throw an XRPCException.> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any()))> 
>                 .thenReturn(CompletableFuture.failedFuture(new XRPCException(400, "Bad Request", Optional.empty()))); // Simulate> 
>                                                                                                                       // error.> 
> > 
>         // Generate the client code> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // --- Compilation and Reflection (Important) ---> 
> > 
>         Class<?> generatedClientClass = InMemoryCompiler.compile("com.example.SimpleQueryClient", generatedCode);> 
> > 
>         // 2. Create an instance of the generated client.> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         // 3. Inject the mockXrpcClient into the generated client instance.> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true);> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // 4. Invoke the generated method (using reflection).> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");> 
> > 
>         // --- Assertions ---> 
> > 
>         // Verify that sendQuery was called *exactly once* with the expected arguments.> 
>         // Use assertThrows to verify that the expected exception is thrown.> 
>         XRPCException thrown = assertThrows(> 
>                 XRPCException.class,> 
>                 () -> method.invoke(clientInstance),> 
>                 "Expected sendQuery to throw, but it didn't");> 
> > 
>         assertEquals(400, thrown.getStatusCode());> 
>         assertEquals("Bad Request", thrown.getMessage());> 
>     }> 
> > 
>     @Test> 
>     public void testGenerateClientForSimpleProcedure_Success() throws Exception {> 
>         LexiconDoc lexiconDoc = createSimpleProcedureLexicon();> 
> > 
>         // Create a mock AtpResponse with expected data> 
>         AtpResponse<String> mockResponse = new AtpResponse<>(200, "{\"message\": \"success\"}", Map.of());// Use a map> 
> > 
>         // Stub the sendQuery method to return the mock response> 
>         when(mockXrpcClient.sendProcedure(anyString(), any(), any(), any()))> 
>                 .thenReturn(CompletableFuture.completedFuture(mockResponse));> 
> > 
>         // Generate the client code> 
>         String generatedCode = generator.generateClient(lexiconDoc);> 
> > 
>         // --- Compilation and Reflection (Important) ---> 
>         // 1. Compile the generated code. This is the CRUCIAL step> 
>         Class<?> generatedClientClass = InMemoryCompiler.compile("com.example.SimpleProcedureClient", generatedCode);> 
> > 
>         // 2. Create an instance of the generated client.> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();> 
> > 
>         // 3. Inject the mockXrpcClient into the generated client instance.> 
>         // This is where we replace the *real* XrpcClient with our *mock*.> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");> 
>         xrpcClientField.setAccessible(true); // Allow access to the private field> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);> 
> > 
>         // 4. Invoke the generated method (using reflection).> 
>         // Since the generated code requires an input, prepare an input class and> 
>         // instantiate an object to provide.> 
> > 
>         Class<?> inputClass = Class.forName("com.example.SimpleProcedureProcedureInput");> 
>         Object input = inputClass.getDeclaredConstructor().newInstance();> 
> > 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleProcedure", inputClass); // Get the> 
>                                                                                                          // method> 
>                                                                                                          // signature> 
>         Object result = method.invoke(clientInstance, input); // Invoke the method.> 
> > 
>         // --- Assertions ---> 
>         // Verify that sendQuery was called *exactly once* with the expected arguments.> 
>         verify(mockXrpcClient, times(1)).sendProcedure(eq("com.example.simpleProcedure"), eq(Optional.empty()), any(),> 
>                 eq(Optional.empty()));> 
> > 
>         // Assert on the result from calling client's method (using the mocked repsonse)> 
>         assertInstanceOf(AtpResponse.class, result); // The result is of type AtpResponse of Map.> 
>         AtpResponse<?> atpResponse = (AtpResponse<?>) result; // Cast to AtpResponse> 
> > 
>         assertEquals(200, atpResponse.getStatusCode());> 
>         assertEquals("{\"message\": \"success\"}", atpResponse.getResponse()); // Check for mocked return.> 
> > 
>     }> 
> }> 
> 
> ```
> 
> URL: https://atproto.com/ URL: https://github.com/bluesky-social/atproto URL: https://github.com/bluesky-social/atproto/tree/main/packages/api URL: https://github.com/bluesky-social/indigo/tree/main URL: https://github.com/MarshalX/atproto URL: https://atproto.blue/en/latest/index.html Typescript NodeJS Go Python 
> Kotlin Docs URL: https://github.com/uakihir0/kbsky 
> Java 21 LTS Maven Documentation I want to build a Java implementation of Bluesky's ATProtocol. The goal is to build a package JAR file that anyone can use as a base to build a Java program from. I want to utilize the official Typescript imlementation as a reference to preferably port their code to Java, or to build my own version from.
> We're going to build out the Lexicon generator. It needs to be as complete as the Typescript implementation since that's the one that's absolutely confirmed working. But you also need to factor in the other versions - especially the Kotlin version (since Kotlin is a "dielect" of Java).
> Let's build it using a test-driven development model. We're working on the ClientGeneratorTest.java and TestUtils.java files right now.
> But I think I might be over-testing now with too many test cases. Double check the official Typescript repo and determine what tests they're doing. I want to match their test coverage exactly - no less, but no more either. 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/api/tests 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/crypto/tests
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/syntax/tests 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/lexicon 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/common/tests 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/oauth/oauth-provider 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/repo/tests 
> URL: https://github.com/bluesky-social/atproto/tree/main/packages/xrpc 
> ClientGeneratorTest.java TestUtils.java InMemoryCompiler.java Git Diff ClientGeneratorMockingTest.java 

#### _Assistant_

> Okay, let's analyze the provided TypeScript tests in the `bluesky-social/atproto` repository to guide our Java test coverage for the Lexicon client generator, focusing on aligning our efforts and avoiding unnecessary over-testing.  I'll break down the analysis by package and then synthesize a recommendation for our `ClientGeneratorTest.java`.
> 
> **Analysis of TypeScript Tests (bluesky-social/atproto)**
> 
> Here's a summary of the tests found in the provided URLs, with a focus on what they're testing and *how* (unit vs. integration, mocking, etc.):
> 
> *   **`packages/api/tests`**:
>     *   **`agent.test.ts`**: This seems to be the closest equivalent to our `ClientGeneratorTest`. It's testing the high-level `BskyAgent` (which is similar to what our generated client will be).  Crucially, it does a *lot* of mocking of the underlying `XrpcClient`. Key aspects tested:
>         *   Successful API calls (with mocked responses).
>         *   Error handling (simulating failed requests via mocking).
>         *   Session management (login, refresh).
>         *   Specific API method calls (getProfile, getTimeline, etc.) - verifies correct parameters and return types.
>         *   Blob uploads.
>         *   "Legacy" mode client functionality.
>         *   Rich Text (facets) processing.
>         *   Moderation preferences
>         *   Event emitter
>     *   **`e2e/`**:  These are clearly end-to-end tests, interacting with a real (or test environment) PDS.  We're not at this stage yet.
>     *   **`_util.ts`**: Utilities for the tests, not tests themselves.
>     *   **`richtext.test.ts`**: Focused specifically on RichText facet generation (links, mentions).
> 
> *   **`packages/crypto/tests`**:
>     *   **`cid.test.ts`**:  Testing CID creation and validation.
>     *   **`did-resolver.test.ts`**: Testing DID resolution (using mocks for external resolvers).
>     *   **`key-cache.test.ts`**: Testing a key cache implementation.
>     *   **`multibase.test.ts`**: Testing multibase encoding/decoding.
>     *   **`multicodec.test.ts`**: Testing multicodec encoding/decoding.
>     *   **`signing.test.ts`**: Testing signature creation and verification.
>     *   **`time.test.ts`**: Tests methods for getting the current time.
> 
> *   **`packages/syntax/tests`**:
>     *   **`at-identifier.test.ts`**: Testing parsing and validation of AT identifiers (Handles, DIDs).
>     *   **`at-uri.test.ts`**: Testing parsing and validation of AT URIs.
>     *   **`handle.test.ts`**: More handle-specific tests.
>     *   **`nsid.test.ts`**: Testing NSID parsing and validation.
>     *   **`record-key.test.ts`**: Testing record key validation.
>     *   **`tid.test.ts`**: Testing TID (Timestamp ID) generation and validation.
>     *   **`misc.test.ts`**: Testing invalid character checks.
> 
> *   **`packages/lexicon`**:  This directory contains code, but very few tests.  The core Lexicon validation is likely happening within the `api` tests.  This is important! It implies that the `atproto/api` tests are doing the *de facto* Lexicon validation.  The lexicon schema is in this directory.
> 
> *  **`packages/common/tests`**:
>     * **`async-dedupe.test.ts`**: Tests for a deduplication utility.
>     * **`cid.test.ts`**: Seems duplicated.
>     * **`event-emitter.test.ts`**: Tests of an event emitter.
>     * **`stream.test.ts`**: Tests of async streams
> 
> *  **`packages/oauth/oauth-provider`**: This is a specific set of components, and not relevant now.
> 
> * **`packages/repo/tests`**:
>     * **`basic.test.ts`**: Most likely very low-level tests of the MST and repo operations.
>     * **`integrity.test.ts`**: Testing the integrity checks of the repo.
>     * **`mst.test.ts`**: MST-specific tests.
>     * **`strong-ref.test.ts`**: Strong-ref specific.
> 
> *   **`packages/xrpc/tests`**:
>     *   **`client.test.ts`**:  Fundamental unit tests of the `XrpcClient` itself.  Very important, but lower-level than what our current `ClientGeneratorTest` aims to do.  It tests things like:
>         *   HTTP method selection (GET vs. POST).
>         *   Header handling.
>         *   Query parameter serialization.
>         *   Body serialization (JSON, CBOR).
>         *   Error handling (various HTTP status codes).
>         *   Timeout handling.
>         *   Custom fetch handler.
>     *   **`server.test.ts`**: Tests for the XRPC *server* implementation.
>     *   **`subscription.test.ts`**: Tests for XRPC subscriptions (WebSockets).
> 
> **Synthesis and Recommendations for `ClientGeneratorTest.java`**
> 
> Based on the above, here's how we should focus our Java testing:
> 
> 1.  **Prioritize Mocking `XrpcClient`**: The TypeScript tests in `packages/api/tests/agent.test.ts` heavily rely on mocking the `XrpcClient`. Our `ClientGeneratorMockingTest.java` is correctly doing this. This is the most important testing strategy. We should expand this to cover:
>     *   **Successful calls**: Mock `sendQuery` and `sendProcedure` to return successful `AtpResponse` objects. Verify the generated client correctly handles the response.
>     *   **Error calls**: Mock `sendQuery` and `sendProcedure` to throw `XRPCException` (and potentially other exceptions). Verify the generated client correctly propagates these exceptions. This is covered well in the provided tests.
>     *   **Parameter serialization**:  For methods with parameters, verify that the parameters are correctly serialized and passed to the mocked `sendQuery` or `sendProcedure` methods.
>     *   **Input/Output Validation**: The `agent.test.ts` file doesn't seem to directly test schema validation failures (e.g., passing an invalid object). The atproto repo likely relies on TypeScript's type system. Since Java is statically typed, much of this validation will be handled by the compilation process. Our `ClientGeneratorTest` has good coverage of validation.
> 
> 2.  **Test Different Lexicon Structures**: Our existing `ClientGeneratorTest.java` is doing a good job of testing various Lexicon structures (queries, procedures, parameters of different types, nested objects, ref unions, string constraints, etc.). This is essential, as it ensures our code generator correctly handles the full range of Lexicon possibilities. We should ensure we cover:
>     *   Queries (with and without parameters).
>     *   Procedures (with and without input/output).
>     *   All primitive Lexicon types (string, number, integer, boolean, bytes, CID link).
>     *   Arrays (of primitives and references).
>     *   Objects (including nested objects).
>     *   References (`$ref`) and RefUnions.
>     *   String constraints (maxLength, minLength, const, pattern, known formats like "did", "handle", "at-uri").
>     *   Subscriptions (though the current implementation just throws `UnsupportedOperationException`, we should have a basic test).
>     *   Lexicon documents with multiple definitions.
> 
> 3.  **Do Not Duplicate `XrpcClient` Unit Tests**: The `packages/xrpc/tests/client.test.ts` file contains very thorough unit tests for the `XrpcClient` itself.  We *should not* try to replicate these in `ClientGeneratorTest`.  We are testing the *generated client*, which uses the `XrpcClient`. We assume the `XrpcClient` itself is already well-tested (either in its own test suite if we write one, or by relying on an existing, well-tested HTTP client library).
> 
> 4.  **Focus on Code Generation Logic**: Our tests should ensure the *correct Java code is generated* for a given Lexicon. The reflection-based tests in `ClientGeneratorTest.java` are good for this, as they check:
>     *   Correct class and method names.
>     *   Correct parameter types and names.
>     *   Correct return types.
>     *   Presence of expected annotations (e.g., `@NotNull`, `@MaxLength`).
>     *   That the necessary imports exist.
> 
> 5.   **Integration Tests Later**: We don't need end-to-end tests (like those in `packages/api/tests/e2e/`) at this stage. We will need, *eventually*, integration tests that verify the generated clients work against a real or test PDS, but those are separate from the unit tests of the code generator.
> 
> 6. **Javadoc generation**: Verify Javadocs.
> 
> **In summary, we should prioritize expanding `ClientGeneratorMockingTest` to cover more success/error scenarios with the mocked `XrpcClient`. We should maintain the thorough coverage of different Lexicon structures in `ClientGeneratorTest`. We *don't* need to duplicate the low-level `XrpcClient` tests. Our current approach of compiling the generated code and using reflection to verify its structure is a good one.**
> 

#### _User_

> /share 