### [Continue](https://continue.dev) session transcript
 Exported: 3/24/2025, 10:55:44 PM

#### _Assistant_

> Always include the language and file name in the info string when you write code blocks, for example '```python file.py'.

#### _User_

> indigo: golang code for Bluesky's atproto services 
>  Some Bluesky software is developed in Typescript, and lives in the bluesky-social/atproto repository. Some is developed in Go, and lives here. 
>  
>  Everything in this repository is an work in progress. Features and "Lexicons" may be removed or updated, software interfaces broken, etc. 
>  We are developing in the open, but not ready to accept or review significant contributions. Keep checking back! 
>  
>  What is atproto? 
>  not to be confused with the AT command set or Adenosine triphosphate 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBLLC . Learn more at: 
>  
>  Protocol Documentation 
>  Overview Guide 👈 Good place to start 
>  Blogpost on self-authenticating data structures 
>  
>  Development 
>  First, you will need the Go toolchain installed. We develop using the latest stable version of the language. 
>  The Makefile provides wrapper commands for basic development: 
>  make build
> make test
> make fmt
> make lint
>  
>  Individual commands can be run like:
> 
> dholms 
> changed the title
>  
>  
>  
>  dholms 
> marked this pull request as ready for review
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Choose a reason for hiding this comment 
>  
> The reason will be displayed to describe this comment to others. Learn more .
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Choose a reason for hiding this comment 
>  
> The reason will be displayed to describe this comment to others. Learn more .
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * refactor pds tests to use dev env
> * refactor bsky tests
> * fix pds test
> * tidy bsky tests 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * switch takedown ids back to ints, consistent with live pds
> * tidy/fix migration
> * update migration for sqlite 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  edavis 
> added a commit
> to edavis/pds
> that referenced
> this pull request
>  
>  
>  
>  
>  
>  
>  
>  
>  mloar 
> pushed a commit
> to mloar/atproto
> that referenced
> this pull request
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * rm tables
> * rm event-stream &amp; proxied
> * Remove appview services, move label service to pds
> * only proxy appview stuff
> * delete more tables
> * Start removing message dispatched from pds
> * more syncing-up removal of message dispatcher in pds
> * merged
> * remove feedgens from pds, remove getPopular
> * remove unused image helper from pds
> * fixing compiler errors
> * clean up sharp
> * rm label service
> * first pass on cleaning up tests
> * fix up a bunch of tests
> * moderation view tests
> * last admin tests
> * got a lil overzealous in deletes
> * clean up unused cfg
> * clean up label table
> * simplify admin repo search query/logic
> * tidy pds entrypoint
> * in-progress pds config changes
> * cfg fiddling
> * finish cleaning up cfg/ctx
> * comments
> * building
> * pds prefix on env
> * test env
> * collapse pds migrations down into a single migration
> * fix up dev-env
> * tidy
> * cleanup
> * fix pds admin tests
> * fix handle test
> * fix pds proxy tests
> * fix subscribe repos test
> * fix sqlite config in pds tests
> * add sqlite clause in sequencer-leader
> * fix actor search w/ sqlite on pds
> * fixes
> * fix dev env build
> * update pds service entrypoint
> * simple env example
> * make takedown ids opaque identifiers in the pds
> * use pds routes for api tests
> * update pds dockerfile with volume and correct port env var
> * add a couple env vars to example
> * add comments to env example
> * @atproto/pds 0.2.0-beta.0
> * @atproto/aws 0.0.1-beta.0
> * appview did
> * @atproto/aws 0.0.1
> * enable logs by default
> * update env example
> * bugfixing sandbox issues
> * consistency in pds env var name for appview url
> * log on pds start and stop, configure version at runtime
> * @atproto/pds 0.2.0-beta.1
> * fix semver matching for pds beta version
> * v0.2.0-beta.2
> * default invites to being not required
> * fix flaky test
> * limit db connections in tests
> * publish 0.2.0-beta.d3
> * fix invite required parsing
> * @atproto/pds 0.2.0-beta.5
> * Proxy getPopularFeedGenerators on simplified pds ( bluesky-social#1222 )
> proxy getPopularFeedGenerators on pds
> Co-authored-by: dholms &lt;dtholmgren@gmail.com&gt;
> * tidy migrations
> * fix service entry
> * bump version
> * change auth order
> * bump version
> * bump version
> * add upgradeRepoVersion &amp; fallback url for cdn
> * bump version
> * merging
> * merge pds
> * building dev-env
> * merging tests
> * merge service entry
> * test fixing
> * tidy
> * fix admin search
> * tidy
> * tidy
> * add snap for getListFeed
> * add backup nameserver cfg
> * tidy + pr feedback
> * tidy
> * tidy env
> * bit more
> * re-add dotenv to root package.json
> * fix dep
> * build branch
> * fix tests
> * Refactor tests to make better use of dev-env ( bluesky-social#1690 )
> * refactor pds tests to use dev env
> * refactor bsky tests
> * fix pds test
> * tidy bsky tests
> * build pds correctly
> * fix entry point
> * default logging to false (for now)
> * format service entry
> * Switch takedown ids back to ints on pds distribution ( bluesky-social#1694 )
> * switch takedown ids back to ints, consistent with live pds
> * tidy/fix migration
> * update migration for sqlite
> * export moderation action reversal
> * takedown tests
> * dont build branch
> ---------
> Co-authored-by: Devin Ivy &lt;devinivy@gmail.com&gt;
> 
> Autogenerated from lexicons, well type hinted, documented, sync and async SDK for Python 
>  
>  
> Examples
>  
> •
>  
> Documentation
>  
> •
>  
> Discord Bluesky API
>  
>  
>  The AT Protocol SDK 
>  
>  Under construction. Until the 1.0.0 release compatibility between versions is not guaranteed. 
>  
>  Code snippet: 
>  from atproto import Client , client_utils 
>  def main ():
>  client = Client ()
>  profile = client . login ( 'my-handle' , 'my-password' )
>  print ( 'Welcome,' , profile . display_name )
>  text = client_utils . TextBuilder (). text ( 'Hello World from ' ). link ( 'Python SDK' , 'https://atproto.blue' )
>  post = client . send_post ( text )
>  client . like ( post . uri , post . cid )
>  if __name__ == '__main__' :
>  main () 
>  💬 Direct Messages (Chats) 
>  🍿 Example project with custom feed generator 
>  🔥 Firehose data streaming is available 
>  🌐 Identity resolvers for DID and Handle 
>  Introduction 
>  This SDK attempts to implement everything that provides ATProto. There is support for Lexicon Schemes, XRPC clients, Firehose, Identity, DID keys, signatures, and more. All models, queries, and procedures are generated automatically. The main focus is on the lexicons of atproto.com and bsky.app, but it doesn't have a vendor lock on it. Feel free to use the code generator for your own lexicon schemes. SDK also provides utilities to work with CID, NSID, AT URI Schemes, DAG-CBOR, CAR files, DID Documents and more. 
>  Requirements 
>  
>  Python 3.8 or higher. 
>  
>  Installing 
>  Quick start 
>  First of all, you need to create the instance of the XRPC Client. To do so, you have two major options: asynchronous, and synchronous. The difference only in import and how you call the methods. If you are not familiar with async, use sync instead. 
>  For sync: 
>  from atproto import Client 
>  client = Client ()
>  # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor 
>  # Client('https://example.com') 
>  For async: 
>  from atproto import AsyncClient 
>  client = AsyncClient ()
>  # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor 
>  # AsyncClient('https://example.com') 
>  In the snippets below, only the sync version will be presented. 
>  Right after the creation of the Client instance, you probably want to access the full API and perform actions by profile. To achieve this, you should log in to the network using your handle and password. The password could be app-specific. 
>  from atproto import Client 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' ) 
>  You are awesome! Now you feel to pick any high-level method that you want and perform it! 
>  Code to send post: 
>  from atproto import Client 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  client . send_post ( text = 'Hello World!' ) 
>  Useful links to continue: 
>  
>  List of all methods with documentation . 
>  Examples of using the methods . 
>  
>  SDK structure 
>  The SDK is built upon the following components: 
>  
>  
>  
>  Package 
>  Description 
>  
>  
>  
>  
>  atproto 
>  Import shortcuts to other packages. 
>  
>  
>  atproto_cli 
>  CLI tool to generate code. 
>  
>  
>  atproto_client 
>  XRPC Client, data models, and utils like rich text helper. 
>  
>  
>  atproto_codegen 
>  Code generator of models, clients, and namespaces. 
>  
>  
>  atproto_core 
>  Tools to work with NSID, AT URI Schemes, CID, CAR files, and DID Documents. 
>  
>  
>  atproto_crypto 
>  Crypto utils like multibase, signature verification, work with DID keys. 
>  
>  
>  atproto_firehose 
>  Firehose (data streaming) client and models. 
>  
>  
>  atproto_identity 
>  Identity resolvers for DID, Handle, AT Protocol data, signing keys. 
>  
>  
>  atproto_lexicon 
>  Lexicon parser. 
>  
>  
>  atproto_server 
>  Server-side utils like JWT. 
>  
>  
>  
>  I highly recommend you to use the atproto package to import everything that you need.
> It contains shortcuts to all other packages. 
>  Documentation 
>  The documentation is live at atproto.blue . 
>  Getting help 
>  You can get help in several ways: 
>  
>  Report bugs, request new features by creating an issue . 
>  Ask questions by starting a discussion . 
>  Ask questions in Discord server . 
>  
>  Advanced usage 
>  I'll be honest. The high-level Client that was shown in the "Quick Start" section is not a real ATProto API. This is syntax sugar built upon the real XRPC methods! The high-level methods are not cover the full need of developers. To be able to do anything that you want, you should know to work with low-level API. Let's dive into it! 
>  The basics: 
>  
>  Namespaces – classes that group sub-namespaces and the XRPC queries and procedures. Built upon NSID ATProto semantic. 
>  Model – dataclasses for input, output, and params of the methods from namespaces. Models describe Record and all other types in the Lexicon Schemes. 
>  
>  Namespaces 
>  The client contains references to the root of all namespaces. It's com and app for now. 
>  from atproto import Client 
>  Client (). com 
>  Client (). app 
>  To dive deeper, you can navigate using hints from your IDE. Thanks to well-type hinted SDK, it's much easier. 
>  from atproto import Client 
>  Client (). com . atproto . server . create_session (...)
>  Client (). com . atproto . sync . get_blob (...)
>  Client (). app . bsky . feed . get_likes (...)
>  Client (). app . bsky . graph . get_follows (...) 
>  The endpoint of the path is always the method that you want to call. The method presents a query or procedure in XRPC. You should not care about it much. The only thing you need to know is that the procedures required data objects. Queries could be called with or without params. 
>  Records 
>  In some sub-namespaces, you can find records. Such record classes provide a syntax sugar not defined in the lexicon scheme. This sugar provides a more convenient way to work with repository operations. Such as creating a record, deleting a record, and so on. 
>  Here are some available records of Bluesky records: 
>  from atproto import Client 
>  Client (). app . bsky . feed . post 
>  Client (). app . bsky . feed . like 
>  Client (). app . bsky . graph . follow 
>  Client (). app . bsky . graph . block 
>  Client (). app . bsky . actor . profile 
>  # ... more 
>  Usage example with the post record: 
>  from atproto import AtUri , Client , models 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  posts = client . app . bsky . feed . post . list ( client . me . did , limit = 10 )
>  for uri , post in posts . records . items ():
>  print ( uri , post . text )
>  post = client . app . bsky . feed . post . get ( client . me . did , AtUri . from_str ( uri ). rkey )
>  print ( post . value . text )
>  post_record = models . AppBskyFeedPost . Record ( text = 'test record namespaces' , created_at = client . get_current_time_iso ())
>  new_post = client . app . bsky . feed . post . create ( client . me . did , post_record )
>  print ( new_post )
>  deleted_post = client . app . bsky . feed . post . delete ( client . me . did , AtUri . from_str ( new_post . uri ). rkey )
>  print ( deleted_post ) 
>  Please note that not all repository operations are covered by these syntax sugars. You can always use the low-level methods to perform any desired action. One such action is updating a record. 
>  Models 
>  To deal with methods, we need to deal with models! Models are available in the models module and have NSID-based aliases. Let's take a look at it. 
>  from atproto import models 
>  models . ComAtprotoIdentityResolveHandle 
>  models . AppBskyFeedPost 
>  models . AppBskyActorGetProfile 
>  # 90+ more... 
>  The model classes in the "models" aliases could be: 
>  
>  Data model 
>  Params model 
>  Response model 
>  Sugar response model 
>  Record model 
>  Type model 
>  
>  The only thing you need to know is how to create instances of models. Not with all models, you will work as model-creator. For example, SDK will create Response models for you. 
>  There are a few ways how to create the instance of a model: 
>  
>  Dict-based 
>  Class-based 
>  
>  The instances of data and params models should be passed as arguments to the methods that were described above. 
>  Dict-based: 
>  from atproto import Client 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  # The params model will be created automatically internally for you! 
>  print ( client . com . atproto . identity . resolve_handle ({ 'handle' : 'marshal.dev' })) 
>  Class-based: 
>  from atproto import Client , models 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  params = models . ComAtprotoIdentityResolveHandle . Params ( handle = 'marshal.dev' )
>  print ( client . com . atproto . identity . resolve_handle ( params )) 
>  Tip: look at typehint of the method to figure out the name and the path to the input/data model! 
>  Pro Tip: use IDE autocompletion to find necessary models! Just start typing the method name right after the dot ( models.{type method name in camel case ). 
>  Models could be nested as hell. Be ready for it! 
>  This is how we can send a post with the image using low-level XRPC Client: 
>  from atproto import Client , models 
>  client = Client ()
>  client . login ( 'my-username' , 'my-password' )
>  with open ( 'cat.jpg' , 'rb' ) as f :
>  img_data = f . read ()
>  upload = client . upload_blob ( img_data )
>  images = [ models . AppBskyEmbedImages . Image ( alt = 'Img alt' , image = upload . blob )]
>  embed = models . AppBskyEmbedImages . Main ( images = images )
>  client . com . atproto . repo . create_record (
>  models . ComAtprotoRepoCreateRecord . Data (
>  repo = client . me . did ,
>  collection = models . ids . AppBskyFeedPost ,
>  record = models . AppBskyFeedPost . Record (
>  created_at = client . get_current_time_iso (), text = 'Text of the post' , embed = embed 
> ),
> )
> )
>  # of course, you can use the syntax sugar here instead 
>  post = models . AppBskyFeedPost . Record ( text = 'Text of the post' , embed = embed , created_at = client . get_current_time_iso ())
>  client . app . bsky . feed . post . create ( client . me . did , post )
>  # or even high-level client 
>  client . send_image ( text = 'Text of the post' , image = img_data , image_alt = 'Img alt' )
>  # these three methods are equivalent 
>  I hope you are not scared. May the Force be with you. Good luck! 
>  Change log 
>  The full change log is available in CHANGES.md . 
>  Contributing 
>  Contributions of all sizes are welcome. The contribution guidelines will be presented later. 
>  License 
>  MIT
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  Explore 
>  
>  
> All features
>  
>  
>  
> Documentation
>  
>  
>  
> GitHub Skills
>  
>  
>  
> Blog
>  
>  
>  
>  
>  
>  
>  
>  
>  For 
>  
>  
> Enterprise
>  
>  
>  
> Teams
>  
>  
>  
> Startups
>  
>  
>  
> Education
>  
>  
>  
>  
>  By Solution 
>  
>  
> CI/CD &amp; Automation
>  
>  
>  
> DevOps
>  
>  
>  
> DevSecOps
>  
>  
>  
>  
>  Resources 
>  
>  
> Learning Pathways
>  
>  
>  
> White papers, Ebooks, Webinars
>  
>  
>  
> Customer Stories
>  
>  
>  
> Partners
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  Repositories 
>  
>  
> Topics
>  
>  
>  
> Trending
>  
>  
>  
> Collections
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  Available add-ons 
>  
>  
>  
>  Advanced Security 
> Enterprise-grade security features
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Enterprise-grade AI features
>  
>  
>  
>  
>  
>  Premium Support 
> Enterprise-grade 24/7 support
>  
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
> Sign up
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> BlushSocial
>  
>  / 
>  
>  atproto-tid 
>  
>  Public 
>  
>  
>  
>  
>  Notifications
>  
>  
>  
>  Fork
>  0 
>  
>  
>  
>  
>  
> Star
>  1 
>  
>  
>  
>  
>  
>  
>  
>  
>  
> Implementation of the AT Protocol Timestamp Identifiers (TIDs) in Clojure! 💙🌱
>  
>  
>  
>  1 
> star
>  
>  0 
> forks
>  
>  Branches 
>  
>  Tags 
>  
>  Activity 
>  
>  
>  
>  
> Star
>  
>  
>  
>  Notifications
>  
>  
>  
>  
>  
>  
>  
>  
>  Code 
>  
>  
>  
>  
>  Issues 
>  
>  
>  
>  Pull requests 
>  
>  
>  
>  Actions 
>  
>  
>  
>  
>  Projects 
>  
>  
>  
>  Security 
>  
>  
>  
>  Insights
> 
> Have a question about this project? Sign up for a free GitHub account to open an issue and contact its maintainers and the community.
>  
>  
>  Sign up for GitHub
>  
>  
>  By clicking “Sign up for GitHub”, you agree to our terms of service and
>  privacy statement . We’ll occasionally send you account related emails. 
>  
> Already on GitHub?
>  Sign in 
> to your account
> 
> AT Protocol OpenAPI Types 
>  This repository contains OpenAPI types for the AT Protocol. They are generated
> according to the AT Protocol Specification 
> by converting/translating the lexicon specs into OpenAPI types. 
>  My hope is for this repository to serve as a live representation of the current
> state of the AT Protocol viewed through the lens of OpenAPI. This could enable
> the generation of client and server code for the AT Protocol in a variety of
> languages. 
>  How to use 
>  I want to see what it looks like 
>  A Swagger UI instance prepopulated with the current version of the OpenAPI types is available to preview .
> You can create a session (use an app password!), input your authentication token
> and experiment with authenticated queries. 
>  I want the types 
>  All you need is the spec/api.json file! You can reference it directly at this
> URL: 
>  https://raw.githubusercontent.com/rdmurphy/atproto-openapi-types/main/spec/api.json 
>  
>  Note: The path to this file is subject to change, at least for a little
> while. I'll try my best to not move it but cannot pretend it won't happen
> while this project is still young! 
>  
>  This file is regenerated every two hours
>  via a GitHub Action to keep it up to date with
> the latest changes to the AT Protocol. It sources the
>  bluesky-social/atproto repository
> directly. 
>  I want to generate code 
>  You'll need to use the OpenAPI generator of your choice. I've had luck with
>  openapi-typescript ! 
>  I want to generate the types locally 
>  You'll need to checkout this repository and
>  make sure Deno is installed .
> You'll also need to checkout a copy of the
>  bluesky-social/atproto repository
>  into this repo's directory. (Maybe one day I'll get fancy and set up
> submodules... but not today.) 
>  Then, run the following command: 
>  If you'd like to tweak the generator and see your changes live you can run the
> following command. It will watch for changes and re-run the script any time a
> file is updated: 
>  Known limitations 
>  It's currently not possible to represent the subscription type in OpenAPI. It
> appears the maintainers of the specification
>  have passed on the inclusion of any interfaces that are not strictly scoped to the HTTP protocol .
> (WebSockets are opened via a HTTP request, but I digress.)
>  AsyncAPI may be a better fit for this use case. 
>  Existing implementations 
>  
>  Bluesky-OpenAPI : Another AT
> Protocol to OpenAPI conversion by @trozzelle .
> It takes a slightly different approach to naming the schemas you may prefer! 
>  
>  License 
>  MIT
> 
> indigo: atproto libraries and services in golang 
>  Some Bluesky software is developed in Typescript, and lives in the bluesky-social/atproto repository. Some is developed in Go, and lives here. 
>  What is in here? 
>  Go Services: 
>  
>  bigsky ( README ): "Big Graph Service" (BGS) reference implementation, running at bsky.network 
>  palomar ( README ): fulltext search service for https://bsky.app 
>  
>  Go Packages: 
>  
>  All the packages in this repository are under active development. Features and software interfaces have not stabilized and may break or be removed. 
>  
>  
>  
>  
>  Package 
>  Docs 
>  
>  
>  
>  
>  api/atproto : generated types for com.atproto.* Lexicons 
>  
>  
>  
>  api/bsky : generated types for app.bsky.* Lexicons 
>  
>  
>  
>  atproto/crypto : crytographic signing and key serialization 
>  
>  
>  
>  atproto/identity : DID and handle resolution 
>  
>  
>  
>  atproto/syntax : string types and parsers for identifiers 
>  
>  
>  
>  mst : Merkle Search Tree implementation 
>  
>  
>  
>  repo : account data storage 
>  
>  
>  
>  xrpc : HTTP API client 
>  
>  
>  
>  
>  The TypeScript reference implementation, including PDS and bsky AppView services, is at bluesky-social/atproto . Source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Development Quickstart 
>  First, you will need the Go toolchain installed. We develop using the latest stable version of the language. 
>  The Makefile provides wrapper commands for basic development: 
>  make build
> make test
> make fmt
> make lint
>  
>  Individual commands can be run like: 
>  The HACKING file has a list of commands and packages in this repository and some other development tips. 
>  What is atproto? 
>  not to be confused with the AT command set or Adenosine triphosphate 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  Issues are for bugs &amp; feature requests related to the golang implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or libraries used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> AT Protocol Bluesky NextJS 13.4 Client 
>  This is a proof of concept NextJS client for AT Protocol / Bluesky that works with NextJS 13.4's App Router and React Server Components for server-side rendering. 
>  Start 
>  # Install the packages 
> npm i
>  # Start the dev server 
> npm run dev
>  # Open in browser: http://localhost:3000 
>  Auth Middleware 
>  The middleware handles automatic redirection of logged in and logged out users to the appropriate pages during server-request. 
>  The primary middleware function hasActiveAtpSessionMiddleware() which checks for a session cookie and gets the session from the AT Protocol server uses the fetch() function for server-side compatibility. 
>  The fetch function is used instead of the XRPC wrapper. See below for reasons. 
>  Cookies 
>  
>  Cookies are used to allow server-side functions to access the client's auth session tokens 
>  
>  Data Fetching 
>  The built-in @atproto/api package instantiates a BskyAgent for convenient access to Bluesky queries and procedures. 
>  Example: await bskyAgent.getTimeline() 
>  However, these methods do not appear to be compatible with NextJS server-side rendering and data fetching and will result in the following error 
>  ReferenceError: document is not defined 
>  In the cases of server-side data fetching, the XRPC wrapper is bypassed and we call the endpoint URL directly with the fetch() function. 
>  Areas for Continued Development / Left Off 
>  I have not spent much time troubleshooting the document is not defined errors when trying to execute BskyAgent calls on the server. 
>  The defaultFetchHandler() function at the root of the XRPC calls appears to use the fetch() method which should be server-side compatible. 
>  Possible Solutions 
>  
>  It's possible this is a simple packaging issue or a bug in my code pattern 
>  It's possible that the code-generator could be modified to generate NextJS server-side compatible agent functions for each of the lexicon defined endpoints
> 
> Swift package that provides a AT Protocol libraries. 
>  🚧 This package is under development. 🚧 
>  Requirements 
>  
>  Swift 5.9 or later 
>  
>  Overview 
>  swift-atproto includes the following libraries. 
>  ATProto 
>  ATProto is a umbrella library that includes all libraries in swift-atproto. 
>  ATProtoAPI 
>  ATProtoAPI includes auto-generated Swift code from lexicon files in bluesky-social/atproto . Code is generated by andooown/lexicon-gen . 
>  ATProtoXRPC 
>  ATProtoXRPC is a library that provides XRPC client and fundamental types for XRPC. 
>  ATProtoCore 
>  ATProtoCore is a library that provides fundamental types for AT Protocol. 
>  ATProtoMacro 
>  ATProtoMacro is a library that provides some Swift Macros for AT Protocol. 
>  
>  #LexiconDefID(_:) 
>  
>  Author 
>  
>  andooown 
>  
>  License 
>  swift-atproto is available under the MIT license. See the LICENSE file for more info.
> 
> AT Protocol Reference Implementation (TypeScript) 
>  Welcome friends! 
>  This repository contains Bluesky's reference implementation of AT Protocol, and of the app.bsky microblogging application service backend. 
>  What is in here? 
>  TypeScript Packages: 
>  
>  
>  
>  Package 
>  Docs 
>  NPM 
>  
>  
>  
>  
>  @atproto/api : client library 
>  README 
>  
>  
>  
>  @atproto/common-web : shared code and helpers which can run in web browsers 
>  README 
>  
>  
>  
>  @atproto/common : shared code and helpers which doesn't work in web browsers 
>  README 
>  
>  
>  
>  @atproto/crypto : cryptographic signing and key serialization 
>  README 
>  
>  
>  
>  @atproto/identity : DID and handle resolution 
>  README 
>  
>  
>  
>  @atproto/lexicon : schema definition language 
>  README 
>  
>  
>  
>  @atproto/repo : data storage structure, including MST 
>  README 
>  
>  
>  
>  @atproto/syntax : string parsers for identifiers 
>  README 
>  
>  
>  
>  @atproto/xrpc : client-side HTTP API helpers 
>  README 
>  
>  
>  
>  @atproto/xrpc-server : server-side HTTP API helpers 
>  README 
>  
>  
>  
>  
>  TypeScript Services: 
>  
>  pds : "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in packages/pds , with runtime wrapper in services/pds . See bluesky-social/pds for directions on self-hosting in the federation sandbox network . 
>  bsky : AppView implementation of the app.bsky.* API endpoints. Running on main network at api.bsky.app . Most implementation code in packages/bsky , with runtime wrapper in services/bsky . 
>  
>  Lexicons: for both the com.atproto.* and app.bsky.* are canonically versioned in this repo, for now, under ./lexicons/ . These are JSON files in the Lexicon schema definition language , similar to JSON Schema or OpenAPI. 
>  Interoperability Test Data: the language-neutral test files in ./interop-test-files/ may be useful for other protocol implementations to ensure that they follow the specification correctly 
>  The source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Go programming language source code is in bluesky-social/indigo , including the BGS implementation. 
>  Developer Quickstart 
>  We recommend nvm for managing Node.js installs. This project requires Node.js version 18. pnpm is used to manage the workspace of multiple packages. You can install it with npm install --global pnpm . 
>  There is a Makefile which can help with basic development tasks: 
>  # use existing nvm to install node 18 and pnpm 
> make nvm-setup
>  # pull dependencies and build all local packages 
> make deps
> make build
>  # run the tests, using Docker services as needed 
> make test 
>  # run a local PDS and AppView with fake test accounts and data 
>  # (this requires a global installation of `jq` and `docker`) 
> make run-dev-env
>  # show all other commands 
> make help 
>  About AT Protocol 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  If submitting a PR that includes a lexicon change, please get sign off on the lexicon change before doing the implementation. 
>  Issues are for bugs &amp; feature requests related to the TypeScript implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or frameworks used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team, and we'll respond promptly. See SECURITY.md for more info. 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT.txt or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE.txt or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> atproto-website 
>  This repository contains the documentation for the AT Protocol, available to read at atproto.com . 
>  To read documentation for the Bluesky API, go to docs.bsky.app or this repo . 
>  Making edits to atproto.com 
>  
>  clone this repo 
>  run npm install 
>  run the development server with npm run dev or yarn dev 
>  open http://localhost:3000 with your browser. 
>  
>  
>  pages/index.js generates http://localhost:3000 -- start there if you'd like to make changes. 
>  The page auto-updates as you edit the file. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  Documentation text and the atproto specifications are under Creative Commons Attribution (CC-BY). 
>  Inline code examples, example data, and regular expressions are under Creative Commons Zero (CC-0, aka Public Domain) and copy/pasted without attribution. 
>  Please see LICENSE.txt with reminders about derivative works, and LICENSE-CC-BY.txt for a copy of license legal text.
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  Explore 
>  
>  
> All features
>  
>  
>  
> Documentation
>  
>  
>  
> GitHub Skills
>  
>  
>  
> Blog
>  
>  
>  
>  
>  
>  
>  
>  
>  For 
>  
>  
> Enterprise
>  
>  
>  
> Teams
>  
>  
>  
> Startups
>  
>  
>  
> Education
>  
>  
>  
>  
>  By Solution 
>  
>  
> CI/CD &amp; Automation
>  
>  
>  
> DevOps
>  
>  
>  
> DevSecOps
>  
>  
>  
>  
>  Resources 
>  
>  
> Learning Pathways
>  
>  
>  
> White papers, Ebooks, Webinars
>  
>  
>  
> Customer Stories
>  
>  
>  
> Partners
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  Repositories 
>  
>  
> Topics
>  
>  
>  
> Trending
>  
>  
>  
> Collections
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  Available add-ons 
>  
>  
>  
>  Advanced Security 
> Enterprise-grade security features
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Enterprise-grade AI features
>  
>  
>  
>  
>  
>  Premium Support 
> Enterprise-grade 24/7 support
>  
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
> Sign up
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> bluesky-social
>  
>  / 
>  
>  atproto-website 
>  
>  Public 
>  
>  
>  
>  
>  Notifications
>  
>  
>  
>  Fork
>  138 
>  
>  
>  
>  
>  
> Star
>  213 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Code 
>  
>  
>  
>  
>  Issues 
>  23 
>  
>  
>  
>  Pull requests 
>  16 
>  
>  
>  
>  Actions 
>  
>  
>  
>  
>  Projects 
>  
>  
>  
>  Security 
>  
>  
>  
>  Insights
> 
> ozone 
>  Overview 
>  The Ozone project for the AT Protocol consists of 3 components: 
>  
>  A Gradle plugin to compile AT Protocol schemas into usable Kotlin classes. 
>  Multiplatform APIs for the AT Protocol spec that can be used with any compatible service, including Bluesky Social .
>  
>  Supports Android, JVM, JavaScript, and iOS. 
>  
>  
>  Example client apps that demonstrate usage of those APIs. 
>  
>  
>  Warning 
>  🚧 🚧 🚧 Everything in here is very much a work-in-progress!
> The upstream schemas are still subject to breaking
> changes and may break at any moment if used in production code. Use at your own risk! 
>  
>  Why "Ozone"? 
>  O 3 exists at all levels in the ATmosphere . 
>  No relation to the moderation tools also named Ozone . 
>  Bluesky Social Bindings 
>  Documentation is available at ozone.christian.sh . 
>  Java / Kotlin 
>  // build.gradle[.kts] 
> dependencies {
> api( " sh.christian.ozone:bluesky:0.1.0 " )
> } 
>  Swift / Objective-C 
>  In Xcode, select File &gt; Add Packages and enter https://github.com/christiandeange/BlueskyAPI 
>  Gradle Plugin 
>  In addition to shipping the lexicons that define the official Bluesky API, this project also includes a Gradle Plugin that allows you to bring your own lexicon definitions and generate any set of AT Protocol bindings from them. 
>  // build.gradle[.kts] 
> plugins {
> id( " sh.christian.ozone.generator " ) version " 0.1.0 " 
> }
> dependencies {
>  // This is where you have your schema files stored in your project. 
> lexicons(fileTree( " lexicons " ) { include( " **/*.json " ) })
> }
> lexicons {
>  // Generates an additional interface for the target schemas. 
>  // This method can be called more than once to generate multiple API interfaces. 
> generateApi( " BlueskyApi " ) {
>  // Determines the package name of the generated API. Defaults to "sh.christian.ozone". 
> packageName.set( " com.example.myapp " )
>  // Generates an additional class that implements this interface by sending corresponding 
>  // XRPC requests to a provided host conforming to the AT Protocol. 
>  // Inherits the same package name as the generated interface. 
> withKtorImplementation( " XrpcBlueskyApi " )
>  // Determines the return type for each generated API method. Defaults to Raw. 
>  // - Raw: the raw data type 
>  // - Result: Result&lt;T&gt; 
>  // - Response: AtpResponse&lt;T&gt; 
> returnType.set( ApiReturnType . Result )
>  // Determines whether the generated methods should be marked as suspend functions. 
>  // When generating a Ktor implementation as well, execution will block the current thread 
>  // for non-suspending methods. Defaults to true. 
> suspending.set( true )
> }
>  // File path where Kotlin source files will be written to. Defaults to "/build/generated/lexicons". 
> outputDirectory.set(project.layout.buildDirectory.dir( " out " ))
> }
> 
> AT Protocol implementation in Python 
>  This is just starting, as I begin to grok Bluesky and the AT Protocol.
> I'm releasing it super early for educational purposes only. 
>  Set environment variables BLUESKY_IDENTIFIER and BLUESKY_PASSWORD to run demo.py .
> The password should be an App Password , not your main password. 
>  
>  
>  atproto.py basic client library for accessing the Bluesky PDS. 
>  
>  
>  utils.py basic util functions 
>  
>  
>  lexicon.py work-in-progress module for dealing with lexicon files 
>  
>  
>  demo.py runnable script trying things out 
>  
>  
>  cli.py command-line interface 
>  
>  
>  followers.py quick script to list your followers (display name and handle) 
>  
>  
>  post.py quick script to post 
>  
>  
>  repos.py quick script to list repos 
>  
>  
>  What I've Tried 
>  com.atproto.admin 
>  Nothing yet. 
>  com.atproto.identity 
>  
>  resolveHandle 
>  
>  com.atproto.label 
>  Nothing yet. 
>  com.atproto.moderation 
>  Nothing yet. 
>  com.atproto.repo 
>  
>  describeRepo 
>  listRecords 
>  getRecord 
>  createRecord 
>  
>  com.atproto.server 
>  
>  describeServer 
>  createSession 
>  getAccountInviteCodes 
>  getSession 
>  
>  com.atproto.sync 
>  
>  listRepos 
>  
>  app.bsky.actor 
>  
>  getProfile 
>  
>  app.bsky.embed 
>  Nothing yet. 
>  app.bsky.feed 
>  
>  getPosts 
>  
>  Collections: 
>  
>  post 
>  
>  app.bsky.graph 
>  
>  getFollows 
>  getFollowers 
>  
>  Collections: 
>  
>  follow 
>  
>  app.bsky.notification 
>  Nothing yet. 
>  app.bsky.richtext 
>  Nothing yet. 
>  Changes to API since I first started 
>  
>  
>  new method app.bsky.feed.getPosts 
>  
>  
>  app.bsky.embed.record now included labels 
>  
>  
>  viewerState in app.bsky.actor.defs now has extra properties blockedBy (boolean) and blocking (at-uri) 
>  
>  
>  app.bsky.embed.record allows for embedded records to reference posts as blocked 
>  
>  
>  app.bsky.feed.getAuthorFeed can return a BlockedActor or BlockedByActor error 
>  
>  
>  app.bsky.feed.getPostThread allows for a reference to a blocked post and (via change to app.bsky.feed.defs ) parent and replies can also reference blocked posts 
>  
>  
>  there is a new record app.bsky.graph.block for blocks with subject (did) and createdAt (datetime) properties 
>  
>  
>  new method app.bsky.graph.getBlocks that returns who you are blocking (as an array of profileView s)
> 
> Bluesky Social App 
>  Welcome friends! This is the codebase for the Bluesky Social app. 
>  Get the app itself: 
>  
>  Web: bsky.app 
>  iOS: App Store 
>  Android: Play Store 
>  
>  Development Resources 
>  This is a React Native application, written in the TypeScript programming language. It builds on the atproto TypeScript packages (like @atproto/api ), code for which is also on open source, but in a different git repository . 
>  There is a small amount of Go language source code (in ./bskyweb/ ), for a web service that returns the React Native Web application. 
>  The Build Instructions are a good place to get started with the app itself. 
>  The Authenticated Transfer Protocol ("AT Protocol" or "atproto") is a decentralized social media protocol. You don't need to understand AT Protocol to work with this application, but it can help. Learn more at: 
>  
>  Overview and Guides 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We're not going to provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  Stay away from PRs like...
>  
>  Changing "Post" to "Skeet." 
>  Refactoring the codebase, eg to replace mobx with redux or something. 
>  Adding entirely new features without prior discussion. 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day to day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. That's what forking is for! 
>  Forking guidelines 
>  You have our blessing 🪄✨ to fork this application! However, it's very important to be clear to users when you're giving them a fork. 
>  Please be sure to: 
>  
>  Change all branding in the repository and UI to clearly differentiate from Bluesky. 
>  Change any support links (feedback, email, terms of service, etc) to your own systems. 
>  Replace any analytics or error-collection systems with your own so we don't get super confused. 
>  
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team and we'll respond promptly. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License (MIT) 
>  See ./LICENSE for the full license. 
>  P.S. 
>  We ❤️ you and all of the ways you support us. Thank you for making Bluesky a great place!
> 
> ## Welcome to the Atmosphere
> 
> The AT Protocol is an open, decentralized network for building social applications.
> 
> ### Quickstart
> 
> Create an application and start building.
> 
> [Read more](/guides/applications)
> 
> ### Self-host
> 
> Learn how to set up your own personal data server.
> 
> [Read more](/guides/self-hosting)
> 
> ### Glossary
> 
> Definitions for all the terminology used in AT Protocol.
> 
> [Read more](/guides/glossary)
> 
> ### FAQ
> 
> Frequently Asked Questions about the Atmosphere.
> 
> [Read more](/guides/faq)
> 
> ### [Repository](/specs/repository)
> 
> Self-authenticating storage for public account content.
> 
> ### [Lexicon](/specs/lexicon)
> 
> A schema definition language for ATProto.
> 
> ### [URI Scheme](/specs/at-uri-scheme)
> 
> A URI scheme for addressing ATProto repository data.
> 
> Guide
> 
> What's a PDS? an AppView? a DID? If you're feeling a little bowled over by new concepts, give this glossary a look.
> 
> [Keep reading](/guides/glossary)
> 
> Guide
> 
> In this guide, we build a simple multi-user app that publishes your current "status" as an emoji.
> 
> [Keep reading](/guides/applications)
> 
> Article
> 
> In this article we explore AT Proto from the perspective of distributed backend engineering.
> 
> [Keep reading](/articles/atproto-for-distsys-engineers)
> 
> Guide
> 
> This guide will introduce you to Lexicon and get you started with building your own schemas.
> 
> [Keep reading](/guides/lexicon)
> 
> Go to [docs.bsky.app](https://docs.bsky.app/) for Bluesky-specific documentation.
> 
> ## AT Protocol Reference Implementation (TypeScript)
> 
> [](#at-protocol-reference-implementation-typescript)
> 
> Welcome friends!
> 
> This repository contains Bluesky's reference implementation of AT Protocol, and of the `app.bsky` microblogging application service backend.
> 
> ## What is in here?
> 
> [](#what-is-in-here)
> 
> **TypeScript Packages:**
> 
> | Package                                                                     | Docs                                                                       | NPM                                                                                                                                                                                                                                                                  |
> | --------------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | @atproto/api: client library                                                | [README](/bluesky-social/atproto/blob/main/packages/api/README.md)         | [![NPM](https://camo.githubusercontent.com/6327031e34807d5a06ce855d6d0e41383d3b6078e86dfad37d05b27db130ec99/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f617069)](https://www.npmjs.com/package/@atproto/api)                         |
> | @atproto/common-web: shared code and helpers which can run in web browsers  | [README](/bluesky-social/atproto/blob/main/packages/common-web/README.md)  | [![NPM](https://camo.githubusercontent.com/70d89e009507817dbf8da9d1c540817ee9b40f2a771b4aa9de10e0b9ce93ff56/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f636f6d6d6f6e2d776562)](https://www.npmjs.com/package/@atproto/common-web)    |
> | @atproto/common: shared code and helpers which doesn't work in web browsers | [README](/bluesky-social/atproto/blob/main/packages/common/README.md)      | [![NPM](https://camo.githubusercontent.com/a4254843e8a1ea731e231d395ce7dd3189e5eaf9456d456fd1cb73e0a7441435/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f636f6d6d6f6e)](https://www.npmjs.com/package/@atproto/common)                |
> | @atproto/crypto: cryptographic signing and key serialization                | [README](/bluesky-social/atproto/blob/main/packages/crypto/README.md)      | [![NPM](https://camo.githubusercontent.com/925a4f571cce4e38c30a609a50bbe95dadaceb69f57e823e2999b578a30d701b/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f63727970746f)](https://www.npmjs.com/package/@atproto/crypto)                |
> | @atproto/identity: DID and handle resolution                                | [README](/bluesky-social/atproto/blob/main/packages/identity/README.md)    | [![NPM](https://camo.githubusercontent.com/ad1ac05d36585c99e31447f39c8dabc228e2e417345330a19e7fdb151f79ee8f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f6964656e74697479)](https://www.npmjs.com/package/@atproto/identity)          |
> | @atproto/lexicon: schema definition language                                | [README](/bluesky-social/atproto/blob/main/packages/lexicon/README.md)     | [![NPM](https://camo.githubusercontent.com/e9cbd3c2860d659dc6459b84232144765ab12870470f36e2c916b462a81957b0/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f6c657869636f6e)](https://www.npmjs.com/package/@atproto/lexicon)             |
> | @atproto/repo: data storage structure, including MST                        | [README](/bluesky-social/atproto/blob/main/packages/repo/README.md)        | [![NPM](https://camo.githubusercontent.com/539b08001d75662650ad8e13e2c7d3a0b3d01e8f9de005e7e549f79757794e26/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f7265706f)](https://www.npmjs.com/package/@atproto/repo)                      |
> | @atproto/syntax: string parsers for identifiers                             | [README](/bluesky-social/atproto/blob/main/packages/syntax/README.md)      | [![NPM](https://camo.githubusercontent.com/21be3b53af18c9b5378e9bf17c2cf477fa9a87efa0a2bfdc510e8513f58c7902/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f73796e746178)](https://www.npmjs.com/package/@atproto/syntax)                |
> | @atproto/xrpc: client-side HTTP API helpers                                 | [README](/bluesky-social/atproto/blob/main/packages/xrpc/README.md)        | [![NPM](https://camo.githubusercontent.com/c34b17f0a5b255f0951a320171f339cdfcb4a520329f0bef5b787ec65a1f2f0f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f78727063)](https://www.npmjs.com/package/@atproto/xrpc)                      |
> | @atproto/xrpc-server: server-side HTTP API helpers                          | [README](/bluesky-social/atproto/blob/main/packages/xrpc-server/README.md) | [![NPM](https://camo.githubusercontent.com/4519890d16577ab0840d6975df83df18ea39e63ee6963eb2f71df9951d435d65/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f787270632d736572766572)](https://www.npmjs.com/package/@atproto/xrpc-server) |
> 
> **TypeScript Services:**
> 
> * `pds`: "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in `packages/pds`, with runtime wrapper in `services/pds`. See [bluesky-social/pds](https://github.com/bluesky-social/pds) for directions on self-hosting.
> * `bsky`: AppView implementation of the `app.bsky.*` API endpoints. Running on main network at `api.bsky.app`. Most implementation code in `packages/bsky`, with runtime wrapper in `services/bsky`.
> 
> **Lexicons:** for both the `com.atproto.*` and `app.bsky.*` are canonically versioned in this repo, for now, under `./lexicons/`. These are JSON files in the [Lexicon schema definition language](https://atproto.com/specs/lexicon), similar to JSON Schema or OpenAPI.
> 
> **Interoperability Test Data:** the language-neutral test files in `./interop-test-files/` may be useful for other protocol implementations to ensure that they follow the specification correctly
> 
> The source code for the Bluesky Social client app (for web and mobile) can be found at [bluesky-social/social-app](https://github.com/bluesky-social/social-app).
> 
> Go programming language source code is in [bluesky-social/indigo](https://github.com/bluesky-social/indigo), including the BGS implementation.
> 
> ## Developer Quickstart
> 
> [](#developer-quickstart)
> 
> We recommend [nvm](https://github.com/nvm-sh/nvm) for managing Node.js installs. This project requires Node.js version 18\. `pnpm` is used to manage the workspace of multiple packages. You can install it with `npm install --global pnpm`.
> 
> There is a Makefile which can help with basic development tasks:
> 
> # use existing nvm to install node 18 and pnpm
> make nvm-setup
> 
> # pull dependencies and build all local packages
> make deps
> make build
> 
> # run the tests, using Docker services as needed
> make test
> 
> # run a local PDS and AppView with fake test accounts and data
> # (this requires a global installation of `jq` and `docker`)
> make run-dev-env
> 
> # show all other commands
> make help
> 
> ## About AT Protocol
> 
> [](#about-at-protocol)
> 
> The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by [Bluesky PBC](https://bsky.social/). Learn more at:
> 
> * [Overview and Guides](https://atproto.com/guides/overview) 👈 Best starting point
> * [Github Discussions](https://github.com/bluesky-social/atproto/discussions) 👈 Great place to ask questions
> * [Protocol Specifications](https://atproto.com/specs/atp)
> * [Blogpost on self-authenticating data structures](https://bsky.social/about/blog/3-6-2022-a-self-authenticating-social-protocol)
> 
> The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is `app.bsky.*`.
> 
> ## Contributions
> 
> [](#contributions)
> 
> > While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review.
> 
> **Rules:**
> 
> * We may not respond to your issue or PR.
> * We may close an issue or PR without much feedback.
> * We may lock discussions or contributions if our attention is getting DDOSed.
> * We do not provide support for build issues.
> 
> **Guidelines:**
> 
> * Check for existing issues before filing a new one, please.
> * Open an issue and give some time for discussion before submitting a PR.
> * If submitting a PR that includes a lexicon change, please get sign off on the lexicon change _before_ doing the implementation.
> * Issues are for bugs & feature requests related to the TypeScript implementation of atproto and related services.  
>    * For high-level discussions, please use the [Discussion Forum](https://github.com/bluesky-social/atproto/discussions).  
>    * For client issues, please use the relevant [social-app](https://github.com/bluesky-social/social-app) repo.
> * Stay away from PRs that:  
>    * Refactor large parts of the codebase  
>    * Add entirely new features without prior discussion  
>    * Change the tooling or frameworks used without prior discussion  
>    * Introduce new unnecessary dependencies
> 
> Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth.
> 
> ## Are you a developer interested in building on atproto?
> 
> [](#are-you-a-developer-interested-in-building-on-atproto)
> 
> Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more.
> 
> ## Security disclosures
> 
> [](#security-disclosures)
> 
> If you discover any security issues, please send an email to [security@bsky.app](mailto:security@bsky.app). The email is automatically CCed to the entire team, and we'll respond promptly. See [SECURITY.md](https://github.com/bluesky-social/atproto/blob/main/SECURITY.md) for more info.
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> ## ATP API
> 
> [](#atp-api)
> 
> This API is a client for ATProtocol servers. It communicates using HTTP. It includes:
> 
> * ✔️ APIs for ATProto and Bluesky.
> * ✔️ Validation and complete typescript types.
> * ✔️ Session management.
> * ✔️ A RichText library.
> 
> ## Getting started
> 
> [](#getting-started)
> 
> First install the package:
> 
> Then in your application:
> 
> import { AtpAgent } from '@atproto/api'
> 
> const agent = new AtpAgent({ service: 'https://example.com' })
> 
> ## Usage
> 
> [](#usage)
> 
> ### Session management
> 
> [](#session-management)
> 
> You'll need an authenticated session for most API calls. There are two ways to manage sessions:
> 
> 1. [App password based session management](#app-password-based-session-management)
> 2. [OAuth based session management](#oauth-based-session-management)
> 
> #### App password based session management
> 
> [](#app-password-based-session-management)
> 
> Username / password based authentication can be performed using the `AtpAgent`class.
> 
> Caution
> 
> This method is deprecated in favor of OAuth based session management. It is recommended to use OAuth based session management (through the`@atproto/oauth-client-*` packages).
> 
> import { AtpAgent, AtpSessionEvent, AtpSessionData } from '@atproto/api'
> 
> // configure connection to the server, without account authentication
> const agent = new AtpAgent({
>   service: 'https://example.com',
>   persistSession: (evt: AtpSessionEvent, sess?: AtpSessionData) => {
>     // store the session-data for reuse
>   },
> })
> 
> // Change the agent state to an authenticated state either by:
> 
> // 1) creating a new account on the server.
> await agent.createAccount({
>   email: 'alice@mail.com',
>   password: 'hunter2',
>   handle: 'alice.example.com',
>   inviteCode: 'some-code-12345-abcde',
> })
> 
> // 2) if an existing session was securely stored previously, then reuse that to resume the session.
> await agent.resumeSession(savedSessionData)
> 
> // 3) if no old session was available, create a new one by logging in with password (App Password)
> await agent.login({
>   identifier: 'alice@mail.com',
>   password: 'hunter2',
> })
> 
> #### OAuth based session management
> 
> [](#oauth-based-session-management)
> 
> Depending on the environment used by your application, different OAuth clients are available:
> 
> * [@atproto/oauth-client-browser](https://www.npmjs.com/package/@atproto/oauth-client-browser): for the browser.
> * [@atproto/oauth-client-node](https://www.npmjs.com/package/@atproto/oauth-client-node): for Node.js.
> * [@atproto/oauth-client](https://www.npmjs.com/package/@atproto/oauth-client): Lower level; compatible with most JS engines.
> 
> Every `@atproto/oauth-client-*` implementation has a different way to obtain an`OAuthSession` instance that can be used to instantiate an `Agent` (from`@atproto/api`). Here is an example restoring a previously saved session:
> 
> import { Agent } from '@atproto/api'
> import { OAuthClient } from '@atproto/oauth-client'
> 
> const oauthClient = new OAuthClient({
>   // ...
> })
> 
> const oauthSession = await oauthClient.restore('did:plc:123')
> 
> // Instantiate the api Agent using an OAuthSession
> const agent = new Agent(oauthSession)
> 
> ### API calls
> 
> [](#api-calls)
> 
> The agent includes methods for many common operations, including:
> 
> // The DID of the user currently authenticated (or undefined)
> agent.did
> agent.accountDid // Throws if the user is not authenticated
> 
> // Feeds and content
> await agent.getTimeline(params, opts)
> await agent.getAuthorFeed(params, opts)
> await agent.getPostThread(params, opts)
> await agent.getPost(params)
> await agent.getPosts(params, opts)
> await agent.getLikes(params, opts)
> await agent.getRepostedBy(params, opts)
> await agent.post(record)
> await agent.deletePost(postUri)
> await agent.like(uri, cid)
> await agent.deleteLike(likeUri)
> await agent.repost(uri, cid)
> await agent.deleteRepost(repostUri)
> await agent.uploadBlob(data, opts)
> 
> // Social graph
> await agent.getFollows(params, opts)
> await agent.getFollowers(params, opts)
> await agent.follow(did)
> await agent.deleteFollow(followUri)
> 
> // Actors
> await agent.getProfile(params, opts)
> await agent.upsertProfile(updateFn)
> await agent.getProfiles(params, opts)
> await agent.getSuggestions(params, opts)
> await agent.searchActors(params, opts)
> await agent.searchActorsTypeahead(params, opts)
> await agent.mute(did)
> await agent.unmute(did)
> await agent.muteModList(listUri)
> await agent.unmuteModList(listUri)
> await agent.blockModList(listUri)
> await agent.unblockModList(listUri)
> 
> // Notifications
> await agent.listNotifications(params, opts)
> await agent.countUnreadNotifications(params, opts)
> await agent.updateSeenNotifications()
> 
> // Identity
> await agent.resolveHandle(params, opts)
> await agent.updateHandle(params, opts)
> 
> // Legacy: Session management should be performed through the SessionManager
> // rather than the Agent instance.
> if (agent instanceof AtpAgent) {
>   // AtpAgent instances support using different sessions during their lifetime
>   await agent.createAccount({ ... }) // session a
>   await agent.login({ ... }) // session b
>   await agent.resumeSession(savedSession) // session c
> }
> 
> ### Validation and types
> 
> [](#validation-and-types)
> 
> The package includes a complete types system which includes validation and type-guards. For example, to validate a post record:
> 
> import { AppBskyFeedPost } from '@atproto/api'
> 
> const post = {...}
> if (AppBskyFeedPost.isRecord(post)) {
>   // typescript now recognizes `post` as a AppBskyFeedPost.Record
>   // however -- we still need to validate it
>   const res = AppBskyFeedPost.validateRecord(post)
>   if (res.success) {
>     // a valid record
>   } else {
>     // something is wrong
>     console.log(res.error)
>   }
> }
> 
> ### Rich text
> 
> [](#rich-text)
> 
> Some records (ie posts) use the `app.bsky.richtext` lexicon. At the moment richtext is only used for links and mentions, but it will be extended over time to include bold, italic, and so on.
> 
> ℹ️ It is **strongly** recommended to use this package's `RichText` library. Javascript encodes strings in utf16 while the protocol (and most other programming environments) use utf8\. Converting between the two is challenging, but `RichText` handles that for you.
> 
> import { RichText } from '@atproto/api'
> 
> // creating richtext
> const rt = new RichText({
>   text: 'Hello @alice.com, check out this link: https://example.com',
> })
> await rt.detectFacets(agent) // automatically detects mentions and links
> const postRecord = {
>   $type: 'app.bsky.feed.post',
>   text: rt.text,
>   facets: rt.facets,
>   createdAt: new Date().toISOString(),
> }
> 
> // rendering as markdown
> let markdown = ''
> for (const segment of rt.segments()) {
>   if (segment.isLink()) {
>     markdown += `[${segment.text}](${segment.link?.uri})`
>   } else if (segment.isMention()) {
>     markdown += `[${segment.text}](https://my-bsky-app.com/user/${segment.mention?.did})`
>   } else {
>     markdown += segment.text
>   }
> }
> 
> // calculating string lengths
> const rt2 = new RichText({ text: 'Hello' })
> console.log(rt2.length) // => 5
> console.log(rt2.graphemeLength) // => 5
> const rt3 = new RichText({ text: '👨‍👩‍👧‍👧' })
> console.log(rt3.length) // => 25
> console.log(rt3.graphemeLength) // => 1
> 
> ### Moderation
> 
> [](#moderation)
> 
> Applying the moderation system is a challenging task, but we've done our best to simplify it for you. The Moderation API helps handle a wide range of tasks, including:
> 
> * Moderator labeling
> * User muting (including mutelists)
> * User blocking
> * Mutewords
> * Hidden posts
> 
> For more information, see the [Moderation Documentation](/bluesky-social/atproto/blob/main/packages/api/docs/moderation.md).
> 
> import { moderatePost } from '@atproto/api'
> 
> // First get the user's moderation prefs and their label definitions
> // =
> 
> const prefs = await agent.getPreferences()
> const labelDefs = await agent.getLabelDefinitions(prefs)
> 
> // We call the appropriate moderation function for the content
> // =
> 
> const postMod = moderatePost(postView, {
>   userDid: agent.session.did,
>   moderationPrefs: prefs.moderationPrefs,
>   labelDefs,
> })
> 
> // We then use the output to decide how to affect rendering
> // =
> 
> // in feeds
> if (postMod.ui('contentList').filter) {
>   // don't include in feeds
> }
> if (postMod.ui('contentList').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentList').blurs to explain)
>   if (postMod.ui('contentList').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> if (postMod.ui('contentList').alert || postMod.ui('contentList').inform) {
>   // render warnings on the post
>   // find the warnings in postMod.ui('contentList').alerts and postMod.ui('contentList').informs
> }
> 
> // viewed directly
> if (postMod.ui('contentView').filter) {
>   // don't include in feeds
> }
> if (postMod.ui('contentView').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentView').blurs to explain)
>   if (postMod.ui('contentView').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> if (postMod.ui('contentView').alert || postMod.ui('contentView').inform) {
>   // render warnings on the post
>   // find the warnings in postMod.ui('contentView').alerts and postMod.ui('contentView').informs
> }
> 
> // post embeds in all contexts
> if (postMod.ui('contentMedia').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentMedia').blurs to explain)
>   if (postMod.ui('contentMedia').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> 
> ## Advanced
> 
> [](#advanced)
> 
> ### Advanced API calls
> 
> [](#advanced-api-calls)
> 
> The methods above are convenience wrappers. It covers most but not all available methods.
> 
> The AT Protocol identifies methods and records with reverse-DNS names. You can use them on the agent as well:
> 
> const res1 = await agent.com.atproto.repo.createRecord({
>   did: alice.did,
>   collection: 'app.bsky.feed.post',
>   record: {
>     $type: 'app.bsky.feed.post',
>     text: 'Hello, world!',
>     createdAt: new Date().toISOString(),
>   },
> })
> const res2 = await agent.com.atproto.repo.listRecords({
>   repo: alice.did,
>   collection: 'app.bsky.feed.post',
> })
> 
> const res3 = await agent.app.bsky.feed.post.create(
>   { repo: alice.did },
>   {
>     text: 'Hello, world!',
>     createdAt: new Date().toISOString(),
>   },
> )
> const res4 = await agent.app.bsky.feed.post.list({ repo: alice.did })
> 
> ### Non-browser configuration
> 
> [](#non-browser-configuration)
> 
> If your environment doesn't have a built-in `fetch` implementation, you'll need to provide one. This will typically be done through a polyfill.
> 
> ### Bring your own fetch
> 
> [](#bring-your-own-fetch)
> 
> If you want to provide your own `fetch` implementation, you can do so by instantiating the sessionManager with a custom fetch implementation:
> 
> import { AtpAgent } from '@atproto/api'
> 
> const myFetch = (input: RequestInfo | URL, init?: RequestInit) => {
>   console.log('requesting', input)
>   const response = await globalThis.fetch(input, init)
>   console.log('got response', response)
>   return response
> }
> 
> const agent = new AtpAgent({
>   service: 'https://example.com',
>   fetch: myFetch,
> })
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> [![photo](https://camo.githubusercontent.com/bda2c3676213507b76185ad1b791584739dedea5aa13ddc971fd41143230c128/68747470733a2f2f7374617469632e626e6577626f6c642e6e65742f746d702f696e6469676f5f73657261632e6a706567)](https://camo.githubusercontent.com/bda2c3676213507b76185ad1b791584739dedea5aa13ddc971fd41143230c128/68747470733a2f2f7374617469632e626e6577626f6c642e6e65742f746d702f696e6469676f5f73657261632e6a706567)
> 
> ## indigo: atproto libraries and services in golang
> 
> [](#indigo-atproto-libraries-and-services-in-golang)
> 
> Some Bluesky software is developed in Typescript, and lives in the [bluesky-social/atproto](https://github.com/bluesky-social/atproto) repository. Some is developed in Go, and lives here.
> 
> ## What is in here?
> 
> [](#what-is-in-here)
> 
> **Go Services:**
> 
> * **bigsky** ([README](/bluesky-social/indigo/blob/main/cmd/bigsky/README.md)): relay reference implementation, running at `bsky.network`
> * **palomar** ([README](/bluesky-social/indigo/blob/main/cmd/palomar/README.md)): fulltext search service for [https://bsky.app](https://bsky.app/)
> * **hepa** ([README](/bluesky-social/indigo/blob/main/cmd/hepa/README.md)): auto-moderation bot for [Ozone](https://ozone.tools/)
> 
> **Go Packages:**
> 
> > ⚠️ All the packages in this repository are under active development. Features and software interfaces have not stabilized and may break or be removed.
> 
> | Package                                                    | Docs                                                                                                                                                                                                                                                                                                                                                      |
> | ---------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | api/atproto: generated types for com.atproto.\* Lexicons   | [![PkgGoDev](https://camo.githubusercontent.com/1632469fde5392f6b858e026a5be41969d8f563923a7ff1f3aedfdeddc607a6b/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f6170692f617470726f746f)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/api/atproto)                |
> | api/bsky: generated types for app.bsky.\* Lexicons         | [![PkgGoDev](https://camo.githubusercontent.com/eaf21e8f86ab5f8a7fc9241993ae5d5cccd10f5a2070e22a77fcc7fa5b88f875/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f6170692f62736b79)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/api/bsky)                         |
> | atproto/crypto: crytographic signing and key serialization | [![PkgGoDev](https://camo.githubusercontent.com/83e162c36fb08a306eb3a1e8c0a092b5f8ad9c5dd95c9ac15830e305c5cfb3e5/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f617470726f746f2f63727970746f)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/atproto/crypto)       |
> | atproto/identity: DID and handle resolution                | [![PkgGoDev](https://camo.githubusercontent.com/27d0da10955c6d294d5d1c1622b0897a44a33a44cfe3ad3d93d8e511ad76a92c/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f617470726f746f2f6964656e74697479)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/atproto/identity) |
> | atproto/syntax: string types and parsers for identifiers   | [![PkgGoDev](https://camo.githubusercontent.com/1ff3a5a270db861a1ee17940c3586752247a3b40eaad728c7247f5e42425af9e/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f617470726f746f2f73796e746178)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/atproto/syntax)       |
> | mst: Merkle Search Tree implementation                     | [![PkgGoDev](https://camo.githubusercontent.com/46a2a2d524bc7101010c93012d58f1faf86d6b4ed747c1f690e64033b3834927/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f6d7374)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/mst)                                        |
> | repo: account data storage                                 | [![PkgGoDev](https://camo.githubusercontent.com/d104d4090dd0d977545594a555d6a8ff82e2aa1bbced735696a10d9aacdc2b3a/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f7265706f)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/repo)                                     |
> | xrpc: HTTP API client                                      | [![PkgGoDev](https://camo.githubusercontent.com/3a54940458af732495e8d285f818157e61512c97ecaba5cbd9bbba867fddf5a0/68747470733a2f2f706b672e676f2e6465762f62616467652f6d6f642f6769746875622e636f6d2f626c7565736b792d736f6369616c2f696e6469676f2f78727063)](https://pkg.go.dev/mod/github.com/bluesky-social/indigo/xrpc)                                     |
> 
> The TypeScript reference implementation, including PDS and bsky AppView services, is at [bluesky-social/atproto](https://github.com/bluesky-social/atproto). Source code for the Bluesky Social client app (for web and mobile) can be found at [bluesky-social/social-app](https://github.com/bluesky-social/social-app).
> 
> ## Development Quickstart
> 
> [](#development-quickstart)
> 
> First, you will need the Go toolchain installed. We develop using the latest stable version of the language.
> 
> The Makefile provides wrapper commands for basic development:
> 
> ```
> make build
> make test
> make fmt
> make lint
> 
> ```
> 
> Individual commands can be run like:
> 
> The [HACKING](/bluesky-social/indigo/blob/main/HACKING.md) file has a list of commands and packages in this repository and some other development tips.
> 
> ## What is atproto?
> 
> [](#what-is-atproto)
> 
> _not to be confused with the [AT command set](https://en.wikipedia.org/wiki/Hayes%5Fcommand%5Fset) or [Adenosine triphosphate](https://en.wikipedia.org/wiki/Adenosine%5Ftriphosphate)_
> 
> The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by [Bluesky PBC](https://bsky.social/). Learn more at:
> 
> * [Overview and Guides](https://atproto.com/guides/overview) 👈 Best starting point
> * [Github Discussions](https://github.com/bluesky-social/atproto/discussions) 👈 Great place to ask questions
> * [Protocol Specifications](https://atproto.com/specs/atp)
> * [Blogpost on self-authenticating data structures](https://bsky.social/about/blog/3-6-2022-a-self-authenticating-social-protocol)
> 
> The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is `app.bsky.*`.
> 
> ## Contributions
> 
> [](#contributions)
> 
> > While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review.
> 
> **Rules:**
> 
> * We may not respond to your issue or PR.
> * We may close an issue or PR without much feedback.
> * We may lock discussions or contributions if our attention is getting DDOSed.
> * We do not provide support for build issues.
> 
> **Guidelines:**
> 
> * Check for existing issues before filing a new one, please.
> * Open an issue and give some time for discussion before submitting a PR.
> * Issues are for bugs & feature requests related to the golang implementation of atproto and related services.  
>    * For high-level discussions, please use the [Discussion Forum](https://github.com/bluesky-social/atproto/discussions).  
>    * For client issues, please use the relevant [social-app](https://github.com/bluesky-social/social-app) repo.
> * Stay away from PRs that:  
>    * Refactor large parts of the codebase  
>    * Add entirely new features without prior discussion  
>    * Change the tooling or libraries used without prior discussion  
>    * Introduce new unnecessary dependencies
> 
> Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth.
> 
> ## Are you a developer interested in building on atproto?
> 
> [](#are-you-a-developer-interested-in-building-on-atproto)
> 
> Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more.
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT](https://github.com/bluesky-social/indigo/blob/main/LICENSE-MIT) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE](https://github.com/bluesky-social/indigo/blob/main/LICENSE-APACHE) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> [ ![Logo of atproto SDK for Python by Midjourney'](https://github.com/MarshalX/atproto/raw/main/.github/images/logo.png) ](https://github.com/MarshalX/atproto)   
> **Autogenerated from lexicons, well type hinted, documented, sync and async SDK for Python**   
> [ Examples](https://github.com/MarshalX/atproto/tree/main/examples) •[ Documentation](https://atproto.blue/) •[ Discord Bluesky API](https://discord.gg/PCyVJXU9jN) 
> 
> ## The AT Protocol SDK
> 
> [](#the-at-protocol-sdk)
> 
> > ⚠️ Under construction. Until the 1.0.0 release compatibility between versions is not guaranteed.
> 
> Code snippet:
> 
> from atproto import Client, client_utils
> 
> 
> def main():
>     client = Client()
>     profile = client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
>     
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = client.send_post(text)
>     client.like(post.uri, post.cid)
> 
> 
> if __name__ == '__main__':
>     main()
> 
> Code snippet of async version 
> 
> import asyncio
> 
> from atproto import AsyncClient, client_utils
> 
> 
> async def main():
>     client = AsyncClient()
>     profile = await client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
> 
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = await client.send_post(text)
>     await client.like(post.uri, post.cid)
> 
>     
> if __name__ == '__main__':
>     # use run() for a higher Python version
>     asyncio.get_event_loop().run_until_complete(main())
> 
> 💬 [Direct Messages (Chats)](https://atproto.blue/en/latest/dm.html)
> 
> 🍿 [Example project with custom feed generator](https://github.com/MarshalX/bluesky-feed-generator)
> 
> 🔥 [Firehose data streaming is available](https://atproto.blue/en/latest/atproto%5Ffirehose/index.html)
> 
> 🌐 [Identity resolvers for DID and Handle](https://atproto.blue/en/latest/atproto%5Fidentity/index.html)
> 
> ### Introduction
> 
> [](#introduction)
> 
> This SDK attempts to implement everything that provides ATProto. There is support for Lexicon Schemes, XRPC clients, Firehose, Identity, DID keys, signatures, and more. All models, queries, and procedures are generated automatically. The main focus is on the lexicons of atproto.com and bsky.app, but it doesn't have a vendor lock on it. Feel free to use the code generator for your own lexicon schemes. The SDK also provides utilities to work with CID, NSID, AT URI Schemes, DAG-CBOR, CAR files, DID Documents and more.
> 
> ### Requirements
> 
> [](#requirements)
> 
> * Python 3.8 or higher.
> 
> ### Installing
> 
> [](#installing)
> 
> ### Quick start
> 
> [](#quick-start)
> 
> First of all, you need to create the instance of the XRPC Client. To do so, you have two major options: asynchronous and synchronous. The difference is only in the import and how you call the methods. If you are not familiar with async, use sync instead.
> 
> For sync:
> 
> from atproto import Client
> 
> client = Client()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # Client('https://example.com')
> 
> For async:
> 
> from atproto import AsyncClient
> 
> client = AsyncClient()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # AsyncClient('https://example.com')
> 
> In the snippets below, only the sync version will be presented.
> 
> Right after the creation of the Client instance, you will probably want to access the full API and perform actions by profile. To achieve this, you should log into the network using your handle and password. The password could be app-specific.
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> You are awesome! Now feel free to pick any high-level method that you want and try it out!
> 
> Code to send a post:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> client.send_post(text='Hello World!')
> 
> Useful links to continue:
> 
> * [List of all methods with documentation](https://atproto.readthedocs.io/en/latest/atproto%5Fclient/index.html).
> * [Examples of using the methods](https://github.com/MarshalX/atproto/tree/main/examples).
> 
> ### SDK structure
> 
> [](#sdk-structure)
> 
> The SDK is built upon the following components:
> 
> | Package           | Description                                                                 |
> | ----------------- | --------------------------------------------------------------------------- |
> | atproto           | Import shortcuts to other packages.                                         |
> | atproto\_cli      | CLI tool to generate code.                                                  |
> | atproto\_client   | XRPC Client, data models, and utils like rich text helper.                  |
> | atproto\_codegen  | Code generator of models, clients, and namespaces.                          |
> | atproto\_core     | Tools to work with NSID, AT URI Schemes, CID, CAR files, and DID Documents. |
> | atproto\_crypto   | Crypto utils like multibase, signature verification, work with DID keys.    |
> | atproto\_firehose | Firehose (data streaming) client and models.                                |
> | atproto\_identity | Identity resolvers for DID, Handle, AT Protocol data, signing keys.         |
> | atproto\_lexicon  | Lexicon parser.                                                             |
> | atproto\_server   | Server-side utils like JWT.                                                 |
> 
> I highly recommend that you use the `atproto` package to import everything that you need. It contains shortcuts to all other packages.
> 
> ### Documentation
> 
> [](#documentation)
> 
> The documentation is live at [atproto.blue](https://atproto.blue/).
> 
> ### Getting help
> 
> [](#getting-help)
> 
> You can get help in several ways:
> 
> * Report bugs, request new features by [creating an issue](https://github.com/MarshalX/atproto/issues/new).
> * Ask questions by [starting a discussion](https://github.com/MarshalX/atproto/discussions/new).
> * Ask questions in [Discord server](https://discord.gg/PCyVJXU9jN).
> 
> ### Advanced usage
> 
> [](#advanced-usage)
> 
> I'll be honest. The high-level Client that was shown in the "Quick Start" section is not a real ATProto API. This is syntax sugar built upon the real XRPC methods! The high-level methods do not cover the full needs of developers. To be able to do anything that you want, you should know how to work with low-level API. Let's dive into it!
> 
> The basics:
> 
> * Namespaces – classes that group sub-namespaces and the XRPC queries and procedures. Built upon NSID ATProto semantic.
> * Model – dataclasses for input, output, and params of the methods from namespaces. Models describe Record and all other types in the Lexicon Schemes.
> 
> #### Namespaces
> 
> [](#namespaces)
> 
> The client contains references to the root of all namespaces. It's `com` and `app` for now.
> 
> from atproto import Client
> 
> Client().com
> Client().app
> 
> To dive deeper, you can navigate using hints from your IDE. Thanks to a well-type hinted SDK, it's much easier.
> 
> from atproto import Client
> 
> Client().com.atproto.server.create_session(...)
> Client().com.atproto.sync.get_blob(...)
> Client().app.bsky.feed.get_likes(...)
> Client().app.bsky.graph.get_follows(...)
> 
> The endpoint of the path is always the method you want to call. The method presents a query or procedure in XRPC. You should not care about it much. The only thing you need to know is that the procedures require data objects. Queries could be called with or without params.
> 
> #### Records
> 
> [](#records)
> 
> In some sub-namespaces, you can find records. Such record classes provide a syntax sugar not defined in the lexicon scheme. This sugar provides a more convenient way to work with repository operations, such as creating a record, deleting a record, and so on.
> 
> Here are some available records of Bluesky records:
> 
> from atproto import Client
> 
> Client().app.bsky.feed.post
> Client().app.bsky.feed.like
> Client().app.bsky.graph.follow
> Client().app.bsky.graph.block
> Client().app.bsky.actor.profile
> # ... more
> 
> Usage example with the `post` record:
> 
> from atproto import AtUri, Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> posts = client.app.bsky.feed.post.list(client.me.did, limit=10)
> for uri, post in posts.records.items():
>     print(uri, post.text)
> 
> post = client.app.bsky.feed.post.get(client.me.did, AtUri.from_str(uri).rkey)
> print(post.value.text)
> 
> post_record = models.AppBskyFeedPost.Record(text='test record namespaces', created_at=client.get_current_time_iso())
> new_post = client.app.bsky.feed.post.create(client.me.did, post_record)
> print(new_post)
> 
> deleted_post = client.app.bsky.feed.post.delete(client.me.did, AtUri.from_str(new_post.uri).rkey)
> print(deleted_post)
> 
> Please note that not all repository operations are covered by these syntax sugars. You can always use the low-level methods to perform any desired action. One such action is updating a record.
> 
> #### Models
> 
> [](#models)
> 
> To deal with methods, we need to deal with models! Models are available in the `models` module and have NSID-based aliases. Let's take a look at it.
> 
> from atproto import models
> 
> models.ComAtprotoIdentityResolveHandle
> models.AppBskyFeedPost
> models.AppBskyActorGetProfile
> # 90+ more...
> 
> The model classes in the "models" aliases could be:
> 
> * Data model
> * Params model
> * Response model
> * Sugar response model
> * Record model
> * Type model
> 
> The only thing you need to know is how to create instances of models. You won't need to work as model-creator for all models. For example, the SDK will create Response models for you.
> 
> There are a few ways to create the instance of a model:
> 
> * Dict-based
> * Class-based
> 
> The instances of any data and params models should be passed as arguments to the methods that were described above.
> 
> Dict-based:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> # The params model will be created automatically internally for you!
> print(client.com.atproto.identity.resolve_handle({'handle': 'marshal.dev'}))
> 
> Class-based:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> params = models.ComAtprotoIdentityResolveHandle.Params(handle='marshal.dev')
> print(client.com.atproto.identity.resolve_handle(params))
> 
> Tip: look at the typehint of the method to figure out the name and the path to the input/data model!
> 
> Pro Tip: use IDE autocompletion to find necessary models! Just start typing the method name right after the dot (`models.{type method name in camel case`).
> 
> Models can be nested to the innermost rings of hell. Be ready for it!
> 
> This is how we can send a post with an image using low-level XRPC Client:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> with open('cat.jpg', 'rb') as f:
>     img_data = f.read()
> 
>     upload = client.upload_blob(img_data)
>     images = [models.AppBskyEmbedImages.Image(alt='Img alt', image=upload.blob)]
>     embed = models.AppBskyEmbedImages.Main(images=images)
> 
>     client.com.atproto.repo.create_record(
>         models.ComAtprotoRepoCreateRecord.Data(
>             repo=client.me.did,
>             collection=models.ids.AppBskyFeedPost,
>             record=models.AppBskyFeedPost.Record(
>                 created_at=client.get_current_time_iso(), text='Text of the post', embed=embed
>             ),
>         )
>     )
> 
>     # of course, you can use the syntax sugar here instead
>     post = models.AppBskyFeedPost.Record(text='Text of the post', embed=embed, created_at=client.get_current_time_iso())
>     client.app.bsky.feed.post.create(client.me.did, post)
>     # or even high-level client
>     client.send_image(text='Text of the post', image=img_data, image_alt='Img alt')
>     # these three methods are equivalent
> 
> I hope you are not scared. May the Force be with you. Good luck!
> 
> ### Change log
> 
> [](#change-log)
> 
> The full change log is available in [CHANGES.md](https://github.com/MarshalX/atproto/blob/main/CHANGES.md).
> 
> ### Contributing
> 
> [](#contributing)
> 
> Contributions of all sizes are welcome. The contribution guidelines will be presented later.
> 
> ### License
> 
> [](#license)
> 
> MIT
> 
> [ View this page ](https://github.com/MarshalX/atproto/blob/main/docs/source/index.rst?plain=true "View this page") 
> 
> [ Edit this page ](https://github.com/MarshalX/atproto/edit/main/docs/source/index.rst "Edit this page") 
> 
> Toggle table of contents sidebar
> 
> [ ![Logo of atproto SDK for Python by Midjourney'](https://github.com/MarshalX/atproto/raw/main/.github/images/logo.png) ](https://github.com/MarshalX/atproto)   
> **Autogenerated from lexicons, well type hinted, documented, sync and async SDK for Python**   
> [ Examples](https://github.com/MarshalX/atproto/tree/main/examples) •[ Documentation](https://atproto.blue/) •[ Discord Bluesky API](https://discord.gg/PCyVJXU9jN) 
> 
> ## The AT Protocol SDK[¶](#the-at-protocol-sdk "Permalink to this heading")
> 
> > ⚠️ Under construction. Until the 1.0.0 release compatibility between versions is not guaranteed.
> 
> Code snippet:
> 
> from atproto import Client, client_utils
> 
> 
> def main():
>     client = Client()
>     profile = client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
> 
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = client.send_post(text)
>     client.like(post.uri, post.cid)
> 
> 
> if __name__ == '__main__':
>     main()
> 
> Code snippet of async version 
> 
> import asyncio
> 
> from atproto import AsyncClient, client_utils
> 
> 
> async def main():
>     client = AsyncClient()
>     profile = await client.login('my-handle', 'my-password')
>     print('Welcome,', profile.display_name)
> 
>     text = client_utils.TextBuilder().text('Hello World from ').link('Python SDK', 'https://atproto.blue')
>     post = await client.send_post(text)
>     await client.like(post.uri, post.cid)
> 
> 
> if __name__ == '__main__':
>     # use run() for a higher Python version
>     asyncio.get_event_loop().run_until_complete(main())
> 
> 💬 [Direct Messages (Chats)](https://atproto.blue/en/latest/dm.html)
> 
> 🍿 [Example project with custom feed generator](https://github.com/MarshalX/bluesky-feed-generator)
> 
> 🔥 [Firehose data streaming is available](https://atproto.blue/en/latest/atproto%5Ffirehose/index.html)
> 
> 🌐 [Identity resolvers for DID and Handle](https://atproto.blue/en/latest/atproto%5Fidentity/index.html)
> 
> ### Introduction[¶](#introduction "Permalink to this heading")
> 
> This SDK attempts to implement everything that provides ATProto. There is support for Lexicon Schemes, XRPC clients, Firehose, Identity, DID keys, signatures, and more. All models, queries, and procedures are generated automatically. The main focus is on the lexicons of atproto.com and bsky.app, but it doesn’t have a vendor lock on it. Feel free to use the code generator for your own lexicon schemes. The SDK also provides utilities to work with CID, NSID, AT URI Schemes, DAG-CBOR, CAR files, DID Documents and more.
> 
> ### Requirements[¶](#requirements "Permalink to this heading")
> 
> * Python 3.8 or higher.
> 
> ### Installing[¶](#installing "Permalink to this heading")
> 
> ### Quick start[¶](#quick-start "Permalink to this heading")
> 
> First of all, you need to create the instance of the XRPC Client. To do so, you have two major options: asynchronous and synchronous. The difference is only in the import and how you call the methods. If you are not familiar with async, use sync instead.
> 
> For sync:
> 
> from atproto import Client
> 
> client = Client()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # Client('https://example.com')
> 
> For async:
> 
> from atproto import AsyncClient
> 
> client = AsyncClient()
> # By default, it uses the server of bsky.app. To change this behavior, pass the base api URL to constructor
> # AsyncClient('https://example.com')
> 
> In the snippets below, only the sync version will be presented.
> 
> Right after the creation of the Client instance, you will probably want to access the full API and perform actions by profile. To achieve this, you should log into the network using your handle and password. The password could be app-specific.
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> You are awesome! Now feel free to pick any high-level method that you want and try it out!
> 
> Code to send a post:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> client.send_post(text='Hello World!')
> 
> Useful links to continue:
> 
> * [List of all methods with documentation](https://atproto.readthedocs.io/en/latest/atproto%5Fclient/index.html).
> * [Examples of using the methods](https://github.com/MarshalX/atproto/tree/main/examples).
> 
> ### SDK structure[¶](#sdk-structure "Permalink to this heading")
> 
> The SDK is built upon the following components:
> 
> | Package           | Description                                                                 |
> | ----------------- | --------------------------------------------------------------------------- |
> | atproto           | Import shortcuts to other packages.                                         |
> | atproto\_cli      | CLI tool to generate code.                                                  |
> | atproto\_client   | XRPC Client, data models, and utils like rich text helper.                  |
> | atproto\_codegen  | Code generator of models, clients, and namespaces.                          |
> | atproto\_core     | Tools to work with NSID, AT URI Schemes, CID, CAR files, and DID Documents. |
> | atproto\_crypto   | Crypto utils like multibase, signature verification, work with DID keys.    |
> | atproto\_firehose | Firehose (data streaming) client and models.                                |
> | atproto\_identity | Identity resolvers for DID, Handle, AT Protocol data, signing keys.         |
> | atproto\_lexicon  | Lexicon parser.                                                             |
> | atproto\_server   | Server-side utils like JWT.                                                 |
> 
> I highly recommend that you use the `atproto` package to import everything that you need. It contains shortcuts to all other packages.
> 
> ### Documentation[¶](#documentation "Permalink to this heading")
> 
> The documentation is live at [atproto.blue](https://atproto.blue/).
> 
> ### Getting help[¶](#getting-help "Permalink to this heading")
> 
> You can get help in several ways:
> 
> * Report bugs, request new features by [creating an issue](https://github.com/MarshalX/atproto/issues/new).
> * Ask questions by [starting a discussion](https://github.com/MarshalX/atproto/discussions/new).
> * Ask questions in [Discord server](https://discord.gg/PCyVJXU9jN).
> 
> ### Advanced usage[¶](#advanced-usage "Permalink to this heading")
> 
> I’ll be honest. The high-level Client that was shown in the “Quick Start” section is not a real ATProto API. This is syntax sugar built upon the real XRPC methods! The high-level methods do not cover the full needs of developers. To be able to do anything that you want, you should know how to work with low-level API. Let’s dive into it!
> 
> The basics:
> 
> * Namespaces – classes that group sub-namespaces and the XRPC queries and procedures. Built upon NSID ATProto semantic.
> * Model – dataclasses for input, output, and params of the methods from namespaces. Models describe Record and all other types in the Lexicon Schemes.
> 
> #### Namespaces[¶](#namespaces "Permalink to this heading")
> 
> The client contains references to the root of all namespaces. It’s `com` and `app` for now.
> 
> from atproto import Client
> 
> Client().com
> Client().app
> 
> To dive deeper, you can navigate using hints from your IDE. Thanks to a well-type hinted SDK, it’s much easier.
> 
> from atproto import Client
> 
> Client().com.atproto.server.create_session(...)
> Client().com.atproto.sync.get_blob(...)
> Client().app.bsky.feed.get_likes(...)
> Client().app.bsky.graph.get_follows(...)
> 
> The endpoint of the path is always the method you want to call. The method presents a query or procedure in XRPC. You should not care about it much. The only thing you need to know is that the procedures require data objects. Queries could be called with or without params.
> 
> #### Records[¶](#records "Permalink to this heading")
> 
> In some sub-namespaces, you can find records. Such record classes provide a syntax sugar not defined in the lexicon scheme. This sugar provides a more convenient way to work with repository operations, such as creating a record, deleting a record, and so on.
> 
> Here are some available records of Bluesky records:
> 
> from atproto import Client
> 
> Client().app.bsky.feed.post
> Client().app.bsky.feed.like
> Client().app.bsky.graph.follow
> Client().app.bsky.graph.block
> Client().app.bsky.actor.profile
> # ... more
> 
> Usage example with the `post` record:
> 
> from atproto import AtUri, Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> posts = client.app.bsky.feed.post.list(client.me.did, limit=10)
> for uri, post in posts.records.items():
>     print(uri, post.text)
> 
> post = client.app.bsky.feed.post.get(client.me.did, AtUri.from_str(uri).rkey)
> print(post.value.text)
> 
> post_record = models.AppBskyFeedPost.Record(text='test record namespaces', created_at=client.get_current_time_iso())
> new_post = client.app.bsky.feed.post.create(client.me.did, post_record)
> print(new_post)
> 
> deleted_post = client.app.bsky.feed.post.delete(client.me.did, AtUri.from_str(new_post.uri).rkey)
> print(deleted_post)
> 
> Please note that not all repository operations are covered by these syntax sugars. You can always use the low-level methods to perform any desired action. One such action is updating a record.
> 
> #### Models[¶](#models "Permalink to this heading")
> 
> To deal with methods, we need to deal with models! Models are available in the `models` module and have NSID-based aliases. Let’s take a look at it.
> 
> from atproto import models
> 
> models.ComAtprotoIdentityResolveHandle
> models.AppBskyFeedPost
> models.AppBskyActorGetProfile
> # 90+ more...
> 
> The model classes in the “models” aliases could be:
> 
> * Data model
> * Params model
> * Response model
> * Sugar response model
> * Record model
> * Type model
> 
> The only thing you need to know is how to create instances of models. You won’t need to work as model-creator for all models. For example, the SDK will create Response models for you.
> 
> There are a few ways to create the instance of a model:
> 
> * Dict-based
> * Class-based
> 
> The instances of any data and params models should be passed as arguments to the methods that were described above.
> 
> Dict-based:
> 
> from atproto import Client
> 
> client = Client()
> client.login('my-username', 'my-password')
> # The params model will be created automatically internally for you!
> print(client.com.atproto.identity.resolve_handle({'handle': 'marshal.dev'}))
> 
> Class-based:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> params = models.ComAtprotoIdentityResolveHandle.Params(handle='marshal.dev')
> print(client.com.atproto.identity.resolve_handle(params))
> 
> Tip: look at the typehint of the method to figure out the name and the path to the input/data model!
> 
> Pro Tip: use IDE autocompletion to find necessary models! Just start typing the method name right after the dot (`models.{type method name in camel case`).
> 
> Models can be nested to the innermost rings of hell. Be ready for it!
> 
> This is how we can send a post with an image using low-level XRPC Client:
> 
> from atproto import Client, models
> 
> client = Client()
> client.login('my-username', 'my-password')
> 
> with open('cat.jpg', 'rb') as f:
>     img_data = f.read()
> 
>     upload = client.upload_blob(img_data)
>     images = [models.AppBskyEmbedImages.Image(alt='Img alt', image=upload.blob)]
>     embed = models.AppBskyEmbedImages.Main(images=images)
> 
>     client.com.atproto.repo.create_record(
>         models.ComAtprotoRepoCreateRecord.Data(
>             repo=client.me.did,
>             collection=models.ids.AppBskyFeedPost,
>             record=models.AppBskyFeedPost.Record(
>                 created_at=client.get_current_time_iso(), text='Text of the post', embed=embed
>             ),
>         )
>     )
> 
>     # of course, you can use the syntax sugar here instead
>     post = models.AppBskyFeedPost.Record(text='Text of the post', embed=embed, created_at=client.get_current_time_iso())
>     client.app.bsky.feed.post.create(client.me.did, post)
>     # or even high-level client
>     client.send_image(text='Text of the post', image=img_data, image_alt='Img alt')
>     # these three methods are equivalent
> 
> I hope you are not scared. May the Force be with you. Good luck!
> 
> ### Change log[¶](#change-log "Permalink to this heading")
> 
> The full change log is available in [CHANGES.md](https://github.com/MarshalX/atproto/blob/main/CHANGES.md).
> 
> ### Contributing[¶](#contributing "Permalink to this heading")
> 
> Contributions of all sizes are welcome. The contribution guidelines will be presented later.
> 
> ### License[¶](#license "Permalink to this heading")
> 
> MIT
> 
> * [Getting Started](readme.html)  
>    * [The AT Protocol SDK](about:blank/readme.html#the-at-protocol-sdk)  
>          * [Introduction](readme.content.html)  
>          * [Requirements](about:blank/readme.content.html#requirements)  
>          * [Installing](about:blank/readme.content.html#installing)  
>          * [Quick start](about:blank/readme.content.html#quick-start)  
>          * [SDK structure](about:blank/readme.content.html#sdk-structure)  
>          * [Documentation](about:blank/readme.content.html#documentation)  
>          * [Getting help](about:blank/readme.content.html#getting-help)  
>          * [Advanced usage](about:blank/readme.content.html#advanced-usage)  
>                   * [Namespaces](about:blank/readme.content.html#namespaces)  
>                   * [Records](about:blank/readme.content.html#records)  
>                   * [Models](about:blank/readme.content.html#models)
> * [Examples](https://github.com/MarshalX/atproto/tree/main/examples)
> 
> SDK
> 
> * [Direct Messages (Chats)](dm.html)  
>    * [Example](about:blank/dm.html#example)
> * [Client (API)](atproto%5Fclient/index.html)  
>    * [AsyncClient](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient)  
>          * [AsyncClient.AtprotoServiceType](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.AtprotoServiceType)  
>                   * [AsyncClient.AtprotoServiceType.ATPROTO\_LABELER](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.AtprotoServiceType.ATPROTO%5FLABELER)  
>                   * [AsyncClient.AtprotoServiceType.BSKY\_CHAT](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.AtprotoServiceType.BSKY%5FCHAT)  
>          * [AsyncClient.BSKY\_CHAT\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.BSKY%5FCHAT%5FDID)  
>          * [AsyncClient.BSKY\_LABELER\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.BSKY%5FLABELER%5FDID)  
>          * [AsyncClient.app](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.app)  
>          * [AsyncClient.chat](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.chat)  
>          * [AsyncClient.clone()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.clone)  
>          * [AsyncClient.com](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.com)  
>          * [AsyncClient.configure\_labelers\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.configure%5Flabelers%5Fheader)  
>          * [AsyncClient.configure\_proxy\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.configure%5Fproxy%5Fheader)  
>          * [AsyncClient.delete\_follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Ffollow)  
>          * [AsyncClient.delete\_like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Flike)  
>          * [AsyncClient.delete\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Fpost)  
>          * [AsyncClient.delete\_repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.delete%5Frepost)  
>          * [AsyncClient.export\_session\_string()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.export%5Fsession%5Fstring)  
>          * [AsyncClient.follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.follow)  
>          * [AsyncClient.get\_author\_feed()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fauthor%5Ffeed)  
>          * [AsyncClient.get\_current\_time()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fcurrent%5Ftime)  
>          * [AsyncClient.get\_current\_time\_iso()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fcurrent%5Ftime%5Fiso)  
>          * [AsyncClient.get\_followers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ffollowers)  
>          * [AsyncClient.get\_follows()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ffollows)  
>          * [AsyncClient.get\_likes()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Flikes)  
>          * [AsyncClient.get\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fpost)  
>          * [AsyncClient.get\_post\_thread()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fpost%5Fthread)  
>          * [AsyncClient.get\_posts()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fposts)  
>          * [AsyncClient.get\_profile()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fprofile)  
>          * [AsyncClient.get\_profiles()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Fprofiles)  
>          * [AsyncClient.get\_reposted\_by()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Freposted%5Fby)  
>          * [AsyncClient.get\_time\_from\_timestamp()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ftime%5Ffrom%5Ftimestamp)  
>          * [AsyncClient.get\_timeline()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.get%5Ftimeline)  
>          * [AsyncClient.invoke\_procedure()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.invoke%5Fprocedure)  
>          * [AsyncClient.invoke\_query()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.invoke%5Fquery)  
>          * [AsyncClient.like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.like)  
>          * [AsyncClient.login()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.login)  
>          * [AsyncClient.mute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.mute)  
>          * [AsyncClient.on\_session\_change()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.on%5Fsession%5Fchange)  
>          * [AsyncClient.post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.post)  
>          * [AsyncClient.repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.repost)  
>          * [AsyncClient.request](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.request)  
>          * [AsyncClient.resolve\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.resolve%5Fhandle)  
>          * [AsyncClient.send\_image()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fimage)  
>          * [AsyncClient.send\_images()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fimages)  
>          * [AsyncClient.send\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fpost)  
>          * [AsyncClient.send\_video()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.send%5Fvideo)  
>          * [AsyncClient.tools](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.tools)  
>          * [AsyncClient.unfollow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unfollow)  
>          * [AsyncClient.unlike()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unlike)  
>          * [AsyncClient.unmute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unmute)  
>          * [AsyncClient.unrepost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unrepost)  
>          * [AsyncClient.unsend()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.unsend)  
>          * [AsyncClient.update\_base\_url()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.update%5Fbase%5Furl)  
>          * [AsyncClient.update\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.update%5Fhandle)  
>          * [AsyncClient.upload\_blob()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.upload%5Fblob)  
>          * [AsyncClient.with\_bsky\_chat\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Fbsky%5Fchat%5Fproxy)  
>          * [AsyncClient.with\_bsky\_labeler()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Fbsky%5Flabeler)  
>          * [AsyncClient.with\_labelers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Flabelers)  
>          * [AsyncClient.with\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.AsyncClient.with%5Fproxy)  
>    * [Client](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client)  
>          * [Client.AtprotoServiceType](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.AtprotoServiceType)  
>                   * [Client.AtprotoServiceType.ATPROTO\_LABELER](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.AtprotoServiceType.ATPROTO%5FLABELER)  
>                   * [Client.AtprotoServiceType.BSKY\_CHAT](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.AtprotoServiceType.BSKY%5FCHAT)  
>          * [Client.BSKY\_CHAT\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.BSKY%5FCHAT%5FDID)  
>          * [Client.BSKY\_LABELER\_DID](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.BSKY%5FLABELER%5FDID)  
>          * [Client.app](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.app)  
>          * [Client.chat](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.chat)  
>          * [Client.clone()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.clone)  
>          * [Client.com](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.com)  
>          * [Client.configure\_labelers\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.configure%5Flabelers%5Fheader)  
>          * [Client.configure\_proxy\_header()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.configure%5Fproxy%5Fheader)  
>          * [Client.delete\_follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Ffollow)  
>          * [Client.delete\_like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Flike)  
>          * [Client.delete\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Fpost)  
>          * [Client.delete\_repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.delete%5Frepost)  
>          * [Client.export\_session\_string()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.export%5Fsession%5Fstring)  
>          * [Client.follow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.follow)  
>          * [Client.get\_author\_feed()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fauthor%5Ffeed)  
>          * [Client.get\_current\_time()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fcurrent%5Ftime)  
>          * [Client.get\_current\_time\_iso()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fcurrent%5Ftime%5Fiso)  
>          * [Client.get\_followers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ffollowers)  
>          * [Client.get\_follows()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ffollows)  
>          * [Client.get\_likes()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Flikes)  
>          * [Client.get\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fpost)  
>          * [Client.get\_post\_thread()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fpost%5Fthread)  
>          * [Client.get\_posts()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fposts)  
>          * [Client.get\_profile()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fprofile)  
>          * [Client.get\_profiles()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Fprofiles)  
>          * [Client.get\_reposted\_by()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Freposted%5Fby)  
>          * [Client.get\_time\_from\_timestamp()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ftime%5Ffrom%5Ftimestamp)  
>          * [Client.get\_timeline()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.get%5Ftimeline)  
>          * [Client.invoke\_procedure()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.invoke%5Fprocedure)  
>          * [Client.invoke\_query()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.invoke%5Fquery)  
>          * [Client.like()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.like)  
>          * [Client.login()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.login)  
>          * [Client.me](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.me)  
>          * [Client.mute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.mute)  
>          * [Client.on\_session\_change()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.on%5Fsession%5Fchange)  
>          * [Client.post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.post)  
>          * [Client.repost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.repost)  
>          * [Client.request](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.request)  
>          * [Client.resolve\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.resolve%5Fhandle)  
>          * [Client.send\_image()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fimage)  
>          * [Client.send\_images()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fimages)  
>          * [Client.send\_post()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fpost)  
>          * [Client.send\_video()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.send%5Fvideo)  
>          * [Client.tools](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.tools)  
>          * [Client.unfollow()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unfollow)  
>          * [Client.unlike()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unlike)  
>          * [Client.unmute()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unmute)  
>          * [Client.unrepost()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unrepost)  
>          * [Client.unsend()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.unsend)  
>          * [Client.update\_base\_url()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.update%5Fbase%5Furl)  
>          * [Client.update\_handle()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.update%5Fhandle)  
>          * [Client.upload\_blob()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.upload%5Fblob)  
>          * [Client.with\_bsky\_chat\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Fbsky%5Fchat%5Fproxy)  
>          * [Client.with\_bsky\_labeler()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Fbsky%5Flabeler)  
>          * [Client.with\_labelers()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Flabelers)  
>          * [Client.with\_proxy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Client.with%5Fproxy)  
>    * [Session](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session)  
>          * [Session.access\_jwt](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.access%5Fjwt)  
>          * [Session.access\_jwt\_payload](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.access%5Fjwt%5Fpayload)  
>          * [Session.copy()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.copy)  
>          * [Session.decode()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.decode)  
>          * [Session.did](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.did)  
>          * [Session.encode()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.encode)  
>          * [Session.export()](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.export)  
>          * [Session.handle](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.handle)  
>          * [Session.pds\_endpoint](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.pds%5Fendpoint)  
>          * [Session.refresh\_jwt](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.refresh%5Fjwt)  
>          * [Session.refresh\_jwt\_payload](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.Session.refresh%5Fjwt%5Fpayload)  
>    * [SessionEvent](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent)  
>          * [SessionEvent.CREATE](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent.CREATE)  
>          * [SessionEvent.IMPORT](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent.IMPORT)  
>          * [SessionEvent.REFRESH](about:blank/atproto%5Fclient/index.html#atproto%5Fclient.SessionEvent.REFRESH)  
>    * [Submodules](about:blank/atproto%5Fclient/index.html#submodules)  
>          * [Clients](atproto%5Fclient/clients.html)  
>                   * [Submodules](about:blank/atproto%5Fclient/clients.html#submodules)  
>          * [Namespace](atproto%5Fclient/namespace.html)  
>                   * [AppBskyActorNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyActorNamespace)  
>                   * [AppBskyActorProfileRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyActorProfileRecord)  
>                   * [AppBskyFeedGeneratorRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedGeneratorRecord)  
>                   * [AppBskyFeedLikeRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedLikeRecord)  
>                   * [AppBskyFeedNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedNamespace)  
>                   * [AppBskyFeedPostRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedPostRecord)  
>                   * [AppBskyFeedPostgateRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedPostgateRecord)  
>                   * [AppBskyFeedRepostRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedRepostRecord)  
>                   * [AppBskyFeedThreadgateRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyFeedThreadgateRecord)  
>                   * [AppBskyGraphBlockRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphBlockRecord)  
>                   * [AppBskyGraphFollowRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphFollowRecord)  
>                   * [AppBskyGraphListRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphListRecord)  
>                   * [AppBskyGraphListblockRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphListblockRecord)  
>                   * [AppBskyGraphListitemRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphListitemRecord)  
>                   * [AppBskyGraphNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphNamespace)  
>                   * [AppBskyGraphStarterpackRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyGraphStarterpackRecord)  
>                   * [AppBskyLabelerNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyLabelerNamespace)  
>                   * [AppBskyLabelerServiceRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyLabelerServiceRecord)  
>                   * [AppBskyNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyNamespace)  
>                   * [AppBskyNotificationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyNotificationNamespace)  
>                   * [AppBskyUnspeccedNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyUnspeccedNamespace)  
>                   * [AppBskyVideoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppBskyVideoNamespace)  
>                   * [AppNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.AppNamespace)  
>                   * [ChatBskyActorDeclarationRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyActorDeclarationRecord)  
>                   * [ChatBskyActorNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyActorNamespace)  
>                   * [ChatBskyConvoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyConvoNamespace)  
>                   * [ChatBskyModerationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyModerationNamespace)  
>                   * [ChatBskyNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatBskyNamespace)  
>                   * [ChatNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ChatNamespace)  
>                   * [ComAtprotoAdminNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoAdminNamespace)  
>                   * [ComAtprotoIdentityNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoIdentityNamespace)  
>                   * [ComAtprotoLabelNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoLabelNamespace)  
>                   * [ComAtprotoLexiconNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoLexiconNamespace)  
>                   * [ComAtprotoLexiconSchemaRecord](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoLexiconSchemaRecord)  
>                   * [ComAtprotoModerationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoModerationNamespace)  
>                   * [ComAtprotoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoNamespace)  
>                   * [ComAtprotoRepoNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoRepoNamespace)  
>                   * [ComAtprotoServerNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoServerNamespace)  
>                   * [ComAtprotoSyncNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoSyncNamespace)  
>                   * [ComAtprotoTempNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComAtprotoTempNamespace)  
>                   * [ComNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ComNamespace)  
>                   * [ToolsNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsNamespace)  
>                   * [ToolsOzoneCommunicationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneCommunicationNamespace)  
>                   * [ToolsOzoneModerationNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneModerationNamespace)  
>                   * [ToolsOzoneNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneNamespace)  
>                   * [ToolsOzoneServerNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneServerNamespace)  
>                   * [ToolsOzoneSetNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneSetNamespace)  
>                   * [ToolsOzoneSettingNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneSettingNamespace)  
>                   * [ToolsOzoneSignatureNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneSignatureNamespace)  
>                   * [ToolsOzoneTeamNamespace](about:blank/atproto%5Fclient/namespace.html#atproto%5Fclient.namespaces.sync%5Fns.ToolsOzoneTeamNamespace)  
>          * [Models](atproto%5Fclient/models.html)  
>                   * [Submodules](about:blank/atproto%5Fclient/models.html#submodules)  
>          * [Auth](atproto%5Fclient/auth.html)  
>                   * [Login](about:blank/atproto%5Fclient/auth.html#login)  
>                   * [Session string](about:blank/atproto%5Fclient/auth.html#session-string)  
>          * [String Formats](atproto%5Fclient/string%5Fformats.html)  
>                   * [Overview](about:blank/atproto%5Fclient/string%5Fformats.html#overview)  
>                   * [Supported String Formats](about:blank/atproto%5Fclient/string%5Fformats.html#supported-string-formats)  
>                   * [Using Validation in Your Code](about:blank/atproto%5Fclient/string%5Fformats.html#using-validation-in-your-code)  
>          * [Utils](atproto%5Fclient/utils/index.html)  
>                   * [Text Builder (rich text)](atproto%5Fclient/utils/text%5Fbuilder.html)
> * [Core](atproto%5Fcore/index.html)  
>    * [Submodules](about:blank/atproto%5Fcore/index.html#submodules)  
>          * [NSID (NameSpaced ID)](atproto%5Fcore/nsid.html)  
>                   * [NSID](about:blank/atproto%5Fcore/nsid.html#atproto%5Fcore.nsid.NSID)  
>                   * [validate\_nsid()](about:blank/atproto%5Fcore/nsid.html#atproto%5Fcore.nsid.validate%5Fnsid)  
>          * [CID decoder](atproto%5Fcore/cid.html)  
>                   * [CID](about:blank/atproto%5Fcore/cid.html#atproto%5Fcore.cid.CID)  
>          * [AT URI Scheme](atproto%5Fcore/uri.html)  
>                   * [AtUri](about:blank/atproto%5Fcore/uri.html#atproto%5Fcore.uri.AtUri)  
>          * [CAR reader](atproto%5Fcore/car.html)  
>                   * [CAR](about:blank/atproto%5Fcore/car.html#atproto%5Fcore.car.CAR)  
>          * [DAG-CBOR](atproto%5Fcore/cbor.html)  
>                   * [decode\_dag()](about:blank/atproto%5Fcore/cbor.html#atproto%5Fcore.cbor.decode%5Fdag)  
>                   * [decode\_dag\_multi()](about:blank/atproto%5Fcore/cbor.html#atproto%5Fcore.cbor.decode%5Fdag%5Fmulti)  
>          * [DID Document](atproto%5Fcore/did%5Fdoc.html)  
>                   * [DidDocument](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.DidDocument)  
>                   * [Service](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.Service)  
>                   * [SigningKey](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.SigningKey)  
>                   * [VerificationMethod](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.VerificationMethod)  
>                   * [is\_valid\_did\_doc()](about:blank/atproto%5Fcore/did%5Fdoc.html#atproto%5Fcore.did%5Fdoc.is%5Fvalid%5Fdid%5Fdoc)
> * [Firehose (data streaming)](atproto%5Ffirehose/index.html)  
>    * [AsyncFirehoseSubscribeLabelsClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient)  
>          * [AsyncFirehoseSubscribeLabelsClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient.start)  
>          * [AsyncFirehoseSubscribeLabelsClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient.stop)  
>          * [AsyncFirehoseSubscribeLabelsClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeLabelsClient.update%5Fparams)  
>    * [AsyncFirehoseSubscribeReposClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient)  
>          * [AsyncFirehoseSubscribeReposClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient.start)  
>          * [AsyncFirehoseSubscribeReposClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient.stop)  
>          * [AsyncFirehoseSubscribeReposClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.AsyncFirehoseSubscribeReposClient.update%5Fparams)  
>    * [FirehoseSubscribeLabelsClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient)  
>          * [FirehoseSubscribeLabelsClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient.start)  
>          * [FirehoseSubscribeLabelsClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient.stop)  
>          * [FirehoseSubscribeLabelsClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeLabelsClient.update%5Fparams)  
>    * [FirehoseSubscribeReposClient](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient)  
>          * [FirehoseSubscribeReposClient.start()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient.start)  
>          * [FirehoseSubscribeReposClient.stop()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient.stop)  
>          * [FirehoseSubscribeReposClient.update\_params()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.FirehoseSubscribeReposClient.update%5Fparams)  
>    * [parse\_subscribe\_labels\_message()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.parse%5Fsubscribe%5Flabels%5Fmessage)  
>    * [parse\_subscribe\_repos\_message()](about:blank/atproto%5Ffirehose/index.html#atproto%5Ffirehose.parse%5Fsubscribe%5Frepos%5Fmessage)  
>    * [Submodules](about:blank/atproto%5Ffirehose/index.html#submodules)  
>          * [Frame models](atproto%5Ffirehose/models.html)  
>                   * [ErrorFrame](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.ErrorFrame)  
>                   * [ErrorFrameBody](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.ErrorFrameBody)  
>                   * [ErrorFrameHeader](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.ErrorFrameHeader)  
>                   * [Frame](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.Frame)  
>                   * [FrameHeader](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.FrameHeader)  
>                   * [FrameType](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.FrameType)  
>                   * [MessageFrame](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.MessageFrame)  
>                   * [MessageFrameHeader](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.MessageFrameHeader)  
>                   * [parse\_frame()](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.parse%5Fframe)  
>                   * [parse\_frame\_header()](about:blank/atproto%5Ffirehose/models.html#atproto%5Ffirehose.models.parse%5Fframe%5Fheader)
> * [Identity (DID and Handle resolvers)](atproto%5Fidentity/index.html)  
>    * [AsyncIdResolver](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.AsyncIdResolver)  
>          * [AsyncIdResolver.did](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.AsyncIdResolver.did)  
>          * [AsyncIdResolver.handle](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.AsyncIdResolver.handle)  
>    * [IdResolver](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.IdResolver)  
>          * [IdResolver.did](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.IdResolver.did)  
>          * [IdResolver.handle](about:blank/atproto%5Fidentity/index.html#atproto%5Fidentity.resolver.IdResolver.handle)  
>    * [Submodules](about:blank/atproto%5Fidentity/index.html#submodules)  
>          * [ID Resolver](atproto%5Fidentity/id%5Fresolver.html)  
>                   * [AsyncIdResolver](about:blank/atproto%5Fidentity/id%5Fresolver.html#atproto%5Fidentity.resolver.AsyncIdResolver)  
>                   * [IdResolver](about:blank/atproto%5Fidentity/id%5Fresolver.html#atproto%5Fidentity.resolver.IdResolver)  
>          * [Handle Resolver](atproto%5Fidentity/handle%5Fresolver.html)  
>                   * [AsyncHandleResolver](about:blank/atproto%5Fidentity/handle%5Fresolver.html#atproto%5Fidentity.handle.resolver.AsyncHandleResolver)  
>                   * [HandleResolver](about:blank/atproto%5Fidentity/handle%5Fresolver.html#atproto%5Fidentity.handle.resolver.HandleResolver)  
>          * [DID Resolver](atproto%5Fidentity/did%5Fresolver.html)  
>                   * [AsyncDidResolver](about:blank/atproto%5Fidentity/did%5Fresolver.html#atproto%5Fidentity.did.resolver.AsyncDidResolver)  
>                   * [DidResolver](about:blank/atproto%5Fidentity/did%5Fresolver.html#atproto%5Fidentity.did.resolver.DidResolver)  
>          * [Cache](atproto%5Fidentity/cache.html)  
>                   * [AsyncDidInMemoryCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.in%5Fmemory%5Fcache.AsyncDidInMemoryCache)  
>                   * [DidInMemoryCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.in%5Fmemory%5Fcache.DidInMemoryCache)  
>                   * [AsyncDidBaseCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.base%5Fcache.AsyncDidBaseCache)  
>                   * [DidBaseCache](about:blank/atproto%5Fidentity/cache.html#atproto%5Fidentity.cache.base%5Fcache.DidBaseCache)  
>          * [AT Protocol Data](atproto%5Fidentity/atproto%5Fdata.html)  
>                   * [AtprotoData](about:blank/atproto%5Fidentity/atproto%5Fdata.html#atproto%5Fidentity.did.atproto%5Fdata.AtprotoData)  
>                   * [ensure\_atproto\_document()](about:blank/atproto%5Fidentity/atproto%5Fdata.html#atproto%5Fidentity.did.atproto%5Fdata.ensure%5Fatproto%5Fdocument)  
>                   * [ensure\_atproto\_key()](about:blank/atproto%5Fidentity/atproto%5Fdata.html#atproto%5Fidentity.did.atproto%5Fdata.ensure%5Fatproto%5Fkey)
> * [Crypto](atproto%5Fcrypto/index.html)  
>    * [Submodules](about:blank/atproto%5Fcrypto/index.html#submodules)  
>          * [DID](atproto%5Fcrypto/did.html)  
>                   * [Multikey](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.Multikey)  
>                   * [format\_did\_key()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.format%5Fdid%5Fkey)  
>                   * [format\_did\_key\_multikey()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.format%5Fdid%5Fkey%5Fmultikey)  
>                   * [format\_multikey()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.format%5Fmultikey)  
>                   * [get\_did\_key()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.get%5Fdid%5Fkey)  
>                   * [get\_multikey\_alg()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.get%5Fmultikey%5Falg)  
>                   * [parse\_did\_key()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.parse%5Fdid%5Fkey)  
>                   * [parse\_multikey()](about:blank/atproto%5Fcrypto/did.html#atproto%5Fcrypto.did.parse%5Fmultikey)  
>          * [Multibase](atproto%5Fcrypto/multibase.html)  
>                   * [bytes\_to\_multibase()](about:blank/atproto%5Fcrypto/multibase.html#atproto%5Fcrypto.multibase.bytes%5Fto%5Fmultibase)  
>                   * [multibase\_to\_bytes()](about:blank/atproto%5Fcrypto/multibase.html#atproto%5Fcrypto.multibase.multibase%5Fto%5Fbytes)  
>          * [Verify signature](atproto%5Fcrypto/verify.html)  
>                   * [verify\_signature()](about:blank/atproto%5Fcrypto/verify.html#atproto%5Fcrypto.verify.verify%5Fsignature)
> * [Server](atproto%5Fserver/index.html)  
>    * [Submodules](about:blank/atproto%5Fserver/index.html#submodules)  
>          * [Auth](atproto%5Fserver/auth.html)  
>                   * [JwtPayload](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.JwtPayload)  
>                   * [decode\_jwt\_payload()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.decode%5Fjwt%5Fpayload)  
>                   * [get\_jwt\_payload()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.get%5Fjwt%5Fpayload)  
>                   * [parse\_jwt()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.parse%5Fjwt)  
>                   * [validate\_jwt\_payload()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.validate%5Fjwt%5Fpayload)  
>                   * [verify\_jwt()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.verify%5Fjwt)  
>                   * [verify\_jwt\_async()](about:blank/atproto%5Fserver/auth.html#atproto%5Fserver.auth.jwt.verify%5Fjwt%5Fasync)
> * [Lexicon](atproto%5Flexicon/index.html)  
>    * [Submodules](about:blank/atproto%5Flexicon/index.html#submodules)  
>          * [Parser](atproto%5Flexicon/parser.html)  
>                   * [lexicon\_parse()](about:blank/atproto%5Flexicon/parser.html#atproto%5Flexicon.parser.lexicon%5Fparse)  
>                   * [lexicon\_parse\_dir()](about:blank/atproto%5Flexicon/parser.html#atproto%5Flexicon.parser.lexicon%5Fparse%5Fdir)  
>                   * [lexicon\_parse\_file()](about:blank/atproto%5Flexicon/parser.html#atproto%5Flexicon.parser.lexicon%5Fparse%5Ffile)  
>          * [Models](atproto%5Flexicon/models.html)  
>                   * [LexArray](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexArray)  
>                   * [LexBase](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBase)  
>                   * [LexBlob](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBlob)  
>                   * [LexBoolean](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBoolean)  
>                   * [LexBytes](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexBytes)  
>                   * [LexCidLink](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexCidLink)  
>                   * [LexDefinitionBase](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexDefinitionBase)  
>                   * [LexDefinitionType](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexDefinitionType)  
>                   * [LexInteger](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexInteger)  
>                   * [LexNumber](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexNumber)  
>                   * [LexObject](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexObject)  
>                   * [LexPrimitiveBase](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexPrimitiveBase)  
>                   * [LexPrimitiveType](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexPrimitiveType)  
>                   * [LexRecord](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexRecord)  
>                   * [LexRef](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexRef)  
>                   * [LexRefUnion](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexRefUnion)  
>                   * [LexString](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexString)  
>                   * [LexSubscription](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexSubscription)  
>                   * [LexToken](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexToken)  
>                   * [LexUnknown](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexUnknown)  
>                   * [LexXrpcBody](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcBody)  
>                   * [LexXrpcError](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcError)  
>                   * [LexXrpcParameters](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcParameters)  
>                   * [LexXrpcProcedure](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcProcedure)  
>                   * [LexXrpcQuery](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcQuery)  
>                   * [LexXrpcSubscriptionMessage](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexXrpcSubscriptionMessage)  
>                   * [LexiconDoc](about:blank/atproto%5Flexicon/models.html#atproto%5Flexicon.models.LexiconDoc)
> * [Exceptions](exceptions.html)  
>    * [Core](about:blank/exceptions.html#module-atproto%5Fcore.exceptions)  
>          * [AtProtocolError](about:blank/exceptions.html#atproto%5Fcore.exceptions.AtProtocolError)  
>          * [DAGCBORDecodingError](about:blank/exceptions.html#atproto%5Fcore.exceptions.DAGCBORDecodingError)  
>          * [InvalidAtUriError](about:blank/exceptions.html#atproto%5Fcore.exceptions.InvalidAtUriError)  
>          * [InvalidCARFile](about:blank/exceptions.html#atproto%5Fcore.exceptions.InvalidCARFile)  
>          * [InvalidNsidError](about:blank/exceptions.html#atproto%5Fcore.exceptions.InvalidNsidError)  
>    * [Client](about:blank/exceptions.html#module-atproto%5Fclient.exceptions)  
>          * [BadRequestError](about:blank/exceptions.html#atproto%5Fclient.exceptions.BadRequestError)  
>          * [InvokeTimeoutError](about:blank/exceptions.html#atproto%5Fclient.exceptions.InvokeTimeoutError)  
>          * [LoginRequiredError](about:blank/exceptions.html#atproto%5Fclient.exceptions.LoginRequiredError)  
>          * [ModelError](about:blank/exceptions.html#atproto%5Fclient.exceptions.ModelError)  
>          * [ModelFieldNotFoundError](about:blank/exceptions.html#atproto%5Fclient.exceptions.ModelFieldNotFoundError)  
>          * [NetworkError](about:blank/exceptions.html#atproto%5Fclient.exceptions.NetworkError)  
>          * [RequestErrorBase](about:blank/exceptions.html#atproto%5Fclient.exceptions.RequestErrorBase)  
>          * [RequestException](about:blank/exceptions.html#atproto%5Fclient.exceptions.RequestException)  
>          * [UnauthorizedError](about:blank/exceptions.html#atproto%5Fclient.exceptions.UnauthorizedError)  
>    * [Firehose](about:blank/exceptions.html#module-atproto%5Ffirehose.exceptions)  
>          * [FirehoseDecodingError](about:blank/exceptions.html#atproto%5Ffirehose.exceptions.FirehoseDecodingError)  
>          * [FirehoseError](about:blank/exceptions.html#atproto%5Ffirehose.exceptions.FirehoseError)  
>    * [Identity](about:blank/exceptions.html#module-atproto%5Fidentity.exceptions)  
>          * [AtprotoDataParseError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.AtprotoDataParseError)  
>          * [DidNotFoundError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.DidNotFoundError)  
>          * [DidPlcResolverError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.DidPlcResolverError)  
>          * [DidWebResolverError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.DidWebResolverError)  
>          * [PoorlyFormattedDidDocumentError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.PoorlyFormattedDidDocumentError)  
>          * [PoorlyFormattedDidError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.PoorlyFormattedDidError)  
>          * [UnsupportedDidMethodError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.UnsupportedDidMethodError)  
>          * [UnsupportedDidWebPathError](about:blank/exceptions.html#atproto%5Fidentity.exceptions.UnsupportedDidWebPathError)  
>    * [Crypto](about:blank/exceptions.html#module-atproto%5Fcrypto.exceptions)  
>          * [DidKeyError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.DidKeyError)  
>          * [IncorrectDidKeyPrefixError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.IncorrectDidKeyPrefixError)  
>          * [IncorrectMultikeyPrefixError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.IncorrectMultikeyPrefixError)  
>          * [InvalidCompressedPubkeyError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.InvalidCompressedPubkeyError)  
>          * [UnsupportedKeyTypeError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.UnsupportedKeyTypeError)  
>          * [UnsupportedSignatureAlgorithmError](about:blank/exceptions.html#atproto%5Fcrypto.exceptions.UnsupportedSignatureAlgorithmError)  
>    * [Server](about:blank/exceptions.html#module-atproto%5Fserver.exceptions)  
>          * [InvalidTokenError](about:blank/exceptions.html#atproto%5Fserver.exceptions.InvalidTokenError)  
>          * [TokenDecodeError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenDecodeError)  
>          * [TokenExpiredSignatureError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenExpiredSignatureError)  
>          * [TokenImmatureSignatureError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenImmatureSignatureError)  
>          * [TokenInvalidAudienceError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenInvalidAudienceError)  
>          * [TokenInvalidIssuedAtError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenInvalidIssuedAtError)  
>          * [TokenInvalidSignatureError](about:blank/exceptions.html#atproto%5Fserver.exceptions.TokenInvalidSignatureError)  
>    * [Lexicon](about:blank/exceptions.html#module-atproto%5Flexicon.exceptions)  
>          * [LexiconParsingError](about:blank/exceptions.html#atproto%5Flexicon.exceptions.LexiconParsingError)
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Type: Documentation-only
> The util.toUSVString() API is deprecated. Please use
> String.prototype.toWellFormed instead.
> DEP0176: fs.F_OK, fs.R_OK, fs.W_OK, fs.X_OK#
> 
> Type: Documentation-only
> F_OK, R_OK, W_OK and X_OK getters exposed directly on node:fs are
> deprecated. Get them from fs.constants or fs.promises.constants instead.
> DEP0177: util.types.isWebAssemblyCompiledModule#
> 
> Type: End-of-Life
> The util.types.isWebAssemblyCompiledModule API has been removed.
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> Kotlin docsLatest stable version: 2.0.21Get started with KotlinCreate your first Kotlin project for a platform of your choice in an IDE: IntelliJ IDEA or Android StudioTry Kotlin onlineWrite, edit, run, and share Kotlin code right in the browserFirst stepsBasic syntaxA quick introduction to Kotlin syntax: keywords, operators, program structureKotlin tourTake a tour of the fundamentals of the Kotlin programming languageKotlin MultiplatformKotlin Multiplatform overviewExplore the Kotlin Multiplatf
> 
> Kotlin docsLatest stable version: 2.0.21Get started with KotlinCreate your first Kotlin project for a platform of your choice in an IDE: IntelliJ IDEA or Android StudioTry Kotlin onlineWrite, edit, run, and share Kotlin code right in the browserFirst stepsBasic syntaxA quick introduction to Kotlin syntax: keywords, operators, program structureKotlin tourTake a tour of the fundamentals of the Kotlin programming languageKotlin MultiplatformKotlin Multiplatform overviewExplore the Kotlin Multiplatf
> 
> Kotlin releasesThe latest Kotlin releases and instructions on how to update to themStandard library API referenceLiving essentials for everyday work with Kotlin: IO, files, threading, collections, and much moreBasic typesKotlin type system: numbers, strings, arrays, and other built-in typesCollectionsCollections: lists, sets, and mapsCoroutinesConcurrency: coroutines, flows, channels
> 
> Kotlin releasesThe latest Kotlin releases and instructions on how to update to themStandard library API referenceLiving essentials for everyday work with Kotlin: IO, files, threading, collections, and much moreBasic typesKotlin type system: numbers, strings, arrays, and other built-in typesCollectionsCollections: lists, sets, and mapsCoroutinesConcurrency: coroutines, flows, channels
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> > [日本語](/uakihir0/kbsky/blob/main/docs/README%5Fja.md)
> 
> ## kbsky
> 
> [](#kbsky)
> 
> [![Maven Central Version](https://camo.githubusercontent.com/01a864834cd5596b8fede4647b24640217a22a870c5e4c0a682d0068bb17995d/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f776f726b2e736f6369616c6875622e6b62736b792f616c6c)](https://camo.githubusercontent.com/01a864834cd5596b8fede4647b24640217a22a870c5e4c0a682d0068bb17995d/68747470733a2f2f696d672e736869656c64732e696f2f6d6176656e2d63656e7472616c2f762f776f726b2e736f6369616c6875622e6b62736b792f616c6c)
> 
> [![badge](https://camo.githubusercontent.com/a14bdf13f54d05dd84487481c44f7d5a394c7738f846984d6dcd2c51b0749693/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6a766d2d4442343133442e737667)](https://camo.githubusercontent.com/a14bdf13f54d05dd84487481c44f7d5a394c7738f846984d6dcd2c51b0749693/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6a766d2d4442343133442e737667) [![badge](https://camo.githubusercontent.com/357a086606eb9c0372515b69e5b7845d6a66d7af22f38889e60a51cb44c43972/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d696f732d4344434443442e737667)](https://camo.githubusercontent.com/357a086606eb9c0372515b69e5b7845d6a66d7af22f38889e60a51cb44c43972/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d696f732d4344434443442e737667) [![badge](https://camo.githubusercontent.com/a34549acfbc29ada665ee0f59348b80a8db2492dfbbaf5a0fd862b7e9fafb4c6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6d61636f732d3131313131312e737667)](https://camo.githubusercontent.com/a34549acfbc29ada665ee0f59348b80a8db2492dfbbaf5a0fd862b7e9fafb4c6/687474703a2f2f696d672e736869656c64732e696f2f62616467652f2d6d61636f732d3131313131312e737667)
> 
> **This library is a Bluesky/ATProtocol client library compatible with [Kotlin Multiplatform](https://kotlinlang.org/docs/multiplatform.html).**It depends on [khttpclient](https://github.com/uakihir0/khttpclient) and uses Ktor Client internally. Therefore, this library can be used on any platform supported by Kotlin Multiplatform and Ktor Client. The behavior on each platform depends on [khttpclient](https://github.com/uakihir0/khttpclient).
> 
> ## Usage
> 
> [](#usage)
> 
> Below is how to use it with Kotlin on the supported platforms using Gradle.  
> **If you are using it on an Apple platform, please refer to [kbsky-cocoapods](https://github.com/uakihir0/kbsky-cocoapods).**  
> Additionally, please check the test code as well.
> 
> ### Stable (Maven Central)
> 
> [](#stable-maven-central)
> 
> repositories {
>     mavenCentral()
> }
> 
> dependencies {
> +   implementation("work.socialhub.kbsky:core:0.3.0")
> +   implementation("work.socialhub.kbsky:auth:0.3.0")
> +   implementation("work.socialhub.kbsky:stream:0.3.0")
> }
> 
> ### Snapshot
> 
> [](#snapshot)
> 
> repositories {
> +   maven { url = uri("https://repo.repsy.io/mvn/uakihir0/public") }
> }
> 
> dependencies {
> +   implementation("work.socialhub.kbsky:core:0.4.0-SNAPSHOT")
> +   implementation("work.socialhub.kbsky:auth:0.4.0-SNAPSHOT")
> +   implementation("work.socialhub.kbsky:stream:0.4.0-SNAPSHOT")
> }
> 
> ### Using as part of a regular Java project
> 
> [](#using-as-part-of-a-regular-java-project)
> 
> All of the above can be added to and used in regular Java projects, too. All you have to do is to use the suffix `-jvm` when listing the dependency.
> 
> Here is a sample Maven configuration:
> 
> <dependency>
>     <groupId>work.socialhub.kbsky</groupId>
>     <artifactId>core-jvm</artifactId>
>     <version>[VERSION]</version>
> </dependency>
> 
> ### Starting a Session
> 
> [](#starting-a-session)
> 
> #### Authentication with Password
> 
> [](#authentication-with-password)
> 
> To start a session by specifying a handle and password, do as follows:
> 
> val response = BlueskyFactory
>     .instance(BSKY_SOCIAL.uri)
>     .server()
>     .createSession(
>         ServerCreateSessionRequest().also {
>             it.identifier = HANDLE
>             it.password = PASSWORD
>         }
>     )
> 
> println(response.data.accessJwt)
> 
> To access various resources with the obtained access token, execute the following:
> 
> val auth = BearerTokenAuthProvider(accessJwt)
> 
> BlueskyFactory
>     .instance(BSKY_SOCIAL.uri)
>     .feed()
>     .post(
>         FeedPostRequest(auth).also {
>             it.text = "Hello World!"
>         }
>     )
> 
> #### Authentication with OAuth
> 
> [](#authentication-with-oauth)
> 
> Authentication using a password is gradually being replaced with OAuth. For more details on OAuth authentication, please refer to [Authentication via OAuth](/uakihir0/kbsky/blob/main/docs/OAUTH.md).
> 
> ### PLC Directory
> 
> [](#plc-directory)
> 
> val response = PLCDirectoryFactory
>     .instance()
>     .DIDDetails(did)
> 
> println(checkNotNull(response.data.alsoKnownAs)[0])
> 
> ### SubscribeRepos (stream)
> 
> [](#subscriberepos-stream)
> 
> val stream = ATProtocolStreamFactory
>     .instance(
>         apiUri = BSKY_SOCIAL.uri,
>         streamUri = BSKY_NETWORK.uri
>     )
>     .sync()
>     .subscribeRepos(
>         SyncSubscribeReposRequest().also {
>             it.filter = listOf(
>                 "app.bsky.feed.post"
>             )
>         }
>     )
> 
> stream.eventCallback(
>     object : EventCallback {
>         override fun onEvent(
>             cid: String?,
>             uri: String?,
>             record: RecordUnion
>         ) {
>             print(record)
>         }
>     })
> 
> ## License
> 
> [](#license)
> 
> MIT License
> 
> ## Author
> 
> [](#author)
> 
> [Akihiro Urushihara](https://github.com/uakihir0)
> 
> Modules
> Packages
> Interfaces
> Classes
> Enum Classes
> Exception Classes
> Record Classes
> Annotation Interfaces
> Fields
> Methods
> Constructors
> Enum Constants
> 
> 
> 
> 
> New Modules
> 
> 
> 
> 
> 
> 
> jdk.jpackage
> 16
> 
> Defines the Java Packaging tool, jpackage.
> 
> jdk.nio.mapmode
> 14
> 
> Defines JDK-specific file mapping modes.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Packages
> 
> 
> 
> 
> 
> 
> java.lang.constant
> 12
> 
> Classes and interfaces to represent nominal descriptors for run-time
>  entities such as classes or method handles, and classfile entities such as
> 
> javax.lang.model.SourceVersion.RELEASE_14
> 14
> 
> The version introduced by the Java Platform, Standard Edition
>  14.
> 
> javax.lang.model.SourceVersion.RELEASE_15
> 15
> 
> The version introduced by the Java Platform, Standard Edition
>  15.
> 
> javax.lang.model.SourceVersion.RELEASE_16
> 16
> 
> The version introduced by the Java Platform, Standard Edition
>  16.
> 
> javax.lang.model.SourceVersion.RELEASE_17
> 17
> 
> The version introduced by the Java Platform, Standard Edition
>  17.
> 
> javax.lang.model.SourceVersion.RELEASE_18
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> transitive
> java.management
> 
> Defines the Java Management Extensions (JMX) API.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> Within artifact producing source directories (ie. main and test), there is one directory for the language java (under which the normal package hierarchy exists), and one for resources (the structure which is copied to the target classpath given the default resource definition).
> If there are other contributing sources to the artifact build, they would be under other subdirectories. For example src/main/antlr would contain Antlr grammar definition files.
> 
> Apache Maven 3.8.8 is the previous stable minor release for all users.
>         
> 
> 
>             
> 
>               
> Java Development Kit (JDK)
>               
> Maven 3.8+ requires JDK 1.7 or above to execute. It still allows you to build against 1.3 and other JDK versions
>                   by using toolchains.
>             
>           
>         
>         
> Maven is distributed in several formats for your convenience. Simply pick a
>               ready-made binary distribution archive and follow the
> 
> `-- AppTest.java
> The src/main/java directory contains the project source code, the src/test/java directory contains the test source, and the pom.xml file is the project's Project Object Model, or POM.
> The POM
> 
> An archetype to generate a sample JSR-268 Portlet.
> 
> maven-archetype-quickstart
> An archetype to generate a sample Maven project.
> 
> maven-archetype-simple
> An archetype to generate a simple Maven project.
> 
> maven-archetype-site
> An archetype to generate a sample Maven site which demonstrates some of the supported document types like APT, XDoc, and FML and demonstrates how to i18n your site.
> 
> maven-archetype-site-simple
> An archetype to generate a sample Maven site.
> 
> maven-archetype-webapp
> 
> To utilize Modello, you would configure the modello-maven-plugin something like the following where you want to generate the Java sources for the model, the xpp3 serialization code and the xpp3 deserialization code (see modello-plugin-xpp3 for more details):
> 
> <project>  ...  <build>    <plugins>      <plugin>        <groupId>org.codehaus.modello</groupId>        <artifactId>modello-maven-plugin</artifactId>        <version>1.8.3</version>        <executions>          <execution>            <goals>              <!-- Generate the xpp3 reader code -->              <goal>xpp3-reader</goal>              <!-- Generate the xpp3 writer code -->              <goal>xpp3-writer</goal>              <!-- Generate the Java sources for the model itself -->
> 
> If you are producing a JAR that is a derivative of the original (e.g., just a subset of classes, or the same JAR with debugging enabled), Maven supports this using profiles. See  Introduction to Profiles for more information.
> 
> In this example, the sources are found in the parent directory ../src/main/java, and only Java files within a core package are included.
> The final result when building will look like this:
> /
> +- pom.xml
> +- src/
>    +- main/
>       +- java/
>           +- core/
>              +- Core.java
>           +- module/
>              +- Module.java
> +- core/
>    +- pom.xml
>    +- target/
>       +- my-core-1.0-SNAPSHOT.jar
> +- module/
>    +- pom.xml
>    +- target/
>       +- my-module-1.0-SNAPSHOT.jar
> 
> compile
> You may test the newly compiled and packaged JAR with the following command:
> java -cp target/my-app-1.0-SNAPSHOT.jar com.mycompany.app.App
> Which will print the quintessential:
> Hello World!
> Java 9 or later
> 
> How do I set up Maven so it will compile with a target and source JVM of my choice?
> Is it possible to create my own directory structure?
> Where is the source code? I couldn't seem to find a link anywhere on the Maven site
> Maven can't seem to download the dependencies. Is my installation correct?
> I have a jar that I want to put into my local repository. How can I copy it in?
> How do I unsubscribe from Maven mailing lists?
> How do I skip the tests?
> How can I run a single unit test?
> 
> 3.0
> jar
> BSD-3-Clause
> 
> org.htmlunit
> htmlunit
> 4.4.0
> jar
> Apache License, Version 2.0
> Project Transitive Dependencies
> The following is a list of transitive dependencies for this project. Transitive dependencies are the dependencies of the project dependencies.
> test
> The following is a list of test dependencies for this project. These dependencies are only required to compile and run unit tests for the application:
> 
> 
> GroupId
> ArtifactId
> Version
> Type
> Licenses
> 
> commons-codec
> commons-codec
> 1.17.1
> jar
> 
> Guide for New Committers
> Testing Development Versions of Plugins
> 3rd Party Resources
> Conventions
> 
> Maven Conventions
> Naming Conventions
> When You Can't Use the Conventions
> The Central Repository
> 
> Introduction to the Central Repository
> Uploading Artifacts to the Central Repository
> Improving the Repository
> References
> 
> POM Overview (Technical Project Descriptor)
> Settings Overview (Technical Settings Descriptor)
> Core Plug-ins List
> Mojo API
> Glossary
> Javadoc API
> 
> Java Development Kit (JDK)
>               
> Maven 4.0+ requires JDK 17 or above to execute. It still allows you to build against 8 and other JDK versions
>                   by using toolchains.
>             
>           
>         
> 
>         
> Maven is distributed in several formats for your convenience. Simply pick a
>               ready-made binary distribution archive and follow the 
>               installation instructions.
> 
> Building a Plugin
> There are few plugin goals bound to the standard build lifecycle defined with the maven-plugin packaging:
> 
> 
> compile
> Compiles the Java code for the plugin
> 
> process-classes
> Extracts data to build the plugin descriptor
> 
> test
> Runs the plugin's unit tests
> 
> package
> Builds the plugin jar
> 
> install
> Installs the plugin jar in the local repository
> 
> deploy
> Deploys the plugin jar to the remote repository
> For more details, you can look at  detailed bindings for maven-plugin packaging.
> 
> Documentation
> Getting Started with Maven
> 
> Getting Started in 5 Minutes
> Getting Started in 30 Minutes
> Introductions
> 
> The Build Lifecycle
> The POM
> Profiles
> Repositories
> Standard Directory Layout
> The Dependency Mechanism
> 
>  Optional Dependencies and Dependency Exclusions
> Plugins
> 
> Plugin Development
> Configuring Plug-ins
> Plugin Prefix Resolution
> Developing Java Plugins
> Site
> 
> Creating a Site
> The APT Format
> Snippet Macro
> Archetypes
> 
> What is an Archetype
> Creating Archetypes
> Upgrading
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> ```java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> // src/test/java/com/atproto/codegen/ClientGeneratorTest.java
> 
> 
> 
> package com.atproto.codegen;
> 
> 
> 
> import static org.junit.jupiter.api.Assertions.*;
> 
> import static org.mockito.Mockito.*;
> 
> 
> 
> import com.atproto.api.AtpResponse;
> 
> import com.atproto.api.xrpc.XRPCException;
> 
> import com.atproto.lexicon.models.*;
> 
> 
> 
> import java.io.IOException;
> 
> import java.util.ArrayList;
> 
> import java.util.HashMap;
> 
> import java.util.List;
> 
> import java.util.Map;
> 
> import java.util.Optional;
> 
> import java.util.stream.Stream;
> 
> 
> 
> import org.junit.jupiter.api.BeforeEach;
> 
> import org.junit.jupiter.api.Test;
> 
> import org.junit.jupiter.params.ParameterizedTest;
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> import org.junit.jupiter.params.provider.MethodSource;
> 
> import org.mockito.junit.jupiter.MockitoExtension;
> 
> import org.junit.jupiter.api.extension.ExtendWith;
> 
> import org.mockito.Mock;
> 
> 
> 
> @ExtendWith(MockitoExtension.class)
> 
> public class ClientGeneratorTest {
> 
> 
> 
>     @Mock
> 
>     private XrpcClient mockXrpcClient;
> 
> 
> 
>     private ClientGenerator generator;
> 
> 
> 
>     @BeforeEach
> 
>     public void setUp() {
> 
>         generator = new ClientGenerator();
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForSimpleQuery() throws Exception { // Added Exception
> 
>         // Test simple Client
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon.
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks (These are very basic. It should use a Java parser for real
> 
>         // validation)
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains("public class SimpleQueryClient")); // Has class name
> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
> 
>         assertTrue(generatedCode.contains("simpleQuery(")); // Method name (same as ID)
> 
>         assertTrue(generatedCode.contains(
> 
>                 "xrpcClient.sendQuery")); // Use XRPC. (should we mock for this kind of test?)
> 
>         assertFalse(generatedCode.contains(
> 
>                 "import com.atproto.api.xrpc.XRPCException;")); // Doesn't import XRPC
> 
> 
> 
>         // --- Compilation and Reflection ---
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         // Invoke and check return type.
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> 
>         Object result = method.invoke(clientInstance);
> 
>         assertInstanceOf(AtpResponse.class, result);
> 
> 
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForQueryWithParams() throws Exception { // Added Exception
> 
>         // Test params Client
> 
>         LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains("public class ParamsQueryClient")); // Class Name.
> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
> 
>         assertTrue(generatedCode.contains(
> 
>                 "paramsQuery(ParamsQueryParams params")); // Query method with parameters and type
> 
>         assertTrue(generatedCode.contains("xrpcClient.sendQuery")); // Use XRPC
> 
> 
> 
>         // --- Compilation and Reflection ---
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         Class<?> paramClass = Class.forName("com.example.ParamsQueryParams");
> 
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         // Invoke and check return type
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("paramsQuery", paramClass);
> 
>         Object result = method.invoke(clientInstance, paramInstance); // Pass the parameter instance
> 
>         assertInstanceOf(AtpResponse.class, result);
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForProcedure() throws Exception { // Added Exception
> 
>         // Test Procedure
> 
>         LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains("public class ProcedureClient")); // Class name
> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Return AtpResponse
> 
>         assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input")); // Proper params
> 
>         assertTrue(generatedCode.contains(
> 
>                 "xrpcClient.sendProcedure")); // Check for XRPC call (should be checked in its own test)
> 
> 
> 
>         // --- Compilation and Reflection ---
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         Class<?> inputClass = Class.forName("com.example.ProcedureProcedureInput");
> 
>         Object inputInstance = inputClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         // Execute and test
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method
> 
>                                                                                                    // signature
> 
>         Object result = method.invoke(clientInstance, inputInstance); // Invoke with parameter
> 
>         assertInstanceOf(AtpResponse.class, result);
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForSubscription() throws IOException {
> 
>         // Test Subscription
> 
>         LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks (subscriptions might have a very different structure)
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains(
> 
>                 "public class SubscriptionClient")); // Class exists (name should automatically be generated from the
> 
>                                                      // name)
> 
>         assertTrue(generatedCode.contains("public void")); // void return type.
> 
>         assertTrue(
> 
>                 generatedCode.contains("subscription(")); // Subscription Method. (name should automatically be
> 
>                                                           // generated
> 
>         // from the name)
> 
>         assertTrue(generatedCode.contains(
> 
>                 "throw new UnsupportedOperationException")); // Subscription not implemented
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientWithMultipleMethods() throws IOException {
> 
>         // Multiple Definitions
> 
>         LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator Instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Check for multiple methods
> 
>         assertTrue(generatedCode.contains("queryMethod(")); // Query exists
> 
>         assertTrue(generatedCode.contains("procedureMethod(")); // Procedure Exists
> 
>     }
> 
> 
> 
>     // Test for duplicate method names. Should de-dupe
> 
>     @Test
> 
>     public void testGenerateClientWithDuplicateMethods() throws IOException {
> 
>         LexiconDoc lexiconDoc = TestUtils.createDuplicateMethodLexicon();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
> 
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Check for multiple methods
> 
>         assertEquals(1, countOccurrences(generatedCode, "queryMethod")); // Query exists
> 
> 
> 
>     }
> 
> 
> 
>     // Helper Method. (Need to find something more formal; maybe write one of my
> 
>     // own)
> 
>     public int countOccurrences(String text, String word) {
> 
> 
> 
>         int count = 0; // Initialize a counter variable
> 
> 
> 
>         int fromIndex = 0; // Start from the beginning
> 
> 
> 
>         while ((fromIndex = text.indexOf(word, fromIndex)) != -1) {
> 
>             count++;
> 
>             fromIndex++; // Move past the word
> 
>         }
> 
> 
> 
>         return count;
> 
>     }
> 
> 
> 
>     // Test that XRPC Exception gets thrown.
> 
>     @Test
> 
>     public void testXRPCException() throws IOException {
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
> 
>                                                                       // Lexicon
> 
>         // we make, just need one)
> 
> 
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         assertTrue(generatedCode.contains(
> 
>                 "import com.atproto.api.xrpc.XRPCException;")); // Should import exception
> 
>     }
> 
> 
> 
>     // Test that AtpResponse gets imported.
> 
>     @Test
> 
>     public void testAtpResponseType() throws IOException {
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
> 
>                                                                       // Lexicon
> 
>         // we make, just need one)
> 
> 
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         assertTrue(generatedCode.contains(
> 
>                 "import com.atproto.api.AtpResponse;")); // Should import AtpResponse
> 
>     }
> 
> 
> 
>     // Helper methods for creating Lexicon structures (for test readability)
> 
>     // These would ideally be in a separate test utility class.
> 
> 
> 
>     @ParameterizedTest
> 
>     @MethodSource("provideLexiconsForAllParameterTypes")
> 
>     public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType)
> 
>             throws Exception { // Added Exception
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         // General checks (package, class name, etc.)
> 
>         assertTrue(generatedCode.contains("package com.example;"));
> 
> 
> 
>         // More specific checks based on parameter type. This is where we use the
> 
>         // paramName.
> 
>         assertTrue(generatedCode.contains(paramName)); // Very basic, does the parameter exist?
> 
> 
> 
>         // Check that parameter type is correct
> 
>         assertTrue(generatedCode.contains(expectedType + " " + paramName));
> 
> 
> 
>         // --- Compilation and Reflection to check return type ---
> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         // Inject mockXrpcClient
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         // Find the method and its return type. This assumes the method name is "main"
> 
>         java.lang.reflect.Method method = null;
> 
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
> 
>             if (m.getName().equals("main")) { // Or whatever the method name is in your generated code
> 
>                 method = m;
> 
>                 break;
> 
>             }
> 
>         }
> 
>         assertNotNull(method, "Method 'main' not found in generated class");
> 
> 
> 
>         // Get Return Type from Lexicon, create expected type from this
> 
>         String expectedReturnType = "AtpResponse"; // Default
> 
>         if (lexiconDoc.getDefs().get("main") instanceof LexXrpcQuery) {
> 
>             LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
> 
>             if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
> 
>                 expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
> 
>             } else {
> 
>                 expectedReturnType = "AtpResponse<Void>";
> 
>             }
> 
>         } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcProcedure) {
> 
>             LexXrpcProcedure procedure = (LexXrpcProcedure) lexiconDoc.getDefs().get("main");
> 
>             if (procedure.getOutput().isPresent() && procedure.getOutput().get().getSchema().isPresent()) {
> 
>                 expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get())
> 
>                         + ">";
> 
> 
> 
>             } else {
> 
>                 expectedReturnType = "AtpResponse<Void>";
> 
>             }
> 
>         } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcSubscription) {
> 
>             expectedReturnType = "void";
> 
>         }
> 
> 
> 
>         // Now we assert that the return type from code gen is as expected
> 
>         String actualReturnType = method.getGenericReturnType().getTypeName()
> 
>                 .replace("java.util.concurrent.CompletableFuture", "AtpResponse");
> 
>         assertEquals(expectedReturnType, actualReturnType);
> 
>     }
> 
> 
> 
>     // Helper function to return expected Java type String from Lexicon definition.
> 
>     private String getExpectedJavaType(LexXrpcBody xrpcBody) {
> 
> 
> 
>         if (xrpcBody.getSchema().isEmpty()) {
> 
>             return "Void";
> 
>         }
> 
> 
> 
>         LexXrpcBody schema = xrpcBody;
> 
>         if (schema.getSchema().get() instanceof LexObject) {
> 
>             return "Object"; // Placeholder, replace with generated class name if using nested objects.
> 
>         } else if (schema.getSchema().get() instanceof LexArray) {
> 
>             LexArray lexArray = (LexArray) schema.getSchema().get();
> 
>             // Handle nested arrays
> 
>             return getExpectedArrayType(lexArray);
> 
>         } else if (schema.getSchema().get() instanceof LexPrimitive) {
> 
>             return getExpectedPrimitiveType((LexPrimitive) schema.getSchema().get());
> 
>         } else if (schema.getSchema().get() instanceof LexXrpcBody) {
> 
>             return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
> 
>         } else if (schema.getSchema().get() instanceof LexRef) {
> 
>             // Resolve references, including repository refs vs. defs refs. This is very
> 
>             // basic.
> 
>             LexRef ref = (LexRef) schema.getSchema().get();
> 
>             String refStr = ref.getRef();
> 
>             if (refStr.startsWith("#")) {
> 
>                 return refStr.substring(refStr.lastIndexOf(".") + 1); // Local ref
> 
>             } else {
> 
>                 return refStr.replace(".", ""); // External ref
> 
>             }
> 
>         } else if (schema.getSchema().get() instanceof LexString) {
> 
>             LexString lexString = (LexString) schema.getSchema().get();
> 
>             if (lexString.getFormat().isPresent()) {
> 
>                 if (lexString.getFormat().equals("datetime")) {
> 
>                     return "java.time.Instant";
> 
>                 } else if (lexString.getFormat().equals("cid")) {
> 
>                     return "com.atproto.common.Cid";
> 
>                 } else if (lexString.getFormat().equals("did")) {
> 
>                     return "com.atproto.syntax.Did";
> 
>                 } else if (lexString.getFormat().equals("handle")) {
> 
>                     return "com.atproto.syntax.Handle";
> 
>                 } else if (lexString.getFormat().equals("at-uri")) {
> 
>                     return "com.atproto.syntax.AtUri";
> 
>                 } else if (lexString.getFormat().equals("nsid")) {
> 
>                     return "com.atproto.syntax.Nsid";
> 
>                 } else if (lexString.getFormat().equals("uri")) {
> 
>                     return "java.net.URI";
> 
>                 } else if (lexString.getFormat().equals("language")) {
> 
>                     return "java.util.Locale";
> 
>                 } else if (lexString.getFormat().equals("uri-reference")) {
> 
>                     return "java.net.URI"; // Assuming URI for uri-reference
> 
>                 } else if (lexString.getFormat().equals("uri-template")) {
> 
>                     return "java.lang.String"; // Assuming String for uri-template (no built-in type)
> 
>                 } else if (lexString.getFormat().equals("email")) {
> 
>                     return "java.lang.String"; // Assuming String for email
> 
>                 } else if (lexString.getFormat().equals("hostname")) {
> 
>                     return "java.lang.String"; // Assuming String for hostname
> 
>                 } else if (lexString.getFormat().equals("ipv4")) {
> 
>                     return "java.net.InetAddress"; // Assuming InetAddress for IPv4
> 
>                 } else if (lexString.getFormat().equals("ipv6")) {
> 
>                     return "java.net.InetAddress"; // Assuming InetAddress for IPv6
> 
> 
> 
>                 }
> 
>             }
> 
>             return "String";
> 
>         } else if (schema.getSchema().get() instanceof LexRefUnion) {
> 
>             return "Object";
> 
>         }
> 
> 
> 
>         return "Object"; // Unreachable? Error?
> 
>     }
> 
> 
> 
>     private String getExpectedArrayType(LexArray lexArray) {
> 
>         StringBuilder sb = new StringBuilder();
> 
>         sb.append("java.util.List<");
> 
>         LexType itemType = lexArray.getItems();
> 
> 
> 
>         if (itemType instanceof LexPrimitive) {
> 
>             sb.append(getExpectedPrimitiveType((LexPrimitive) itemType));
> 
>         } else if (itemType instanceof LexArray) {
> 
>             sb.append(getExpectedArrayType((LexArray) itemType)); // Recurse for nested arrays
> 
>         } else if (itemType instanceof LexRef) {
> 
>             // Resolve references
> 
>             LexRef ref = (LexRef) itemType;
> 
>             String refStr = ref.getRef();
> 
>             if (refStr.startsWith("#")) {
> 
>                 sb.append(refStr.substring(refStr.lastIndexOf(".") + 1));
> 
>             } else {
> 
>                 sb.append(refStr.replace(".", ""));
> 
>             }
> 
>         } else if (itemType instanceof LexRefUnion) {
> 
>             sb.append("Object"); // No specific type in a refUnion
> 
>         } else if (itemType instanceof LexObject) { // Nested object not allowed as Array
> 
>             return "Object";
> 
>         }
> 
> 
> 
>         sb.append(">");
> 
>         return sb.toString();
> 
>     }
> 
> 
> 
>     private String getExpectedPrimitiveType(LexPrimitive prim) {
> 
>         if (prim instanceof LexBoolean) {
> 
>             return "Boolean";
> 
>         } else if (prim instanceof LexInteger) {
> 
>             return "Integer";
> 
>         } else if (prim instanceof LexString) {
> 
>             return "String";
> 
>         } else if (prim instanceof LexNumber) {
> 
>             return "Float";
> 
>         } else if (prim instanceof LexBytes) {
> 
>             return "byte[]";
> 
>         } else if (prim instanceof LexUnknown) {
> 
>             return "java.util.Map<String, Object>";
> 
>         }
> 
>         return "Object"; // Should not happen in valid Lexicon
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForNestedObject() throws Exception { // Added Exception
> 
>         LexiconDoc lexiconDoc = TestUtils.createNestedObjectLexicon();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         // Basic checks
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains("public class NestedObjectClient")); // Class Name.
> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
> 
>         assertTrue(generatedCode.contains(
> 
>                 "nestedObject(")); // Query method with parameters and type
> 
> 
> 
>         // --- Compilation and Reflection, as before, BUT: ---
> 
>         // 1. Compile and Get Class:
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         // 2. Inject Mock:
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         // 3. Get and Invoke Method, Assert Return Type
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
> 
>         Object result = method.invoke(clientInstance);
> 
>         assertInstanceOf(AtpResponse.class, result); // Very basic check
> 
> 
> 
>         // You could add in more specific checks with Mockito here to check call
> 
>         // parameters
> 
>     }
> 
> 
> 
>     @ParameterizedTest
> 
>     @MethodSource("provideLexiconsForInvalidLexicons")
> 
>     public void testInvalidLexiconStructure(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testMultipleDefs() throws IOException {
> 
>         LexiconDoc lexiconDoc = TestUtils.createLexiconWithMultipleDefs();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         assertTrue(generatedCode.contains("class Query1Client"));
> 
>         assertTrue(generatedCode.contains("class Query2Client"));
> 
>         assertTrue(generatedCode.contains("class Record1Record")); // Check for records.
> 
> 
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForRefUnionParams() throws Exception { // Added Exception
> 
>         LexiconDoc lexiconDoc = TestUtils.createLexiconWithRefUnionParams();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         assertTrue(generatedCode.contains("package com.example;"));
> 
>         assertTrue(generatedCode.contains("public class RefUnionParamsClient"));
> 
>         // Check that the generated code includes the expected parameter and return type
> 
>         // (adjust as per codegen)
> 
>         // NOTE: This will likely need changing based on how you generate method
> 
>         // signatures.
> 
>         assertTrue(generatedCode.contains("public AtpResponse refUnionParams(Object params)")); // Object because it
> 
>                                                                                                 // could be either one
> 
>                                                                                                 // of the Record Types.
> 
> 
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testJavadocGeneration() throws Exception { // Added Exception
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         // Basic Javadoc checks
> 
>         assertTrue(generatedCode.contains("/**"));
> 
>         assertTrue(generatedCode.contains("* This is a test query.")); // Check for the description.
> 
>         assertTrue(generatedCode.contains("*/"));
> 
>         assertTrue(generatedCode.contains("public class SimpleQueryClientWithDescription"));
> 
> 
> 
>         // Compile and load the class, then verify with reflection
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler
> 
>                 .compile("com.example.SimpleQueryClientWithDescription", generatedCode);
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> 
>         assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more
> 
>                                                                                   // thorough.
> 
> 
> 
>     }
> 
> 
> 
>     @ParameterizedTest
> 
>     @MethodSource("provideLexiconsForStringConstraints")
> 
>     public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
> 
>             Integer maxLength, Integer minLength, String constValue, String pattern) throws Exception {
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         // General checks, compilation, method retrieval (as before)
> 
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         java.lang.reflect.Method method = null;
> 
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
> 
>             if (m.getName().equals("main")) {
> 
>                 method = m;
> 
>                 break;
> 
>             }
> 
>         }
> 
>         Class<?> paramClass = method.getParameterTypes()[0];
> 
>         // Now using reflection
> 
>         java.lang.reflect.Field paramField = null;
> 
>         try {
> 
>             paramField = paramClass.getDeclaredField(paramName);
> 
> 
> 
>         } catch (Exception e) {
> 
>             failCount++;
> 
>             fail("parameter not found in parameters of generated class.");
> 
>         }
> 
> 
> 
>         // maxLength constraint
> 
>         if (maxLength != null) {
> 
>             assertTrue(generatedCode.contains("@MaxLength(" + maxLength + ")"));
> 
>         }
> 
> 
> 
>         // minLength constraint
> 
>         if (minLength != null) {
> 
>             assertTrue(generatedCode.contains("@MinLength(" + minLength + ")"));
> 
>         }
> 
> 
> 
>         // const constraint
> 
>         if (constValue != null) {
> 
>             assertTrue(generatedCode
> 
>                     .contains("public static final String " + paramName.toUpperCase() + " = \"" + constValue + "\";"));
> 
>         }
> 
>     }
> 
> 
> 
>     // Data Providers
> 
>     private static Stream<Arguments> provideLexiconsForAllParameterTypes() {
> 
>         List<Arguments> argList = new ArrayList<>();
> 
> 
> 
>         // Integer types
> 
>         Map<String, LexPrimitive> intParams = new HashMap<>();
> 
>         intParams.put("intParam",
> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.intParams", intParams), "intParam",
> 
>                 "Integer"));
> 
> 
> 
>         // Number types (float/double) part of LexNumber
> 
>         Map<String, LexPrimitive> numberParams = new HashMap<>();
> 
>         numberParams.put("floatParam",
> 
>                 new LexNumber(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.floatParams", numberParams),
> 
>                 "floatParam", "Float")); // Double, double
> 
> 
> 
>         // String types
> 
>         Map<String, LexPrimitive> stringParams = new HashMap<>();
> 
>         stringParams.put("stringParam", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.stringParams", stringParams),
> 
>                 "stringParam", "String"));
> 
> 
> 
>         // Boolean types
> 
>         Map<String, LexPrimitive> boolParams = new HashMap<>();
> 
>         boolParams.put("boolParam", new LexBoolean(Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.boolParams", boolParams), "boolParam",
> 
>                 "Boolean"));
> 
> 
> 
>         // Bytes type
> 
>         Map<String, LexPrimitive> bytesParams = new HashMap<>();
> 
>         bytesParams.put("bytesParam",
> 
>                 new LexBytes(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.bytesParams", bytesParams),
> 
>                 "bytesParam", "byte[]"));
> 
> 
> 
>         // CidLink
> 
>         Map<String, LexPrimitive> cidLinkParams = new HashMap<>();
> 
>         cidLinkParams.put("cidLinkParam", new LexCidLink(Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.cidLinkParams", cidLinkParams),
> 
>                 "cidLinkParam", "com.atproto.common.Cid"));
> 
> 
> 
>         // Array of primitives
> 
>         Map<String, LexType> arrayParams = new HashMap<>();
> 
>         arrayParams.put("intArrayParam", new LexArray(
> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.arrayParams", arrayParams),
> 
>                 "intArrayParam", "java.util.List<Integer>"));
> 
> 
> 
>         // Unknown
> 
>         Map<String, LexPrimitive> unknownParams = new HashMap<>();
> 
>         unknownParams.put("unknownParam", new LexUnknown(Optional.empty()));
> 
>         argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.unknownParams", unknownParams),
> 
>                 "unknownParam", "java.util.Map<String, Object>"));
> 
> 
> 
>         // String Formats.
> 
>         Map<String, LexPrimitive> stringFormatParams = new HashMap<>();
> 
>         stringFormatParams.put("atUriParam", new LexString(Optional.of("at-uri"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("cidParam", new LexString(Optional.of("cid"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("didParam", new LexString(Optional.of("did"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("handleParam", new LexString(Optional.of("handle"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("nsidParam", new LexString(Optional.of("nsid"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("datetimeParam", new LexString(Optional.of("datetime"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("languageParam", new LexString(Optional.of("language"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("uriParam", new LexString(Optional.of("uri"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("uriRefParam", new LexString(Optional.of("uri-reference"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("uriTemplateParam", new LexString(Optional.of("uri-template"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("emailParam", new LexString(Optional.of("email"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("hostnameParam", new LexString(Optional.of("hostname"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("ipv4Param", new LexString(Optional.of("ipv4"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         stringFormatParams.put("ipv6Param", new LexString(Optional.of("ipv6"),
> 
>                 Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
> 
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "atUriParam", "com.atproto.syntax.AtUri"));
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "cidParam", "com.atproto.common.Cid")); // Assuming you have a Cid class.
> 
> 
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "didParam", "com.atproto.syntax.Did")); // Assuming you have a Did class
> 
> 
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "handleParam", "com.atproto.syntax.Handle")); // Assuming you have a Handle class
> 
> 
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "nsidParam", "com.atproto.syntax.Nsid")); // Assuming you have an NSID class.
> 
> 
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "datetimeParam", "java.time.Instant"));
> 
> 
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "languageParam", "java.util.Locale"));
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "uriParam", "java.net.URI"));
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "uriRefParam", "java.net.URI")); // Assuming URI for uri-reference
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "uriTemplateParam", "java.lang.String")); // Assuming String for uri-template (no built-in type)
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "emailParam", "java.lang.String")); // Assuming String for email
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "hostnameParam", "java.lang.String")); // Assuming String for hostname
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "ipv4Param", "java.net.InetAddress")); // Assuming InetAddress for IPv4
> 
>         argList.add(
> 
>                 Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> 
>                         "ipv6Param", "java.net.InetAddress")); // Assuming InetAddress for IPv6
> 
>         return argList.stream();
> 
>     }
> 
> 
> 
>     private static Stream<Arguments> provideLexiconsForInvalidLexicons() {
> 
>         return Stream.of(
> 
>                 // Missing 'defs'
> 
>                 Arguments.of(TestUtils.createLexiconWithoutDefs(), IllegalArgumentException.class),
> 
>                 // Invalid type within parameters
> 
>                 Arguments.of(TestUtils.createLexiconWithInvalidType(), IllegalArgumentException.class)
> 
> 
> 
>         );
> 
> 
> 
>     }
> 
> 
> 
>     private static Stream<Arguments> provideLexiconsForStringConstraints() {
> 
>         return Stream.of(
> 
>                 Arguments.of(createLexiconWithStringConstraints(), "maxLengthString", "String", 10, null, null, null),
> 
>                 Arguments.of(createLexiconWithStringConstraints(), "minLengthString", "String", null, 5, null, null),
> 
>                 Arguments.of(createLexiconWithStringConstraints(), "constString", "String", null, null, "constantValue",
> 
>                         null),
> 
>                 Arguments.of(createLexiconWithStringConstraints(), "patternString", "String", null, null, null,
> 
>                         "[a-zA-Z]+"));
> 
>     }
> 
> }
> ```
> 
> ```java
> // src/main/test/java/com/atproto/codegen/TestUtils.java
> // src/test/java/com/atproto/codegen/TestUtils.java
> 
> 
> 
> package com.atproto.codegen;
> 
> 
> 
> import com.atproto.lexicon.models.*;
> 
> 
> 
> import javax.tools.*;
> 
> import java.io.ByteArrayInputStream;
> 
> import java.io.IOException;
> 
> import java.io.InputStream;
> 
> import java.io.OutputStream;
> 
> import java.net.URI;
> 
> import java.net.URISyntaxException;
> 
> import java.nio.CharBuffer;
> 
> import java.nio.charset.StandardCharsets;
> 
> import java.util.*;
> 
> import java.util.stream.Stream;
> 
> 
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> 
> 
> public class TestUtils {
> 
> 
> 
>     public static LexiconDoc createSimpleQueryLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.simpleQuery", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createSimpleQueryLexiconWithDescription() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>()); // Added description
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.simpleQueryWithDescription", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createQueryWithParamsLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> params = new HashMap<>();
> 
>         params.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty()));
> 
>         params.put("p_int", new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
> 
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.paramsQuery", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createProcedureLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         Map<String, LexPrimitive> properties = new HashMap<>();
> 
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
> 
> 
>         LexXrpcBody input = new LexXrpcBody("application/json", Optional.of(new LexObject(
> 
>                 Optional.empty(), Optional.empty(), properties,
> 
>                 new ArrayList<>())), Optional.empty());
> 
> 
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(),
> 
>                 Optional.empty());
> 
> 
> 
>         LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(input), Optional.empty(), Optional.of(output),
> 
>                 new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "procedure", procedure));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.procedure", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createSubscriptionLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         Map<String, LexPrimitive> properties = new HashMap<>(); // Properties, for message
> 
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty())); // Add string property
> 
> 
> 
>         LexXrpcSubscription subscription = new LexXrpcSubscription(Optional.empty(), Optional.empty()); // Declare
> 
>                                                                                                         // subscription
> 
> 
> 
>         defs.add(new LexDefinition("main", "subscription", subscription)); // Add to Definitions.
> 
> 
> 
>         return new LexiconDoc(1, "com.example.subscription", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createMultiMethodLexicon() {  // Multiple Method Lexicon.
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Query
> 
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
> 
>             Optional.empty());   //Create Output
> 
> 
> 
>         LexXrpcQuery query =
> 
>             new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(outputQuery), new ArrayList<>());  //Create Query
> 
>         defs.add(new LexDefinition("queryMethod", "query", query)); //Add Definition
> 
> 
> 
>         // Procedure
> 
>         LexXrpcBody inputProcedure =
> 
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create input
> 
>         LexXrpcBody outputProcedure =
> 
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create output
> 
> 
> 
>         LexXrpcProcedure procedure =
> 
>             new LexXrpcProcedure(Optional.of(inputProcedure), Optional.empty(),
> 
>                 Optional.of(outputProcedure), new ArrayList<>());  //Create Procedure
> 
> 
> 
>         defs.add(new LexDefinition("procedureMethod", "procedure", procedure));   //Add Definition
> 
> 
> 
>         return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
> 
>             defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                 java.util.function.Function.identity))); //Convert Def List to Map
> 
>     }
> 
> 
> 
>     private static LexiconDoc createDuplicateMethodLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
> 
>                 Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(outputQuery), new ArrayList<>());
> 
>         defs.add(new LexDefinition("queryMethod", "query", query));
> 
>         defs.add(new LexDefinition("queryMethod", "query", query)); // Duplicate
> 
> 
> 
>         return new LexiconDoc(1, "com.example.duplicateMethod", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createNestedObjectLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Define the nested object type
> 
>         Map<String, LexPrimitive> nestedProperties = new HashMap<>();
> 
>         nestedProperties.put("innerString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexObject nestedObject = new LexObject(Optional.empty(), Optional.empty(), nestedProperties, new ArrayList<>());
> 
> 
> 
>         // Main query with an object containing the nested object
> 
>         Map<String, LexType> properties = new HashMap<>();
> 
>         properties.put("outerObject", nestedObject);
> 
> 
> 
>         LexXrpcBody output = new LexXrpcBody("application/json",
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), properties, new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(), Optional.of(output),
> 
>                 new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.nestedObject", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithParams(String id, Map<String, ? extends LexType> params) {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, id, Optional.of(0), Optional.empty(), defs.stream().collect(
> 
>                 java.util.stream.Collectors.toMap(LexDefinition::getId, java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithRefUnionParams() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Define the referenced types
> 
>         Map<String, LexPrimitive> recordDef1Props = new HashMap<>();
> 
>         recordDef1Props.put("name1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef1 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef1Props, new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         Map<String, LexPrimitive> recordDef2Props = new HashMap<>();
> 
>         recordDef2Props.put("name2",
> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef2 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef2Props,
> 
>                         new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         defs.add(new LexDefinition("recordDef1", "record", recordDef1));
> 
>         defs.add(new LexDefinition("recordDef2", "record", recordDef2));
> 
> 
> 
>         // Main query with a ref-union parameter
> 
>         Map<String, LexType> params = new HashMap<>();
> 
>         List<String> refs = List.of("#recordDef1", "#recordDef2");
> 
>         params.put("refUnionParam", new LexRefUnion(refs, Optional.empty()));
> 
> 
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.refUnionParams", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithMultipleDefs() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         LexXrpcBody output1 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query1 = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output1), new ArrayList<>());
> 
>         defs.add(new LexDefinition("query1", "query", query1));
> 
> 
> 
>         Map<String, LexPrimitive> params2 = new HashMap<>();
> 
>         params2.put("param1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty()));
> 
>         LexXrpcParameters xrpcParams2 = new LexObject(Optional.of("params"), Optional.empty(), params2,
> 
>                 new ArrayList<>());
> 
> 
> 
>         LexXrpcBody output2 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query2 = new LexXrpcQuery(Optional.of(xrpcParams2), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output2), new ArrayList<>());
> 
>         defs.add(new LexDefinition("query2", "query", query2));
> 
> 
> 
>         Map<String, LexPrimitive> recordProperties = new HashMap<>();
> 
>         recordProperties.put("name", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordProperties, new ArrayList<>())),
> 
>                 Optional.empty());
> 
>         defs.add(new LexDefinition("record1", "record", recordDef));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.multipleDefs", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithoutDefs() {
> 
>         // Create a LexiconDoc without 'defs'. This is invalid.
> 
>         return new LexiconDoc(1, "com.example.invalid", Optional.of(0), Optional.empty(), Map.of());
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithInvalidType() {
> 
>         // Create a LexiconDoc with an invalid parameter type within a query.
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> params = new HashMap<>();
> 
>         // Add an invalid type.
> 
>         params.put("invalidParam", new LexString(Optional.of("invalidtype"), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
> 
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query)); //
> 
> 
> 
>         return new LexiconDoc(1, "com.example.invalidType", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static InputStream stringToInputStream(String str) {
> 
>         return new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8));
> 
>     }
> 
> 
> 
>     public static class InMemoryCompiler {
> 
>         private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
> 
> 
> 
>         public static Class<?> compile(String className, String sourceCode)
> 
>                 throws URISyntaxException, ClassNotFoundException {
> 
>             JavaFileManager fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));
> 
> 
> 
>             List<JavaFileObject> compilationUnits = List.of(
> 
>                     new SourceFileObject(className, sourceCode));
> 
> 
> 
>             // Create a compilation task
> 
>             JavaCompiler.CompilationTask task = compiler.getTask(
> 
>                     null, // No writer, write to memory.
> 
>                     fileManager,
> 
>                     null, // No diagnostics listener
> 
>                     null, // No options
> 
>                     null, // No classes to be processed (for annotation processing)
> 
>                     compilationUnits);
> 
> 
> 
>             // Perform the compilation
> 
>             boolean success = task.call();
> 
> 
> 
>             if (!success) {
> 
>                 // For proper error reporting, we need to collect the diagnostics.
> 
>                 DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
> 
>                 JavaFileManager fileManager2 = new ClassFileManager(
> 
>                         compiler.getStandardFileManager(diagnostics, null, null));
> 
>                 compiler.getTask(
> 
>                         null, // No writer, write to memory.
> 
>                         fileManager2,
> 
>                         diagnostics,
> 
>                         null, // No options
> 
>                         null, // No classes to be processed
> 
>                         compilationUnits).call(); // Don't check success; we want to see the diagnostics in either case.
> 
> 
> 
>                 StringBuilder errorMsg = new StringBuilder();
> 
>                 errorMsg.append("Compilation failed:\n");
> 
>                 for (Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
> 
>                     errorMsg.append(diagnostic.toString()).append("\n");
> 
>                 }
> 
>                 throw new RuntimeException(errorMsg.toString());
> 
>             }
> 
> 
> 
>             // Load the compiled class
> 
>             return fileManager.getClassLoader(null).loadClass(className);
> 
>         }
> 
> 
> 
>         private static class SourceFileObject extends SimpleJavaFileObject {
> 
>             private final String sourceCode;
> 
> 
> 
>             SourceFileObject(String name, String sourceCode) throws URISyntaxException {
> 
>                 super(new URI("string:///" + name.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
> 
>                 this.sourceCode = sourceCode;
> 
>             }
> 
> 
> 
>             @Override
> 
>             public CharSequence getCharContent(boolean ignoreEncodingErrors) {
> 
>                 return CharBuffer.wrap(sourceCode);
> 
>             }
> 
>         }
> 
> 
> 
>         private static class ClassFileObject extends SimpleJavaFileObject {
> 
>             private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
> 
> 
> 
>             ClassFileObject(String name, Kind kind) throws URISyntaxException {
> 
>                 super(new URI("byte:///" + name.replace('.', '/') + kind.extension), kind);
> 
>             }
> 
> 
> 
>             byte[] getBytes() {
> 
>                 return outputStream.toByteArray();
> 
>             }
> 
> 
> 
>             @Override
> 
>             public OutputStream openOutputStream() {
> 
>                 return outputStream;
> 
>             }
> 
>         }
> 
> 
> 
>         private static class ClassFileManager extends ForwardingJavaFileManager<JavaFileManager> {
> 
>             private final Map<String, ClassFileObject> compiledClasses = new HashMap<>();
> 
> 
> 
>             ClassFileManager(JavaFileManager fileManager) {
> 
>                 super(fileManager);
> 
>             }
> 
> 
> 
>             @Override
> 
>             public ClassLoader getClassLoader(Location location) {
> 
>                 return new ClassLoader() {
> 
>                     @Override
> 
>                     protected Class<?> findClass(String name) throws ClassNotFoundException {
> 
>                         ClassFileObject classFile = compiledClasses.get(name);
> 
>                         if (classFile == null) {
> 
>                             throw new ClassNotFoundException(name);
> 
>                         }
> 
>                         byte[] bytes = classFile.getBytes();
> 
>                         return defineClass(name, bytes, 0, bytes.length);
> 
>                     }
> 
>                 };
> 
>             }
> 
> 
> 
>             @Override
> 
>             public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,
> 
>                     FileObject sibling) throws IOException {
> 
>                 try {
> 
>                     ClassFileObject fileObject = new ClassFileObject(className, kind);
> 
>                     compiledClasses.put(className, fileObject); // Store the compiled class
> 
> 
> 
>                     return fileObject;
> 
>                 } catch (URISyntaxException ex) {
> 
>                     throw new RuntimeException(ex);
> 
>                 }
> 
>             }
> 
>         }
> 
> 
> 
>         public static LexiconDoc createLexiconWithStringConstraints() {
> 
>             List<LexDefinition> defs = new ArrayList<>();
> 
>             Map<String, LexPrimitive> params = new HashMap<>();
> 
> 
> 
>             // String with maxLength
> 
>             params.put("maxLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.of(10),
> 
>                     Optional.empty(), Optional.empty()));
> 
> 
> 
>             // String with minLength
> 
>             params.put("minLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                     Optional.of(5), Optional.empty()));
> 
> 
> 
>             // String with const
> 
>             params.put("constString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                     Optional.empty(), Optional.of(List.of("constantValue"))));
> 
> 
> 
>             // String with pattern
> 
>             params.put("patternString", new LexString(Optional.empty(), Optional.of("[a-zA-Z]+"), Optional.empty(),
> 
>                     Optional.empty(), Optional.empty()));
> 
>             // String with enum
> 
> 
> 
>             List<String> enumValues = Arrays.asList("value1", "value2", "value3");
> 
>             params.put("enumString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                     Optional.empty(), Optional.of(enumValues)));
> 
> 
> 
>             LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                     new ArrayList<>());
> 
>             LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>             LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                     Optional.of(output), new ArrayList<>());
> 
>             defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>             return new LexiconDoc(1, "com.example.stringConstraints", Optional.of(0), Optional.empty(),
> 
>                     defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                             java.util.function.Function.identity())));
> 
>         }
> 
> 
> 
>         public static Stream<Arguments> provideLexiconsForStringConstraints() {
> 
>             return Stream.of(
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "maxLengthString", "String", 10, null, null,
> 
>                             null), // maxLength
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "minLengthString", "String", null, 5, null,
> 
>                             null), // minLength
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "constString", "String", null, null,
> 
>                             "constantValue", null), // const value
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "patternString", "String", null, null, null,
> 
>                             "[a-zA-Z]+") // Regex pattern
> 
>             // Arguments.of(createLexiconWithStringConstraints(), "enumString", "String",
> 
>             // null, null, null,enumValues)
> 
>             );
> 
>         }
> 
> 
> 
>     }
> 
> }
> ```
> 
> ```git diff
> diff --git a/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java b/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> index d2c6468..6c6071c 100644
> --- a/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> +++ b/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> @@ -39,34 +39,34 @@ public class ClientGeneratorTest {
>          generator = new ClientGenerator();
>      }
>  
> -
>      @Test
>      public void testGenerateClientForSimpleQuery() throws Exception { // Added Exception
> -        //Test simple Client
> -        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); //Create Lexicon.
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test simple Client
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon.
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
> -        // Basic checks (These are very basic. It should use a Java parser for real validation)
> +        // Basic checks (These are very basic. It should use a Java parser for real
> +        // validation)
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class SimpleQueryClient"));  //Has class name
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Returns AtpResponse
> +        assertTrue(generatedCode.contains("public class SimpleQueryClient")); // Has class name
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>          assertTrue(generatedCode.contains("simpleQuery(")); // Method name (same as ID)
>          assertTrue(generatedCode.contains(
> -            "xrpcClient.sendQuery"));    //Use XRPC. (should we mock for this kind of test?)
> +                "xrpcClient.sendQuery")); // Use XRPC. (should we mock for this kind of test?)
>          assertFalse(generatedCode.contains(
> -            "import com.atproto.api.xrpc.XRPCException;"));    //Doesn't import XRPC
> -
> +                "import com.atproto.api.xrpc.XRPCException;")); // Doesn't import XRPC
>  
>          // --- Compilation and Reflection ---
> -        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient", generatedCode);
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",
> +                generatedCode);
>          Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
>          java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>          xrpcClientField.setAccessible(true);
>          xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -        //Invoke and check return type.
> +        // Invoke and check return type.
>          java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
>          Object result = method.invoke(clientInstance);
>          assertInstanceOf(AtpResponse.class, result);
> @@ -75,21 +75,22 @@ public class ClientGeneratorTest {
>  
>      @Test
>      public void testGenerateClientForQueryWithParams() throws Exception { // Added Exception
> -        //Test params Client
> -        LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon();    //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test params Client
> +        LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Basic checks
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class ParamsQueryClient"));    //Class Name.
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Returns AtpResponse
> +        assertTrue(generatedCode.contains("public class ParamsQueryClient")); // Class Name.
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>          assertTrue(generatedCode.contains(
> -            "paramsQuery(ParamsQueryParams params"));   //Query method with parameters and type
> -        assertTrue(generatedCode.contains("xrpcClient.sendQuery"));  //Use XRPC
> +                "paramsQuery(ParamsQueryParams params")); // Query method with parameters and type
> +        assertTrue(generatedCode.contains("xrpcClient.sendQuery")); // Use XRPC
>  
>          // --- Compilation and Reflection ---
> -        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient", generatedCode);
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient",
> +                generatedCode);
>          Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
>          java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> @@ -99,31 +100,30 @@ public class ClientGeneratorTest {
>          Class<?> paramClass = Class.forName("com.example.ParamsQueryParams");
>          Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
>  
> -        //Invoke and check return type
> +        // Invoke and check return type
>          java.lang.reflect.Method method = generatedClientClass.getMethod("paramsQuery", paramClass);
>          Object result = method.invoke(clientInstance, paramInstance); // Pass the parameter instance
>          assertInstanceOf(AtpResponse.class, result);
>      }
>  
> -
>      @Test
>      public void testGenerateClientForProcedure() throws Exception { // Added Exception
> -        //Test Procedure
> -        LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon();   //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test Procedure
> +        LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Basic checks
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class ProcedureClient")); //Class name
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Return AtpResponse
> -        assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input"));  //Proper params
> +        assertTrue(generatedCode.contains("public class ProcedureClient")); // Class name
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Return AtpResponse
> +        assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input")); // Proper params
>          assertTrue(generatedCode.contains(
> -            "xrpcClient.sendProcedure"));  //Check for XRPC call (should be checked in its own test)
> -
> +                "xrpcClient.sendProcedure")); // Check for XRPC call (should be checked in its own test)
>  
>          // --- Compilation and Reflection ---
> -        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient", generatedCode);
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient",
> +                generatedCode);
>          Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
>          java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> @@ -133,58 +133,61 @@ public class ClientGeneratorTest {
>          Class<?> inputClass = Class.forName("com.example.ProcedureProcedureInput");
>          Object inputInstance = inputClass.getDeclaredConstructor().newInstance();
>  
> -
>          // Execute and test
> -        java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method signature
> -        Object result = method.invoke(clientInstance, inputInstance);  // Invoke with parameter
> +        java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method
> +                                                                                                   // signature
> +        Object result = method.invoke(clientInstance, inputInstance); // Invoke with parameter
>          assertInstanceOf(AtpResponse.class, result);
>      }
> -      @Test
> +
> +    @Test
>      public void testGenerateClientForSubscription() throws IOException {
> -        //Test Subscription
> -        LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon();    //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();  //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test Subscription
> +        LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Basic checks (subscriptions might have a very different structure)
> -        assertTrue(generatedCode.contains("package com.example;"));    //Package name
> +        assertTrue(generatedCode.contains("package com.example;")); // Package name
>          assertTrue(generatedCode.contains(
> -            "public class SubscriptionClient"));    //Class exists (name should automatically be generated from the name)
> -        assertTrue(generatedCode.contains("public void"));  //void return type.
> +                "public class SubscriptionClient")); // Class exists (name should automatically be generated from the
> +                                                     // name)
> +        assertTrue(generatedCode.contains("public void")); // void return type.
>          assertTrue(
> -            generatedCode.contains("subscription(")); //Subscription Method. (name should automatically be generated
> +                generatedCode.contains("subscription(")); // Subscription Method. (name should automatically be
> +                                                          // generated
>          // from the name)
>          assertTrue(generatedCode.contains(
> -            "throw new UnsupportedOperationException"));   //Subscription not implemented
> +                "throw new UnsupportedOperationException")); // Subscription not implemented
>      }
>  
>      @Test
>      public void testGenerateClientWithMultipleMethods() throws IOException {
> -        //Multiple Definitions
> -        LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon();   //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator Instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Multiple Definitions
> +        LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator Instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Check for multiple methods
> -        assertTrue(generatedCode.contains("queryMethod("));    //Query exists
> -        assertTrue(generatedCode.contains("procedureMethod("));    //Procedure Exists
> +        assertTrue(generatedCode.contains("queryMethod(")); // Query exists
> +        assertTrue(generatedCode.contains("procedureMethod(")); // Procedure Exists
>      }
>  
> -
>      // Test for duplicate method names. Should de-dupe
>      @Test
>      public void testGenerateClientWithDuplicateMethods() throws IOException {
>          LexiconDoc lexiconDoc = TestUtils.createDuplicateMethodLexicon();
> -         ClientGenerator generator = new ClientGenerator();
> +        ClientGenerator generator = new ClientGenerator();
>  
> -         String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
> -         // Check for multiple methods
> -         assertEquals(1, countOccurrences(generatedCode, "queryMethod"));    //Query exists
> +        // Check for multiple methods
> +        assertEquals(1, countOccurrences(generatedCode, "queryMethod")); // Query exists
>  
>      }
>  
> -    // Helper Method. (Need to find something more formal; maybe write one of my own)
> +    // Helper Method. (Need to find something more formal; maybe write one of my
> +    // own)
>      public int countOccurrences(String text, String word) {
>  
>          int count = 0; // Initialize a counter variable
> @@ -199,49 +202,49 @@ public class ClientGeneratorTest {
>          return count;
>      }
>  
> -
> -
> -    //Test that XRPC Exception gets thrown.
> +    // Test that XRPC Exception gets thrown.
>      @Test
>      public void testXRPCException() throws IOException {
> -        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); //Create Lexicon. (doesn't really matter which Lexicon
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
> +                                                                      // Lexicon
>          // we make, just need one)
>  
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          assertTrue(generatedCode.contains(
> -            "import com.atproto.api.xrpc.XRPCException;")); // Should import exception
> +                "import com.atproto.api.xrpc.XRPCException;")); // Should import exception
>      }
>  
> -    //Test that AtpResponse gets imported.
> +    // Test that AtpResponse gets imported.
>      @Test
>      public void testAtpResponseType() throws IOException {
> -        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); //Create Lexicon. (doesn't really matter which Lexicon
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
> +                                                                      // Lexicon
>          // we make, just need one)
>  
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          assertTrue(generatedCode.contains(
> -            "import com.atproto.api.AtpResponse;"));        //Should import AtpResponse
> +                "import com.atproto.api.AtpResponse;")); // Should import AtpResponse
>      }
>  
> -
> -
>      // Helper methods for creating Lexicon structures (for test readability)
>      // These would ideally be in a separate test utility class.
>  
>      @ParameterizedTest
>      @MethodSource("provideLexiconsForAllParameterTypes")
> -    public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType) throws Exception { //Added Exception
> +    public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType)
> +            throws Exception { // Added Exception
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>  
>          // General checks (package, class name, etc.)
>          assertTrue(generatedCode.contains("package com.example;"));
>  
> -        // More specific checks based on parameter type.  This is where we use the paramName.
> +        // More specific checks based on parameter type. This is where we use the
> +        // paramName.
>          assertTrue(generatedCode.contains(paramName)); // Very basic, does the parameter exist?
>  
>          // Check that parameter type is correct
> @@ -257,8 +260,7 @@ public class ClientGeneratorTest {
>          xrpcClientField.setAccessible(true);
>          xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -
> -        // Find the method and its return type.  This assumes the method name is "main"
> +        // Find the method and its return type. This assumes the method name is "main"
>          java.lang.reflect.Method method = null;
>          for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
>              if (m.getName().equals("main")) { // Or whatever the method name is in your generated code
> @@ -271,171 +273,177 @@ public class ClientGeneratorTest {
>          // Get Return Type from Lexicon, create expected type from this
>          String expectedReturnType = "AtpResponse"; // Default
>          if (lexiconDoc.getDefs().get("main") instanceof LexXrpcQuery) {
> -                LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
> -                 if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
> -                   expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
> -                } else {
> -                   expectedReturnType = "AtpResponse<Void>";
> -                }
> +            LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
> +            if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
> +                expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
> +            } else {
> +                expectedReturnType = "AtpResponse<Void>";
> +            }
>          } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcProcedure) {
>              LexXrpcProcedure procedure = (LexXrpcProcedure) lexiconDoc.getDefs().get("main");
> -             if (procedure.getOutput().isPresent()&& procedure.getOutput().get().getSchema().isPresent()) {
> -                    expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get()) + ">";
> +            if (procedure.getOutput().isPresent() && procedure.getOutput().get().getSchema().isPresent()) {
> +                expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get())
> +                        + ">";
>  
> -             } else {
> +            } else {
>                  expectedReturnType = "AtpResponse<Void>";
> -             }
> +            }
>          } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcSubscription) {
>              expectedReturnType = "void";
>          }
>  
>          // Now we assert that the return type from code gen is as expected
> -        String actualReturnType = method.getGenericReturnType().getTypeName().replace("java.util.concurrent.CompletableFuture", "AtpResponse");
> +        String actualReturnType = method.getGenericReturnType().getTypeName()
> +                .replace("java.util.concurrent.CompletableFuture", "AtpResponse");
>          assertEquals(expectedReturnType, actualReturnType);
>      }
>  
> -    //Helper function to return expected Java type String from Lexicon definition.
> +    // Helper function to return expected Java type String from Lexicon definition.
>      private String getExpectedJavaType(LexXrpcBody xrpcBody) {
>  
>          if (xrpcBody.getSchema().isEmpty()) {
> -          return "Void";
> +            return "Void";
>          }
>  
>          LexXrpcBody schema = xrpcBody;
>          if (schema.getSchema().get() instanceof LexObject) {
> -            return "Object"; // Placeholder,  replace with generated class name if using nested objects.
> +            return "Object"; // Placeholder, replace with generated class name if using nested objects.
>          } else if (schema.getSchema().get() instanceof LexArray) {
> -             LexArray lexArray = (LexArray) schema.getSchema().get();
> -              // Handle nested arrays
> +            LexArray lexArray = (LexArray) schema.getSchema().get();
> +            // Handle nested arrays
>              return getExpectedArrayType(lexArray);
>          } else if (schema.getSchema().get() instanceof LexPrimitive) {
>              return getExpectedPrimitiveType((LexPrimitive) schema.getSchema().get());
>          } else if (schema.getSchema().get() instanceof LexXrpcBody) {
> -             return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
> -        } else if (schema.getSchema().get() instanceof  LexRef ) {
> -            //Resolve references, including repository refs vs. defs refs.  This is very basic.
> -            LexRef ref = (LexRef)schema.getSchema().get();
> +            return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
> +        } else if (schema.getSchema().get() instanceof LexRef) {
> +            // Resolve references, including repository refs vs. defs refs. This is very
> +            // basic.
> +            LexRef ref = (LexRef) schema.getSchema().get();
>              String refStr = ref.getRef();
>              if (refStr.startsWith("#")) {
> -                return refStr.substring(refStr.lastIndexOf(".") + 1);  //Local ref
> +                return refStr.substring(refStr.lastIndexOf(".") + 1); // Local ref
>              } else {
> -                return refStr.replace(".", ""); //External ref
> +                return refStr.replace(".", ""); // External ref
>              }
> -        }  else if (schema.getSchema().get() instanceof LexString) {
> +        } else if (schema.getSchema().get() instanceof LexString) {
>              LexString lexString = (LexString) schema.getSchema().get();
>              if (lexString.getFormat().isPresent()) {
>                  if (lexString.getFormat().equals("datetime")) {
> -                   return "java.time.Instant";
> +                    return "java.time.Instant";
>                  } else if (lexString.getFormat().equals("cid")) {
> -                  return   "com.atproto.common.Cid";
> -                }  else if (lexString.getFormat().equals("did")) {
> +                    return "com.atproto.common.Cid";
> +                } else if (lexString.getFormat().equals("did")) {
>                      return "com.atproto.syntax.Did";
>                  } else if (lexString.getFormat().equals("handle")) {
> -                     return "com.atproto.syntax.Handle";
> -                }  else if (lexString.getFormat().equals("at-uri")) {
> -                    return  "com.atproto.syntax.AtUri";
> -                }  else if (lexString.getFormat().equals("nsid")) {
> -                     return "com.atproto.syntax.Nsid";
> -                }  else if (lexString.getFormat().equals("uri")) {
> +                    return "com.atproto.syntax.Handle";
> +                } else if (lexString.getFormat().equals("at-uri")) {
> +                    return "com.atproto.syntax.AtUri";
> +                } else if (lexString.getFormat().equals("nsid")) {
> +                    return "com.atproto.syntax.Nsid";
> +                } else if (lexString.getFormat().equals("uri")) {
>                      return "java.net.URI";
> -                }   else if (lexString.getFormat().equals("language")) {
> +                } else if (lexString.getFormat().equals("language")) {
>                      return "java.util.Locale";
> -                }  else if (lexString.getFormat().equals("uri-reference")) {
> -                    return "java.net.URI";  // Assuming URI for uri-reference
> -                }   else if (lexString.getFormat().equals("uri-template")) {
> -                     return "java.lang.String";  // Assuming String for uri-template (no built-in type)
> -                }   else if (lexString.getFormat().equals("email")) {
> -                     return "java.lang.String";       // Assuming String for email
> -                }   else if (lexString.getFormat().equals("hostname")) {
> -                      return "java.lang.String";       // Assuming String for hostname
> -                }  else if (lexString.getFormat().equals("ipv4")) {
> -                   return "java.net.InetAddress";    // Assuming InetAddress for IPv4
> -                }   else if (lexString.getFormat().equals("ipv6")) {
> -                     return "java.net.InetAddress";    // Assuming InetAddress for IPv6
> +                } else if (lexString.getFormat().equals("uri-reference")) {
> +                    return "java.net.URI"; // Assuming URI for uri-reference
> +                } else if (lexString.getFormat().equals("uri-template")) {
> +                    return "java.lang.String"; // Assuming String for uri-template (no built-in type)
> +                } else if (lexString.getFormat().equals("email")) {
> +                    return "java.lang.String"; // Assuming String for email
> +                } else if (lexString.getFormat().equals("hostname")) {
> +                    return "java.lang.String"; // Assuming String for hostname
> +                } else if (lexString.getFormat().equals("ipv4")) {
> +                    return "java.net.InetAddress"; // Assuming InetAddress for IPv4
> +                } else if (lexString.getFormat().equals("ipv6")) {
> +                    return "java.net.InetAddress"; // Assuming InetAddress for IPv6
>  
>                  }
>              }
> -             return  "String";
> -        } else if (schema.getSchema().get() instanceof LexRefUnion){
> -             return "Object";
> +            return "String";
> +        } else if (schema.getSchema().get() instanceof LexRefUnion) {
> +            return "Object";
>          }
>  
> -       return "Object"; //Unreachable? Error?
> +        return "Object"; // Unreachable? Error?
>      }
> -      private String getExpectedArrayType(LexArray lexArray) {
> -                StringBuilder sb = new StringBuilder();
> +
> +    private String getExpectedArrayType(LexArray lexArray) {
> +        StringBuilder sb = new StringBuilder();
>          sb.append("java.util.List<");
>          LexType itemType = lexArray.getItems();
>  
>          if (itemType instanceof LexPrimitive) {
> -            sb.append(getExpectedPrimitiveType((LexPrimitive)itemType));
> +            sb.append(getExpectedPrimitiveType((LexPrimitive) itemType));
>          } else if (itemType instanceof LexArray) {
>              sb.append(getExpectedArrayType((LexArray) itemType)); // Recurse for nested arrays
>          } else if (itemType instanceof LexRef) {
> -        	//Resolve references
> -        	LexRef ref = (LexRef)itemType;
> +            // Resolve references
> +            LexRef ref = (LexRef) itemType;
>              String refStr = ref.getRef();
>              if (refStr.startsWith("#")) {
> -                sb.append( refStr.substring(refStr.lastIndexOf(".") + 1));
> +                sb.append(refStr.substring(refStr.lastIndexOf(".") + 1));
>              } else {
> -                sb.append( refStr.replace(".", ""));
> +                sb.append(refStr.replace(".", ""));
>              }
>          } else if (itemType instanceof LexRefUnion) {
> -             sb.append("Object"); // No specific type in a refUnion
> -        } else if (itemType instanceof LexObject) { //Nested object not allowed as Array
> +            sb.append("Object"); // No specific type in a refUnion
> +        } else if (itemType instanceof LexObject) { // Nested object not allowed as Array
>              return "Object";
>          }
>  
>          sb.append(">");
>          return sb.toString();
>      }
> +
>      private String getExpectedPrimitiveType(LexPrimitive prim) {
>          if (prim instanceof LexBoolean) {
>              return "Boolean";
>          } else if (prim instanceof LexInteger) {
>              return "Integer";
>          } else if (prim instanceof LexString) {
> -           return "String";
> +            return "String";
>          } else if (prim instanceof LexNumber) {
> -           return "Float";
> +            return "Float";
>          } else if (prim instanceof LexBytes) {
> -           return "byte[]";
> -        }else if (prim instanceof LexUnknown){
> -          return "java.util.Map<String, Object>";
> +            return "byte[]";
> +        } else if (prim instanceof LexUnknown) {
> +            return "java.util.Map<String, Object>";
>          }
>          return "Object"; // Should not happen in valid Lexicon
>      }
>  
>      @Test
> -    public void testGenerateClientForNestedObject() throws Exception { //Added Exception
> +    public void testGenerateClientForNestedObject() throws Exception { // Added Exception
>          LexiconDoc lexiconDoc = TestUtils.createNestedObjectLexicon();
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>  
>          // Basic checks
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class NestedObjectClient"));    //Class Name.
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Returns AtpResponse
> +        assertTrue(generatedCode.contains("public class NestedObjectClient")); // Class Name.
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>          assertTrue(generatedCode.contains(
> -                "nestedObject("));   //Query method with parameters and type
> -
> +                "nestedObject(")); // Query method with parameters and type
>  
> -       // --- Compilation and Reflection, as before, BUT: ---
> -       // 1.  Compile and Get Class:
> -       Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient", generatedCode);
> -       Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> +        // --- Compilation and Reflection, as before, BUT: ---
> +        // 1. Compile and Get Class:
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient",
> +                generatedCode);
> +        Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
> -       // 2. Inject Mock:
> -       java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> -       xrpcClientField.setAccessible(true);
> -       xrpcClientField.set(clientInstance, mockXrpcClient);
> +        // 2. Inject Mock:
> +        java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> +        xrpcClientField.setAccessible(true);
> +        xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -       // 3.  Get and Invoke Method, Assert Return Type
> -       java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
> -       Object result = method.invoke(clientInstance);
> -       assertInstanceOf(AtpResponse.class, result); // Very basic check
> +        // 3. Get and Invoke Method, Assert Return Type
> +        java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
> +        Object result = method.invoke(clientInstance);
> +        assertInstanceOf(AtpResponse.class, result); // Very basic check
>  
> -        //You could add in more specific checks with Mockito here to check call parameters
> +        // You could add in more specific checks with Mockito here to check call
> +        // parameters
>      }
>  
>      @ParameterizedTest
> @@ -445,36 +453,40 @@ public class ClientGeneratorTest {
>          assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));
>      }
>  
> -
>      @Test
> -    public void  testMultipleDefs() throws IOException{
> +    public void testMultipleDefs() throws IOException {
>          LexiconDoc lexiconDoc = TestUtils.createLexiconWithMultipleDefs();
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>          assertTrue(generatedCode.contains("class Query1Client"));
>          assertTrue(generatedCode.contains("class Query2Client"));
> -        assertTrue(generatedCode.contains("class Record1Record")); //Check for records.
> +        assertTrue(generatedCode.contains("class Record1Record")); // Check for records.
>  
>      }
>  
>      @Test
> -    public void testGenerateClientForRefUnionParams() throws Exception {    //Added Exception
> +    public void testGenerateClientForRefUnionParams() throws Exception { // Added Exception
>          LexiconDoc lexiconDoc = TestUtils.createLexiconWithRefUnionParams();
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>  
>          assertTrue(generatedCode.contains("package com.example;"));
>          assertTrue(generatedCode.contains("public class RefUnionParamsClient"));
> -        // Check that the generated code includes the expected parameter and return type (adjust as per codegen)
> -        // NOTE: This will likely need changing based on how you generate method signatures.
> -        assertTrue(generatedCode.contains("public AtpResponse refUnionParams(Object params)")); //Object because it could be either one of the Record Types.
> +        // Check that the generated code includes the expected parameter and return type
> +        // (adjust as per codegen)
> +        // NOTE: This will likely need changing based on how you generate method
> +        // signatures.
> +        assertTrue(generatedCode.contains("public AtpResponse refUnionParams(Object params)")); // Object because it
> +                                                                                                // could be either one
> +                                                                                                // of the Record Types.
>  
>      }
> -      @Test
> -   public void testJavadocGeneration() throws Exception { //Added Exception
> -       LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
> -       ClientGenerator generator = new ClientGenerator();
> -       String generatedCode = generator.generateClient(lexiconDoc);
> +
> +    @Test
> +    public void testJavadocGeneration() throws Exception { // Added Exception
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
> +        ClientGenerator generator = new ClientGenerator();
> +        String generatedCode = generator.generateClient(lexiconDoc);
>  
>          // Basic Javadoc checks
>          assertTrue(generatedCode.contains("/**"));
> @@ -482,17 +494,18 @@ public class ClientGeneratorTest {
>          assertTrue(generatedCode.contains("*/"));
>          assertTrue(generatedCode.contains("public class SimpleQueryClientWithDescription"));
>  
> -       // Compile and load the class, then verify with reflection
> -       Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClientWithDescription", generatedCode);
> +        // Compile and load the class, then verify with reflection
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler
> +                .compile("com.example.SimpleQueryClientWithDescription", generatedCode);
>          java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> -        assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more thorough.
> +        assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more
> +                                                                                  // thorough.
>  
> +    }
>  
> -   }
> -    
> -   @ParameterizedTest
> -   @MethodSource("provideLexiconsForStringConstraints")
> -   public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
> +    @ParameterizedTest
> +    @MethodSource("provideLexiconsForStringConstraints")
> +    public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
>              Integer maxLength, Integer minLength, String constValue, String pattern) throws Exception {
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
> @@ -514,17 +527,15 @@ public class ClientGeneratorTest {
>              }
>          }
>          Class<?> paramClass = method.getParameterTypes()[0];
> -          // Now using reflection
> +        // Now using reflection
>          java.lang.reflect.Field paramField = null;
> -         try {
> -              paramField = paramClass.getDeclaredField(paramName);
> -
> -          } catch (Exception e) {
> -                 failCount++;
> -               fail("parameter not found in parameters of generated class.");
> -          }
> -
> +        try {
> +            paramField = paramClass.getDeclaredField(paramName);
>  
> +        } catch (Exception e) {
> +            failCount++;
> +            fail("parameter not found in parameters of generated class.");
> +        }
>  
>          // maxLength constraint
>          if (maxLength != null) {
> @@ -538,11 +549,11 @@ public class ClientGeneratorTest {
>  
>          // const constraint
>          if (constValue != null) {
> -            assertTrue(generatedCode.contains("public static final String " + paramName.toUpperCase() + " = \"" + constValue + "\";"));
> -       }
> +            assertTrue(generatedCode
> +                    .contains("public static final String " + paramName.toUpperCase() + " = \"" + constValue + "\";"));
> +        }
>      }
>  
> -
>      // Data Providers
>      private static Stream<Arguments> provideLexiconsForAllParameterTypes() {
>          List<Arguments> argList = new ArrayList<>();
> @@ -618,38 +629,38 @@ public class ClientGeneratorTest {
>          stringFormatParams.put("languageParam", new LexString(Optional.of("language"),
>                  Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("uriParam", new LexString(Optional.of("uri"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("uriRefParam", new LexString(Optional.of("uri-reference"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("uriTemplateParam", new LexString(Optional.of("uri-template"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("emailParam", new LexString(Optional.of("email"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("hostnameParam", new LexString(Optional.of("hostname"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("ipv4Param", new LexString(Optional.of("ipv4"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>          stringFormatParams.put("ipv6Param", new LexString(Optional.of("ipv6"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> +                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>  
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
>                          "atUriParam", "com.atproto.syntax.AtUri"));
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "cidParam", "com.atproto.common.Cid")); //Assuming you have a Cid class.
> +                        "cidParam", "com.atproto.common.Cid")); // Assuming you have a Cid class.
>  
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "didParam", "com.atproto.syntax.Did")); //Assuming you have a Did class
> +                        "didParam", "com.atproto.syntax.Did")); // Assuming you have a Did class
>  
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "handleParam", "com.atproto.syntax.Handle")); //Assuming you have a Handle class
> +                        "handleParam", "com.atproto.syntax.Handle")); // Assuming you have a Handle class
>  
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "nsidParam", "com.atproto.syntax.Nsid")); //Assuming you have an NSID class.
> +                        "nsidParam", "com.atproto.syntax.Nsid")); // Assuming you have an NSID class.
>  
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> @@ -658,27 +669,27 @@ public class ClientGeneratorTest {
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
>                          "languageParam", "java.util.Locale"));
> -	          argList.add(
> +        argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
>                          "uriParam", "java.net.URI"));
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "uriRefParam", "java.net.URI"));  // Assuming URI for uri-reference
> +                        "uriRefParam", "java.net.URI")); // Assuming URI for uri-reference
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "uriTemplateParam", "java.lang.String"));  // Assuming String for uri-template (no built-in type)
> +                        "uriTemplateParam", "java.lang.String")); // Assuming String for uri-template (no built-in type)
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "emailParam", "java.lang.String"));       // Assuming String for email
> +                        "emailParam", "java.lang.String")); // Assuming String for email
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "hostnameParam", "java.lang.String"));      // Assuming String for hostname
> +                        "hostnameParam", "java.lang.String")); // Assuming String for hostname
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "ipv4Param", "java.net.InetAddress"));    // Assuming InetAddress for IPv4
> +                        "ipv4Param", "java.net.InetAddress")); // Assuming InetAddress for IPv4
>          argList.add(
>                  Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "ipv6Param", "java.net.InetAddress"));    // Assuming InetAddress for IPv6
> +                        "ipv6Param", "java.net.InetAddress")); // Assuming InetAddress for IPv6
>          return argList.stream();
>      }
>  
> @@ -692,12 +703,14 @@ public class ClientGeneratorTest {
>          );
>  
>      }
> -     private static Stream < Arguments > provideLexiconsForStringConstraints () { 
> -            return Stream . of ( 
> -                Arguments . of ( createLexiconWithStringConstraints (), "maxLengthString" , "String" , 10 , null , null , null ), 
> -                Arguments . of ( createLexiconWithStringConstraints (), "minLengthString" , "String" , null , 5 , null , null ), 
> -                Arguments . of ( createLexiconWithStringConstraints (), "constString" , "String" , null , null , "constantValue" , null ), 
> -                Arguments . of ( createLexiconWithStringConstraints (), "patternString" , "String" , null , null , null , "[a-zA-Z]+" ) 
> -            ); 
> -    } 
> +
> +    private static Stream<Arguments> provideLexiconsForStringConstraints() {
> +        return Stream.of(
> +                Arguments.of(createLexiconWithStringConstraints(), "maxLengthString", "String", 10, null, null, null),
> +                Arguments.of(createLexiconWithStringConstraints(), "minLengthString", "String", null, 5, null, null),
> +                Arguments.of(createLexiconWithStringConstraints(), "constString", "String", null, null, "constantValue",
> +                        null),
> +                Arguments.of(createLexiconWithStringConstraints(), "patternString", "String", null, null, null,
> +                        "[a-zA-Z]+"));
> +    }
>  }
> \ No newline at end of file
> 
> diff --git a/src/main/test/java/com/atproto/codegen/TestUtils.java b/src/main/test/java/com/atproto/codegen/TestUtils.java
> index e19db33..1baeb4b 100644
> --- a/src/main/test/java/com/atproto/codegen/TestUtils.java
> +++ b/src/main/test/java/com/atproto/codegen/TestUtils.java
> @@ -127,7 +127,7 @@ public class TestUtils {
>  
>          return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
>              defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> -                java.util.function.Function.identity"))); //Convert Def List to Map
> +                java.util.function.Function.identity))); //Convert Def List to Map
>      }
>  
>      private static LexiconDoc createDuplicateMethodLexicon() {
> 
> ```
> 
> URL: https://atproto.com/ URL: https://github.com/bluesky-social/atproto URL: https://github.com/bluesky-social/atproto/tree/main/packages/api URL: https://github.com/bluesky-social/indigo/tree/main URL: https://github.com/MarshalX/atproto URL: https://atproto.blue/en/latest/index.html Typescript NodeJS Go Python 
> Kotlin Docs URL: https://github.com/uakihir0/kbsky 
> Java 21 LTS Maven Documentation I want to build a Java implementation of Bluesky's ATProtocol. The goal is to build a package JAR file that anyone can use as a base to build a Java program from. I want to utilize the official Typescript imlementation as a reference to preferably port their code to Java, or to build my own version from.
> We're going to build out the Lexicon generator. It needs to be as complete as the Typescript implementation since that's the one that's absolutely confirmed working. But you also need to factor in the other versions - especially the Kotlin version (since Kotlin is a "dielect" of Java).
> Let's build it using a test-driven development model. We're working on the ClientGeneratorTest.java file right now. We need to check it to confirm that the ATProtocol Lexicon revisions and optionals are being handled correctly. Please do that and present the full code of the modified files.
> ClientGeneratorTest.java TestUtils.java Git Diff 

#### _Assistant_

> Okay, let's analyze the provided `ClientGeneratorTest.java` and `TestUtils.java` files, focusing on how they handle Lexicon revisions, optionals, and overall completeness compared to the TypeScript reference implementation.  I'll also keep an eye out for opportunities to align with the Kotlin approach where it makes sense.
> 
> **Analysis and Proposed Changes (with justifications)**
> 
> 1.  **Completeness and Alignment with TypeScript:**
> 
>     *   The tests cover various Lexicon features: queries, procedures, subscriptions, parameters (of different types), nested objects, ref unions, string constraints (maxLength, minLength, const, pattern), and Javadoc generation.  This is a good starting point.
>     *   The tests use reflection to inspect the generated code, checking for method signatures, parameter types, and annotations. This dynamic analysis is crucial for ensuring correctness.
>     *   The `TestUtils.java` file provides helper methods to create `LexiconDoc` instances representing different Lexicon structures. This approach is effective for testing various scenarios systematically.
>     *   The use of mocks for interacting with an XRPC is a solid start. This enables more fine-grained testing
> 
> 2.  **Lexicon Revisions (`lex` field):**
> 
>     *   The `LexiconDoc` constructor takes a `lex` parameter (an integer), representing the Lexicon version.  The existing tests consistently use `1` as the version.
>     *  **Enhancement (Test Coverage):** We need to expand the existing tests to cover different `lex` values to confirm the generated output is consistent with the specified Lexicon version. It's essential to cover both valid revision numbers to cover at least two revisions, and potentially invalid/unsupported revisions to verify proper error handling in `ClientGenerator`. The test code should be expanded to test different Lex versions (`lex`) to cover valid vs. invalid revision numbers. The tests should check that the generator properly handles or rejects different Lexicon versions(using `@ParameterizedTest` and `@MethodSource`).
> 
> 3.  **Optionals:**
> 
>     *   The tests and `LexiconDoc` construction methods already handle optional fields reasonably well using `Optional.empty()` and `Optional.of()`.  This is consistent with how optionals are represented in the Lexicon schema.
>     *  **No specific changes immediately needed,** but we should remain vigilant as we add more complex tests. When adding new lexicon definitions to `TestUtils.java`, ensure that both missing and defined cases are added.
> 
> 4.  **Parameter and Return Type Handling:**
> 
>     *   The `provideLexiconsForAllParameterTypes` method and its associated test (`testGenerateClientForVariousParameterTypes`) cover a broad range of parameter types, including primitives, strings with formats, arrays, and `LexUnknown`. This thoroughness is excellent.
>     *   The `getExpectedJavaType` method correctly maps Lexicon types to their Java counterparts (e.g., `LexInteger` to `Integer`, `LexString` with format "datetime" to `java.time.Instant`).  This is critical for type safety.
>     *   The tests verify that method signatures in the generated code match the expected types, both for parameters and return values.  This includes handling `AtpResponse` and generic type parameters (e.g., `AtpResponse<Object>`).
>     *  **Minor suggestion:**  The test `testXRPCException` checks that the exception is imported. We'll want a better test than just verifying the import, and make sure it checks that the exception is *thrown* under the right circumstances. That can be handled with an enhancement below. This would use something like `when(mockXrpcClient.sendQuery(...)).thenThrow(new XRPCException(...));`
>     *  **Enhancement (Ref Union Handling):** Expand `testGenerateClientForRefUnionParams` to be parameterized. It currently only asserts that an `Object` parameter is used, which is the correct fallback.  However, good tests should create multiple scenarios with various combinations of ref unions to ensure the generator correctly produces the expected model classes.
> 
> 5.  **String Constraints:**
> 
>     *   The `testStringConstraints` and `provideLexiconsForStringConstraints` methods, along with `createLexiconWithStringConstraints`, cover `maxLength`, `minLength`, `const`, and `pattern` constraints. This validates that the generator correctly applies these constraints as annotations (e.g., `@MaxLength(10)`).
>     *   **Enhancement (Completeness):**  The current implementation, with `assertTrue(generatedCode.contains(...))`, is fragile.  We should use more robust checks, preferably leveraging reflection to examine the annotations directly.  This is more reliable than string matching.
>     *   **Enhancement (Completeness):** The string constrains should also be expanded to handle numeric constraints as well, like `minimum`, and `maximum` for integers. This can be done in a similar way to `provideLexiconsForStringConstraints` for the `LexInteger` cases.
>     *  **Enhancement (Robustness):** The test should attempt to *violate* the constraints and verify that validation errors are raised appropriately. This should involve making xrpc method calls using Mockito to verify the parameters by returning `XRPCException`.
> 
> 6.   **Javadoc Generation**
> 
>     *   Javadoc is also well tested. While the provided code includes tests for Javadoc generation (`testJavadocGeneration`), no enhancements are necessary at this time. Javadoc generation is handled correctly.
> 
> 7.  **Error Handling:**
> 
>     *   The `provideLexiconsForInvalidLexicons` and `testInvalidLexiconStructure` methods check for exceptions when the Lexicon structure is invalid (e.g., missing `defs`, invalid types).  This is good for ensuring robustness.
>     *  **Enhancement (Specificity):** Instead of just checking for throwing an `IllegalArgumentException`, which is a bit broad, it would be preferable to define more specific custom exception types (e.g., `InvalidLexiconException`, `UnsupportedLexiconTypeException`) and assert those. This makes the tests more informative.
> 
> 8.  **Code Style and Organization:**
> 
>     *   The test code is well-organized, with clear method names and helper functions.
>     *   The use of parameterized tests (`@ParameterizedTest`, `@MethodSource`) is excellent for concisely testing multiple variations of a feature.
>     *   **Suggestion (Refactoring):** `TestUtils.java` could potentially be split into smaller, more focused utility classes (e.g., `LexiconDocFactory`, `InMemoryCompiler`) as the number of helper methods grows.
> 
> 9.  **Mockito Best Practices**
> 
>     *   You are using `@Mock` and `@ExtendWith(MockitoExtension.class)`, a good practice.
>     *   **Enhancement (Stubbing):** Add actual stubbing to the tests. Currently, `mockXrpcClient` isn't configured to return anything. For more comprehensive testing, use `when(...).thenReturn(...)`, `when(...).thenThrow(...)`, and other Mockito stubbing methods to simulate different XRPC responses and error conditions. This is critical for testing error handling and response processing.
> 
> 10. **Enhancement (Test Coverage):** Add test coverage for arrays with array item limits `maxLength`, and `minLength`.
> 
> **Revised Code (with detailed changes)**
> 
> ```java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> package com.atproto.codegen;
> 
> import static org.junit.jupiter.api.Assertions.*;
> import static org.mockito.Mockito.*;
> 
> import com.atproto.api.AtpResponse;
> import com.atproto.api.xrpc.XRPCException;
> import com.atproto.lexicon.models.*;
> 
> import java.io.IOException;
> import java.lang.annotation.Annotation;
> import java.lang.reflect.Field;
> import java.time.Instant;
> import java.util.ArrayList;
> import java.util.HashMap;
> import java.util.List;
> import java.util.Map;
> import java.util.Optional;
> import java.util.stream.Stream;
> 
> import javax.validation.constraints.*;
> 
> import org.junit.jupiter.api.BeforeEach;
> import org.junit.jupiter.api.Test;
> import org.junit.jupiter.params.ParameterizedTest;
> import org.junit.jupiter.params.provider.Arguments;
> import org.junit.jupiter.params.provider.MethodSource;
> import org.mockito.junit.jupiter.MockitoExtension;
> import org.junit.jupiter.api.extension.ExtendWith;
> import org.mockito.Mock;
> 
> @ExtendWith(MockitoExtension.class)
> public class ClientGeneratorTest {
> 
>     @Mock
>     private XrpcClient mockXrpcClient;
> 
>     private ClientGenerator generator;
> 
>     @BeforeEach
>     public void setUp() {
>         generator = new ClientGenerator();
>     }
> 
>     @Test
>     public void testGenerateClientForSimpleQuery() throws Exception {
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         assertTrue(generatedCode.contains("package com.example;"));
>         assertTrue(generatedCode.contains("public class SimpleQueryClient"));
>         assertTrue(generatedCode.contains("public AtpResponse"));
>         assertTrue(generatedCode.contains("simpleQuery("));
>         assertTrue(generatedCode.contains(
>                 "xrpcClient.sendQuery"));
>         assertFalse(generatedCode.contains(
>                 "import com.atproto.api.xrpc.XRPCException;"));
> 
>         // --- Compilation and Reflection ---
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",
>                 generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         // Stub the mockXrpcClient to return a successful response
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>         // Invoke and check return type.
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
>         Object result = method.invoke(clientInstance);
>         assertInstanceOf(AtpResponse.class, result);
> 
>     }
> 
>     @Test
>     public void testGenerateClientForQueryWithParams() throws Exception { // Added Exception
>         // Test params Client
>         LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon(); // Create Lexicon
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
>         // Basic checks
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
>         assertTrue(generatedCode.contains("public class ParamsQueryClient")); // Class Name.
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>         assertTrue(generatedCode.contains(
>                 "paramsQuery(ParamsQueryParams params")); // Query method with parameters and type
>         assertTrue(generatedCode.contains("xrpcClient.sendQuery")); // Use XRPC
> 
>         // --- Compilation and Reflection ---
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient",
>                 generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         // Stub
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>         Class<?> paramClass = Class.forName("com.example.ParamsQueryParams");
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
> 
> 
>         // Invoke and check return type
>         java.lang.reflect.Method method = generatedClientClass.getMethod("paramsQuery", paramClass);
>         Object result = method.invoke(clientInstance, paramInstance); // Pass the parameter instance
>         assertInstanceOf(AtpResponse.class, result);
> 
>     }
> 
>     @Test
>     public void testGenerateClientForProcedure() throws Exception { // Added Exception
>         // Test Procedure
>         LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon(); // Create Lexicon
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
>         // Basic checks
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
>         assertTrue(generatedCode.contains("public class ProcedureClient")); // Class name
>         assertTrue(generatedCode.contains("public AtpResponse")); // Return AtpResponse
>         assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input")); // Proper params
>         assertTrue(generatedCode.contains(
>                 "xrpcClient.sendProcedure")); // Check for XRPC call (should be checked in its own test)
> 
>         // --- Compilation and Reflection ---
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient",
>                 generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>          // Stub
>         when(mockXrpcClient.sendProcedure(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>         Class<?> inputClass = Class.forName("com.example.ProcedureProcedureInput");
>         Object inputInstance = inputClass.getDeclaredConstructor().newInstance();
> 
>         // Execute and test
>         java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method
>                                                                                                    // signature
>         Object result = method.invoke(clientInstance, inputInstance); // Invoke with parameter
>         assertInstanceOf(AtpResponse.class, result);
>     }
> 
>     @Test
>     public void testGenerateClientForSubscription() throws IOException {
>         // Test Subscription
>         LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon(); // Create Lexicon
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
>         // Basic checks (subscriptions might have a very different structure)
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
>         assertTrue(generatedCode.contains(
>                 "public class SubscriptionClient")); // Class exists (name should automatically be generated from the
>                                                      // name)
>         assertTrue(generatedCode.contains("public void")); // void return type.
>         assertTrue(
>                 generatedCode.contains("subscription(")); // Subscription Method. (name should automatically be
>                                                           // generated
>         // from the name)
>         assertTrue(generatedCode.contains(
>                 "throw new UnsupportedOperationException")); // Subscription not implemented
>     }
> 
>     @Test
>     public void testGenerateClientWithMultipleMethods() throws IOException {
>         // Multiple Definitions
>         LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon(); // Create Lexicon
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator Instance
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
>         // Check for multiple methods
>         assertTrue(generatedCode.contains("queryMethod(")); // Query exists
>         assertTrue(generatedCode.contains("procedureMethod(")); // Procedure Exists
>     }
> 
> 
>     // Test for duplicate method names. Should de-dupe
>     @Test
>     public void testGenerateClientWithDuplicateMethods() throws IOException {
>         LexiconDoc lexiconDoc = TestUtils.createDuplicateMethodLexicon();
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
>         // Check for multiple methods
>         assertEquals(1, countOccurrences(generatedCode, "queryMethod")); // Query exists
> 
>     }
> 
>     // Helper Method. (Need to find something more formal; maybe write one of my own)
>     public int countOccurrences(String text, String word) {
> 
>         int count = 0; // Initialize a counter variable
> 
>         int fromIndex = 0; // Start from the beginning
> 
>         while ((fromIndex = text.indexOf(word, fromIndex)) != -1) {
>             count++;
>             fromIndex++; // Move past the word
>         }
> 
>         return count;
>     }
> 
> 
>     // Test that XRPC Exception gets thrown.
>    @Test
>     public void testXRPCException() throws Exception {
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         assertTrue(generatedCode.contains("import com.atproto.api.xrpc.XRPCException;"));
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient", generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         // Stub the mock to throw the exception
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenThrow(new XRPCException(null, null));
> 
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> 
>         // Assert that the method call throws the expected exception
>         assertThrows(XRPCException.class, () -> {
>             method.invoke(clientInstance);
>         });
>     }
> 
> 
>     // Test that AtpResponse gets imported.
>     @Test
>     public void testAtpResponseType() throws IOException {
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
>                                                                       // Lexicon
>         // we make, just need one)
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
>         assertTrue

#### _User_

> Continue your response exactly where you left off:

#### _Assistant_

>         assertTrue(generatedCode.contains(
>                 "import com.atproto.api.AtpResponse;")); // Should import AtpResponse
>     }
> 
>     // Helper methods for creating Lexicon structures (for test readability)
>     // These would ideally be in a separate test utility class.
> 
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForAllParameterTypes")
>     public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType)
>             throws Exception { // Added Exception
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         // General checks (package, class name, etc.)
>         assertTrue(generatedCode.contains("package com.example;"));
> 
>         // More specific checks based on parameter type. This is where we use the
>         // paramName.
>         assertTrue(generatedCode.contains(paramName)); // Very basic, does the parameter exist?
> 
>         // Check that parameter type is correct
>         assertTrue(generatedCode.contains(expectedType + " " + paramName));
> 
>         // --- Compilation and Reflection to check return type ---
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         // Inject mockXrpcClient
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         // Find the method and its return type. This assumes the method name is "main"
>         java.lang.reflect.Method method = null;
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
>             if (m.getName().equals("main")) { // Or whatever the method name is in your generated code
>                 method = m;
>                 break;
>             }
>         }
>         assertNotNull(method, "Method 'main' not found in generated class");
> 
> 
>         // Get Return Type from Lexicon, create expected type from this
>         String expectedReturnType = "AtpResponse"; // Default
>         if (lexiconDoc.getDefs().get("main") instanceof LexXrpcQuery) {
>             LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
>             if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
>                 expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
>             } else {
>                 expectedReturnType = "AtpResponse<Void>";
>             }
>         } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcProcedure) {
>             LexXrpcProcedure procedure = (LexXrpcProcedure) lexiconDoc.getDefs().get("main");
>             if (procedure.getOutput().isPresent() && procedure.getOutput().get().getSchema().isPresent()) {
>                 expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get())
>                         + ">";
> 
>             } else {
>                 expectedReturnType = "AtpResponse<Void>";
>             }
>         } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcSubscription) {
>             expectedReturnType = "void";
>         }
> 
>         // Now we assert that the return type from code gen is as expected
>         String actualReturnType = method.getGenericReturnType().getTypeName()
>                 .replace("java.util.concurrent.CompletableFuture", "AtpResponse"); // Simplify for testing
>         assertEquals(expectedReturnType, actualReturnType);
> 
>         // Stub Mockito for the method call (added)
>          if (method.getParameterCount() > 0) { // For parameters
>                 when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
>             } else { // No Parameters
>                when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
>             }
> 
>     }
> 
>     // Helper function to return expected Java type String from Lexicon definition.
>     private String getExpectedJavaType(LexXrpcBody xrpcBody) {
> 
>         if (xrpcBody.getSchema().isEmpty()) {
>             return "Void";
>         }
> 
>         LexXrpcBody schema = xrpcBody;
>         if (schema.getSchema().get() instanceof LexObject) {
>             return "Object"; // Placeholder, replace with generated class name if using nested objects.
>         } else if (schema.getSchema().get() instanceof LexArray) {
>             LexArray lexArray = (LexArray) schema.getSchema().get();
>             // Handle nested arrays
>             return getExpectedArrayType(lexArray);
>         } else if (schema.getSchema().get() instanceof LexPrimitive) {
>             return getExpectedPrimitiveType((LexPrimitive) schema.getSchema().get());
>         } else if (schema.getSchema().get() instanceof LexXrpcBody) {
>             return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
>         } else if (schema.getSchema().get() instanceof LexRef) {
>             // Resolve references, including repository refs vs. defs refs. This is very
>             // basic.
>             LexRef ref = (LexRef) schema.getSchema().get();
>             String refStr = ref.getRef();
>             if (refStr.startsWith("#")) {
>                 return refStr.substring(refStr.lastIndexOf(".") + 1); // Local ref
>             } else {
>                 return refStr.replace(".", ""); // External ref
>             }
>         } else if (schema.getSchema().get() instanceof LexString) {
>             LexString lexString = (LexString) schema.getSchema().get();
>             if (lexString.getFormat().isPresent()) {
>                 if (lexString.getFormat().get().equals("datetime")) {
>                     return "java.time.Instant";
>                 } else if (lexString.getFormat().get().equals("cid")) {
>                     return "com.atproto.common.Cid";
>                 } else if (lexString.getFormat().get().equals("did")) {
>                     return "com.atproto.syntax.Did";
>                 } else if (lexString.getFormat().get().equals("handle")) {
>                     return "com.atproto.syntax.Handle";
>                 } else if (lexString.getFormat().get().equals("at-uri")) {
>                     return "com.atproto.syntax.AtUri";
>                 } else if (lexString.getFormat().get().equals("nsid")) {
>                     return "com.atproto.syntax.Nsid";
>                 } else if (lexString.getFormat().get().equals("uri")) {
>                     return "java.net.URI";
>                 } else if (lexString.getFormat().get().equals("language")) {
>                     return "java.util.Locale";
>                 } else if (lexString.getFormat().get().equals("uri-reference")) {
>                     return "java.net.URI"; // Assuming URI for uri-reference
>                 } else if (lexString.getFormat().get().equals("uri-template")) {
>                     return "java.lang.String"; // Assuming String for uri-template (no built-in type)
>                 } else if (lexString.getFormat().get().equals("email")) {
>                     return "java.lang.String"; // Assuming String for email
>                 } else if (lexString.getFormat().get().equals("hostname")) {
>                     return "java.lang.String"; // Assuming String for hostname
>                 } else if (lexString.getFormat().get().equals("ipv4")) {
>                     return "java.net.InetAddress"; // Assuming InetAddress for IPv4
>                 } else if (lexString.getFormat().get().equals("ipv6")) {
>                     return "java.net.InetAddress"; // Assuming InetAddress for IPv6
> 
>                 }
>             }
>             return "String";
>         } else if (schema.getSchema().get() instanceof LexRefUnion) {
>             return "Object";
>         }
> 
>         return "Object"; // Unreachable? Error?
>     }
> 
>     private String getExpectedArrayType(LexArray lexArray) {
>         StringBuilder sb = new StringBuilder();
>         sb.append("java.util.List<");
>         LexType itemType = lexArray.getItems();
> 
>         if (itemType instanceof LexPrimitive) {
>             sb.append(getExpectedPrimitiveType((LexPrimitive) itemType));
>         } else if (itemType instanceof LexArray) {
>             sb.append(getExpectedArrayType((LexArray) itemType)); // Recurse for nested arrays
>         } else if (itemType instanceof LexRef) {
>             // Resolve references
>             LexRef ref = (LexRef) itemType;
>             String refStr = ref.getRef();
>             if (refStr.startsWith("#")) {
>                 sb.append(refStr.substring(refStr.lastIndexOf(".") + 1));
>             } else {
>                 sb.append(refStr.replace(".", ""));
>             }
>         } else if (itemType instanceof LexRefUnion) {
>             sb.append("Object"); // No specific type in a refUnion
>         } else if (itemType instanceof LexObject) { // Nested object not allowed as Array
>             return "Object";
>         }
> 
>         sb.append(">");
>         return sb.toString();
>     }
> 
>     private String getExpectedPrimitiveType(LexPrimitive prim) {
>         if (prim instanceof LexBoolean) {
>             return "Boolean";
>         } else if (prim instanceof LexInteger) {
>             return "Integer";
>         } else if (prim instanceof LexString) {
>             return "String";
>         } else if (prim instanceof LexNumber) {
>             return "Float";
>         } else if (prim instanceof LexBytes) {
>             return "byte[]";
>         } else if (prim instanceof LexUnknown) {
>             return "java.util.Map<String, Object>";
>         }
>         return "Object"; // Should not happen in valid Lexicon
>     }
> 
>     @Test
>     public void testGenerateClientForNestedObject() throws Exception { // Added Exception
>         LexiconDoc lexiconDoc = TestUtils.createNestedObjectLexicon();
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         // Basic checks
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
>         assertTrue(generatedCode.contains("public class NestedObjectClient")); // Class Name.
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>         assertTrue(generatedCode.contains(
>                 "nestedObject(")); // Query method with parameters and type
> 
>         // --- Compilation and Reflection, as before, BUT: ---
>         // 1. Compile and Get Class:
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient",
>                 generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         // 2. Inject Mock:
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         // 3.  Stub Mockito
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>         // 4. Get and Invoke Method, Assert Return Type
>         java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
>         Object result = method.invoke(clientInstance);
>         assertInstanceOf(AtpResponse.class, result); // Very basic check
> 
>         // You could add in more specific checks with Mockito here to check call
>         // parameters
>     }
> 
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForInvalidLexicons")
>     public void testInvalidLexiconStructure(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
>         ClientGenerator generator = new ClientGenerator();
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));
>     }
> 
> 
>     @Test
>     public void testMultipleDefs() throws IOException {
>         LexiconDoc lexiconDoc = TestUtils.createLexiconWithMultipleDefs();
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
>         assertTrue(generatedCode.contains("class Query1Client"));
>         assertTrue(generatedCode.contains("class Query2Client"));
>         assertTrue(generatedCode.contains("class Record1Record")); // Check for records.
> 
>     }
> 
>     @ParameterizedTest // Enhanced to be parameterized
>     @MethodSource("provideLexiconsForRefUnionParams")
>     public void testGenerateClientForRefUnionParams(LexiconDoc lexiconDoc, String methodName, String expectedParamType) throws Exception {
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         assertTrue(generatedCode.contains("package com.example;"));
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> 
>         assertTrue(generatedCode.contains("public class " + className));
> 
>         // Dynamic method name check
>         assertTrue(generatedCode.contains("public AtpResponse " + methodName + "(" + expectedParamType + " params)"));
> 
>         // --- Compilation, Reflection, and Mockito Stubbing ---
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>         Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         // Find the method dynamically
>         java.lang.reflect.Method method = generatedClientClass.getMethod(methodName, Class.forName(expectedParamType));
>         assertNotNull(method, "Method '" + methodName + "' not found in generated class");
> 
>         // Basic stubbing (you'd expand this for specific test cases)
>        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>     }
> 
> 
>     @Test
>     public void testJavadocGeneration() throws Exception { // Added Exception
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         // Basic Javadoc checks
>         assertTrue(generatedCode.contains("/**"));
>         assertTrue(generatedCode.contains("* This is a test query.")); // Check for the description.
>         assertTrue(generatedCode.contains("*/"));
>         assertTrue(generatedCode.contains("public class SimpleQueryClientWithDescription"));
> 
>         // Compile and load the class, then verify with reflection
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler
>                 .compile("com.example.SimpleQueryClientWithDescription", generatedCode);
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
>         assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more
>                                                                                   // thorough.
> 
>     }
> 
> 
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForStringConstraints")
>     public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
>             Integer maxLength, Integer minLength, String constValue, String pattern) throws Exception {
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         // General checks, compilation, method retrieval (as before)
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         java.lang.reflect.Method method = null;
>         for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
>             if (m.getName().equals("main")) {
>                 method = m;
>                 break;
>             }
>         }
>         Class<?> paramClass = method.getParameterTypes()[0];
>         // Now using reflection
>         java.lang.reflect.Field paramField = null;
>         try {
>             paramField = paramClass.getDeclaredField(paramName);
> 
>         } catch (Exception e) {
> 
>             fail("parameter not found in parameters of generated class.");
>         }
> 
>         // maxLength constraint
>         if (maxLength != null) {
>             Annotation maxLengthAnnotation = paramField.getAnnotation(MaxLength.class);
>             assertNotNull(maxLengthAnnotation, "MaxLength annotation not found");
>             assertEquals(maxLength.intValue(), ((MaxLength) maxLengthAnnotation).value(),
>                     "MaxLength value mismatch");
>         }
> 
>         // minLength constraint
>         if (minLength != null) {
>             Annotation minLengthAnnotation = paramField.getAnnotation(MinLength.class);
>             assertNotNull(minLengthAnnotation, "MinLength annotation not found");
>              assertEquals(minLength.intValue(), ((MinLength) minLengthAnnotation).value(),
>                     "MinLength value mismatch");
>         }
> 
>         // const constraint
>         if (constValue != null) {
>             assertTrue(generatedCode
>                     .contains("public static final String " + paramName.

#### _User_

> ```java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> // src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> 
> package com.atproto.codegen;
> 
> 
> 
> import static org.junit.jupiter.api.Assertions.*;
> 
> import static org.mockito.Mockito.*;
> 
> 
> 
> import com.atproto.api.AtpResponse;
> 
> import com.atproto.api.xrpc.XRPCException;
> 
> import com.atproto.lexicon.models.*;
> 
> 
> 
> import java.io.IOException;
> 
> import java.lang.annotation.Annotation;
> 
> import java.lang.reflect.Field;
> 
> import java.time.Instant;
> 
> import java.util.ArrayList;
> 
> import java.util.HashMap;
> 
> import java.util.List;
> 
> import java.util.Map;
> 
> import java.util.Optional;
> 
> import java.util.stream.Stream;
> 
> 
> 
> import javax.validation.constraints.*;
> 
> 
> 
> import org.junit.jupiter.api.BeforeEach;
> 
> import org.junit.jupiter.api.Test;
> 
> import org.junit.jupiter.params.ParameterizedTest;
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> import org.junit.jupiter.params.provider.MethodSource;
> 
> import org.mockito.junit.jupiter.MockitoExtension;
> 
> import org.junit.jupiter.api.extension.ExtendWith;
> 
> import org.mockito.Mock;
> 
> 
> 
> @ExtendWith(MockitoExtension.class)
> 
> public class ClientGeneratorTest {
> 
> 
> 
>     @Mock
> 
>     private XrpcClient mockXrpcClient;
> 
> 
> 
>     private ClientGenerator generator;
> 
> 
> 
>     @BeforeEach
> 
>     public void setUp() {
> 
>         generator = new ClientGenerator();
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForSimpleQuery() throws Exception {
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         assertTrue(generatedCode.contains("package com.example;"));
> 
>         assertTrue(generatedCode.contains("public class SimpleQueryClient"));
> 
>         assertTrue(generatedCode.contains("public AtpResponse"));
> 
>         assertTrue(generatedCode.contains("simpleQuery("));
> 
>         assertTrue(generatedCode.contains(
> 
>                 "xrpcClient.sendQuery"));
> 
>         assertFalse(generatedCode.contains(
> 
>                 "import com.atproto.api.xrpc.XRPCException;"));
> 
> 
> 
>         // --- Compilation and Reflection ---
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         // Stub the mockXrpcClient to return a successful response
> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
> 
> 
>         // Invoke and check return type.
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> 
>         Object result = method.invoke(clientInstance);
> 
>         assertInstanceOf(AtpResponse.class, result);
> 
> 
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForQueryWithParams() throws Exception { // Added Exception
> 
>         // Test params Client
> 
>         LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains("public class ParamsQueryClient")); // Class Name.
> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
> 
>         assertTrue(generatedCode.contains(
> 
>                 "paramsQuery(ParamsQueryParams params")); // Query method with parameters and type
> 
>         assertTrue(generatedCode.contains("xrpcClient.sendQuery")); // Use XRPC
> 
> 
> 
>         // --- Compilation and Reflection ---
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         // Stub
> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
> 
> 
>         Class<?> paramClass = Class.forName("com.example.ParamsQueryParams");
> 
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
> 
> 
> 
> 
> 
>         // Invoke and check return type
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("paramsQuery", paramClass);
> 
>         Object result = method.invoke(clientInstance, paramInstance); // Pass the parameter instance
> 
>         assertInstanceOf(AtpResponse.class, result);
> 
> 
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForProcedure() throws Exception { // Added Exception
> 
>         // Test Procedure
> 
>         LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains("public class ProcedureClient")); // Class name
> 
>         assertTrue(generatedCode.contains("public AtpResponse")); // Return AtpResponse
> 
>         assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input")); // Proper params
> 
>         assertTrue(generatedCode.contains(
> 
>                 "xrpcClient.sendProcedure")); // Check for XRPC call (should be checked in its own test)
> 
> 
> 
>         // --- Compilation and Reflection ---
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient",
> 
>                 generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>          // Stub
> 
>         when(mockXrpcClient.sendProcedure(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
> 
> 
>         Class<?> inputClass = Class.forName("com.example.ProcedureProcedureInput");
> 
>         Object inputInstance = inputClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         // Execute and test
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method
> 
>                                                                                                    // signature
> 
>         Object result = method.invoke(clientInstance, inputInstance); // Invoke with parameter
> 
>         assertInstanceOf(AtpResponse.class, result);
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientForSubscription() throws IOException {
> 
>         // Test Subscription
> 
>         LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Basic checks (subscriptions might have a very different structure)
> 
>         assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>         assertTrue(generatedCode.contains(
> 
>                 "public class SubscriptionClient")); // Class exists (name should automatically be generated from the
> 
>                                                      // name)
> 
>         assertTrue(generatedCode.contains("public void")); // void return type.
> 
>         assertTrue(
> 
>                 generatedCode.contains("subscription(")); // Subscription Method. (name should automatically be
> 
>                                                           // generated
> 
>         // from the name)
> 
>         assertTrue(generatedCode.contains(
> 
>                 "throw new UnsupportedOperationException")); // Subscription not implemented
> 
>     }
> 
> 
> 
>     @Test
> 
>     public void testGenerateClientWithMultipleMethods() throws IOException {
> 
>         // Multiple Definitions
> 
>         LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon(); // Create Lexicon
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator Instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Check for multiple methods
> 
>         assertTrue(generatedCode.contains("queryMethod(")); // Query exists
> 
>         assertTrue(generatedCode.contains("procedureMethod(")); // Procedure Exists
> 
>     }
> 
> 
> 
> 
> 
>     // Test for duplicate method names. Should de-dupe
> 
>     @Test
> 
>     public void testGenerateClientWithDuplicateMethods() throws IOException {
> 
>         LexiconDoc lexiconDoc = TestUtils.createDuplicateMethodLexicon();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
> 
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>         // Check for multiple methods
> 
>         assertEquals(1, countOccurrences(generatedCode, "queryMethod")); // Query exists
> 
> 
> 
>     }
> 
> 
> 
>     // Helper Method. (Need to find something more formal; maybe write one of my own)
> 
>     public int countOccurrences(String text, String word) {
> 
> 
> 
>         int count = 0; // Initialize a counter variable
> 
> 
> 
>         int fromIndex = 0; // Start from the beginning
> 
> 
> 
>         while ((fromIndex = text.indexOf(word, fromIndex)) != -1) {
> 
>             count++;
> 
>             fromIndex++; // Move past the word
> 
>         }
> 
> 
> 
>         return count;
> 
>     }
> 
> 
> 
> 
> 
>     // Test that XRPC Exception gets thrown.
> 
>    @Test
> 
>     public void testXRPCException() throws Exception {
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();
> 
>         ClientGenerator generator = new ClientGenerator();
> 
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>         assertTrue(generatedCode.contains("import com.atproto.api.xrpc.XRPCException;"));
> 
> 
> 
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient", generatedCode);
> 
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>         Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>         xrpcClientField.setAccessible(true);
> 
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>         // Stub the mock to throw the exception
> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenThrow(new XRPCException(null, null));
> 
> 
> 
> 
> 
>         java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> 
> 
> 
>         // Assert that the method call throws the expected exception
> 
>         assertThrows(XRPCException.class, () -> {
> 
>             method.invoke(clientInstance);
> 
>         });
> 
>     }
> 
> 
> 
> 
> 
>     // Test that AtpResponse gets imported.
> 
>     @Test
> 
>     public void testAtpResponseType() throws IOException {
> 
>         LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
> 
>                                                                       // Lexicon
> 
>         // we make, just need one)
> 
> 
> 
>         ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> 
>         String generatedCode = generator.generateClient(lexiconDoc); // Generate
> 
> 
> 
>             assertTrue(generatedCode.contains(
> 
>             "import com.atproto.api.AtpResponse;")); // Should import AtpResponse
> 
> }
> 
> 
> 
> // Helper methods for creating Lexicon structures (for test readability)
> 
> // These would ideally be in a separate test utility class.
> 
> 
> 
> @ParameterizedTest
> 
> @MethodSource("provideLexiconsForAllParameterTypes")
> 
> public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType)
> 
>         throws Exception { // Added Exception
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>     // General checks (package, class name, etc.)
> 
>     assertTrue(generatedCode.contains("package com.example;"));
> 
> 
> 
>     // More specific checks based on parameter type. This is where we use the
> 
>     // paramName.
> 
>     assertTrue(generatedCode.contains(paramName)); // Very basic, does the parameter exist?
> 
> 
> 
>     // Check that parameter type is correct
> 
>     assertTrue(generatedCode.contains(expectedType + " " + paramName));
> 
> 
> 
>     // --- Compilation and Reflection to check return type ---
> 
>     String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> 
>     Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> 
>     Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>     // Inject mockXrpcClient
> 
>     java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>     xrpcClientField.setAccessible(true);
> 
>     xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>     // Find the method and its return type. This assumes the method name is "main"
> 
>     java.lang.reflect.Method method = null;
> 
>     for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
> 
>         if (m.getName().equals("main")) { // Or whatever the method name is in your generated code
> 
>             method = m;
> 
>             break;
> 
>         }
> 
>     }
> 
>     assertNotNull(method, "Method 'main' not found in generated class");
> 
> 
> 
> 
> 
>     // Get Return Type from Lexicon, create expected type from this
> 
>     String expectedReturnType = "AtpResponse"; // Default
> 
>     if (lexiconDoc.getDefs().get("main") instanceof LexXrpcQuery) {
> 
>         LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
> 
>         if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
> 
>             expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
> 
>         } else {
> 
>             expectedReturnType = "AtpResponse<Void>";
> 
>         }
> 
>     } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcProcedure) {
> 
>         LexXrpcProcedure procedure = (LexXrpcProcedure) lexiconDoc.getDefs().get("main");
> 
>         if (procedure.getOutput().isPresent() && procedure.getOutput().get().getSchema().isPresent()) {
> 
>             expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get())
> 
>                     + ">";
> 
> 
> 
>         } else {
> 
>             expectedReturnType = "AtpResponse<Void>";
> 
>         }
> 
>     } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcSubscription) {
> 
>         expectedReturnType = "void";
> 
>     }
> 
> 
> 
>     // Now we assert that the return type from code gen is as expected
> 
>     String actualReturnType = method.getGenericReturnType().getTypeName()
> 
>             .replace("java.util.concurrent.CompletableFuture", "AtpResponse"); // Simplify for testing
> 
>     assertEquals(expectedReturnType, actualReturnType);
> 
> 
> 
>     // Stub Mockito for the method call (added)
> 
>      if (method.getParameterCount() > 0) { // For parameters
> 
>             when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>         } else { // No Parameters
> 
>            when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>         }
> 
> 
> 
> }
> 
> 
> 
> // Helper function to return expected Java type String from Lexicon definition.
> 
> private String getExpectedJavaType(LexXrpcBody xrpcBody) {
> 
> 
> 
>     if (xrpcBody.getSchema().isEmpty()) {
> 
>         return "Void";
> 
>     }
> 
> 
> 
>     LexXrpcBody schema = xrpcBody;
> 
>     if (schema.getSchema().get() instanceof LexObject) {
> 
>         return "Object"; // Placeholder, replace with generated class name if using nested objects.
> 
>     } else if (schema.getSchema().get() instanceof LexArray) {
> 
>         LexArray lexArray = (LexArray) schema.getSchema().get();
> 
>         // Handle nested arrays
> 
>         return getExpectedArrayType(lexArray);
> 
>     } else if (schema.getSchema().get() instanceof LexPrimitive) {
> 
>         return getExpectedPrimitiveType((LexPrimitive) schema.getSchema().get());
> 
>     } else if (schema.getSchema().get() instanceof LexXrpcBody) {
> 
>         return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
> 
>     } else if (schema.getSchema().get() instanceof LexRef) {
> 
>         // Resolve references, including repository refs vs. defs refs. This is very
> 
>         // basic.
> 
>         LexRef ref = (LexRef) schema.getSchema().get();
> 
>         String refStr = ref.getRef();
> 
>         if (refStr.startsWith("#")) {
> 
>             return refStr.substring(refStr.lastIndexOf(".") + 1); // Local ref
> 
>         } else {
> 
>             return refStr.replace(".", ""); // External ref
> 
>         }
> 
>     } else if (schema.getSchema().get() instanceof LexString) {
> 
>         LexString lexString = (LexString) schema.getSchema().get();
> 
>         if (lexString.getFormat().isPresent()) {
> 
>             if (lexString.getFormat().get().equals("datetime")) {
> 
>                 return "java.time.Instant";
> 
>             } else if (lexString.getFormat().get().equals("cid")) {
> 
>                 return "com.atproto.common.Cid";
> 
>             } else if (lexString.getFormat().get().equals("did")) {
> 
>                 return "com.atproto.syntax.Did";
> 
>             } else if (lexString.getFormat().get().equals("handle")) {
> 
>                 return "com.atproto.syntax.Handle";
> 
>             } else if (lexString.getFormat().get().equals("at-uri")) {
> 
>                 return "com.atproto.syntax.AtUri";
> 
>             } else if (lexString.getFormat().get().equals("nsid")) {
> 
>                 return "com.atproto.syntax.Nsid";
> 
>             } else if (lexString.getFormat().get().equals("uri")) {
> 
>                 return "java.net.URI";
> 
>             } else if (lexString.getFormat().get().equals("language")) {
> 
>                 return "java.util.Locale";
> 
>             } else if (lexString.getFormat().get().equals("uri-reference")) {
> 
>                 return "java.net.URI"; // Assuming URI for uri-reference
> 
>             } else if (lexString.getFormat().get().equals("uri-template")) {
> 
>                 return "java.lang.String"; // Assuming String for uri-template (no built-in type)
> 
>             } else if (lexString.getFormat().get().equals("email")) {
> 
>                 return "java.lang.String"; // Assuming String for email
> 
>             } else if (lexString.getFormat().get().equals("hostname")) {
> 
>                 return "java.lang.String"; // Assuming String for hostname
> 
>             } else if (lexString.getFormat().get().equals("ipv4")) {
> 
>                 return "java.net.InetAddress"; // Assuming InetAddress for IPv4
> 
>             } else if (lexString.getFormat().get().equals("ipv6")) {
> 
>                 return "java.net.InetAddress"; // Assuming InetAddress for IPv6
> 
> 
> 
>             }
> 
>         }
> 
>         return "String";
> 
>     } else if (schema.getSchema().get() instanceof LexRefUnion) {
> 
>         return "Object";
> 
>     }
> 
> 
> 
>     return "Object"; // Unreachable? Error?
> 
> }
> 
> 
> 
> private String getExpectedArrayType(LexArray lexArray) {
> 
>     StringBuilder sb = new StringBuilder();
> 
>     sb.append("java.util.List<");
> 
>     LexType itemType = lexArray.getItems();
> 
> 
> 
>     if (itemType instanceof LexPrimitive) {
> 
>         sb.append(getExpectedPrimitiveType((LexPrimitive) itemType));
> 
>     } else if (itemType instanceof LexArray) {
> 
>         sb.append(getExpectedArrayType((LexArray) itemType)); // Recurse for nested arrays
> 
>     } else if (itemType instanceof LexRef) {
> 
>         // Resolve references
> 
>         LexRef ref = (LexRef) itemType;
> 
>         String refStr = ref.getRef();
> 
>         if (refStr.startsWith("#")) {
> 
>             sb.append(refStr.substring(refStr.lastIndexOf(".") + 1));
> 
>         } else {
> 
>             sb.append(refStr.replace(".", ""));
> 
>         }
> 
>     } else if (itemType instanceof LexRefUnion) {
> 
>         sb.append("Object"); // No specific type in a refUnion
> 
>     } else if (itemType instanceof LexObject) { // Nested object not allowed as Array
> 
>         return "Object";
> 
>     }
> 
> 
> 
>     sb.append(">");
> 
>     return sb.toString();
> 
> }
> 
> 
> 
> private String getExpectedPrimitiveType(LexPrimitive prim) {
> 
>     if (prim instanceof LexBoolean) {
> 
>         return "Boolean";
> 
>     } else if (prim instanceof LexInteger) {
> 
>         return "Integer";
> 
>     } else if (prim instanceof LexString) {
> 
>         return "String";
> 
>     } else if (prim instanceof LexNumber) {
> 
>         return "Float";
> 
>     } else if (prim instanceof LexBytes) {
> 
>         return "byte[]";
> 
>     } else if (prim instanceof LexUnknown) {
> 
>         return "java.util.Map<String, Object>";
> 
>     }
> 
>     return "Object"; // Should not happen in valid Lexicon
> 
> }
> 
> 
> 
> @Test
> 
> public void testGenerateClientForNestedObject() throws Exception { // Added Exception
> 
>     LexiconDoc lexiconDoc = TestUtils.createNestedObjectLexicon();
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>     // Basic checks
> 
>     assertTrue(generatedCode.contains("package com.example;")); // Package name
> 
>     assertTrue(generatedCode.contains("public class NestedObjectClient")); // Class Name.
> 
>     assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
> 
>     assertTrue(generatedCode.contains(
> 
>             "nestedObject(")); // Query method with parameters and type
> 
> 
> 
>     // --- Compilation and Reflection, as before, BUT: ---
> 
>     // 1. Compile and Get Class:
> 
>     Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient",
> 
>             generatedCode);
> 
>     Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>     // 2. Inject Mock:
> 
>     java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>     xrpcClientField.setAccessible(true);
> 
>     xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>     // 3.  Stub Mockito
> 
>     when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
> 
> 
>     // 4. Get and Invoke Method, Assert Return Type
> 
>     java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
> 
>     Object result = method.invoke(clientInstance);
> 
>     assertInstanceOf(AtpResponse.class, result); // Very basic check
> 
> 
> 
>     // You could add in more specific checks with Mockito here to check call
> 
>     // parameters
> 
> }
> 
> 
> 
> @ParameterizedTest
> 
> @MethodSource("provideLexiconsForInvalidLexicons")
> 
> public void testInvalidLexiconStructure(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));
> 
> }
> 
> 
> 
> 
> 
> @Test
> 
> public void testMultipleDefs() throws IOException {
> 
>     LexiconDoc lexiconDoc = TestUtils.createLexiconWithMultipleDefs();
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     String generatedCode = generator.generateClient(lexiconDoc);
> 
>     assertTrue(generatedCode.contains("class Query1Client"));
> 
>     assertTrue(generatedCode.contains("class Query2Client"));
> 
>     assertTrue(generatedCode.contains("class Record1Record")); // Check for records.
> 
> 
> 
> }
> 
> 
> 
> @ParameterizedTest // Enhanced to be parameterized
> 
> @MethodSource("provideLexiconsForRefUnionParams")
> 
> public void testGenerateClientForRefUnionParams(LexiconDoc lexiconDoc, String methodName, String expectedParamType) throws Exception {
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>     assertTrue(generatedCode.contains("package com.example;"));
> 
>     String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> 
> 
> 
>     assertTrue(generatedCode.contains("public class " + className));
> 
> 
> 
>     // Dynamic method name check
> 
>     assertTrue(generatedCode.contains("public AtpResponse " + methodName + "(" + expectedParamType + " params)"));
> 
> 
> 
>     // --- Compilation, Reflection, and Mockito Stubbing ---
> 
>     Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> 
>     Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>     Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>     xrpcClientField.setAccessible(true);
> 
>     xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>     // Find the method dynamically
> 
>     java.lang.reflect.Method method = generatedClientClass.getMethod(methodName, Class.forName(expectedParamType));
> 
>     assertNotNull(method, "Method '" + methodName + "' not found in generated class");
> 
> 
> 
>     // Basic stubbing (you'd expand this for specific test cases)
> 
>    when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
> 
> 
> }
> 
> 
> 
> 
> 
> @Test
> 
> public void testJavadocGeneration() throws Exception { // Added Exception
> 
>     LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>     // Basic Javadoc checks
> 
>     assertTrue(generatedCode.contains("/**"));
> 
>     assertTrue(generatedCode.contains("* This is a test query.")); // Check for the description.
> 
>     assertTrue(generatedCode.contains("*/"));
> 
>     assertTrue(generatedCode.contains("public class SimpleQueryClientWithDescription"));
> 
> 
> 
>     // Compile and load the class, then verify with reflection
> 
>     Class<?> generatedClientClass = TestUtils.InMemoryCompiler
> 
>             .compile("com.example.SimpleQueryClientWithDescription", generatedCode);
> 
>     java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> 
>     assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more
> 
>                                                                               // thorough.
> 
> 
> 
> }
> 
> 
> 
> 
> 
> @ParameterizedTest
> 
> @MethodSource("provideLexiconsForStringConstraints")
> 
> public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
> 
>         Integer maxLength, Integer minLength, String constValue, String pattern) throws Exception {
> 
>     ClientGenerator generator = new ClientGenerator();
> 
>     String generatedCode = generator.generateClient(lexiconDoc);
> 
> 
> 
>     // General checks, compilation, method retrieval (as before)
> 
>     String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> 
>     Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> 
>     Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
> 
> 
>     java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> 
>     xrpcClientField.setAccessible(true);
> 
>     xrpcClientField.set(clientInstance, mockXrpcClient);
> 
> 
> 
>     java.lang.reflect.Method method = null;
> 
>     for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
> 
>         if (m.getName().equals("main")) {
> 
>             method = m;
> 
>             break;
> 
>         }
> 
>     }
> 
>     Class<?> paramClass = method.getParameterTypes()[0];
> 
>     // Now using reflection
> 
>     java.lang.reflect.Field paramField = null;
> 
>     try {
> 
>         paramField = paramClass.getDeclaredField(paramName);
> 
> 
> 
>     } catch (Exception e) {
> 
> 
> 
>         fail("parameter not found in parameters of generated class.");
> 
>     }
> 
> 
> 
>     // maxLength constraint
> 
>     if (maxLength != null) {
> 
>         Annotation maxLengthAnnotation = paramField.getAnnotation(MaxLength.class);
> 
>         assertNotNull(maxLengthAnnotation, "MaxLength annotation not found");
> 
>         assertEquals(maxLength.intValue(), ((MaxLength) maxLengthAnnotation).value(),
> 
>                 "MaxLength value mismatch");
> 
>     }
> 
> 
> 
>     // minLength constraint
> 
>     if (minLength != null) {
> 
>         Annotation minLengthAnnotation = paramField.getAnnotation(MinLength.class);
> 
>         assertNotNull(minLengthAnnotation, "MinLength annotation not found");
> 
>          assertEquals(minLength.intValue(), ((MinLength) minLengthAnnotation).value(),
> 
>                 "MinLength value mismatch");
> 
>     }
> 
> 
> 
>     // const constraint
> 
>     if (constValue != null) {
> 
>         assertTrue(generatedCode
> 
>                 .contains("public static final String " + paramName.
> ```
> 
> Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
> Sign up
> 
> Name already in use 
>  
>  
>  
>  
>  A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?
>  
>  
>  
>  
>  
>  1 
> branch
>  
>  
>  0 
> tags
>  
>  
>  
> Code
>  
>  
>  
>  
>  
>  
>  
> Use Git or checkout with SVN using the web URL.
>  
>  
>  
>  
>  
> Open with GitHub Desktop
>  
>  
>  
> Download ZIP
>  
>  
>  
>  
>  
>  
>  
>  Latest commit 
>  
>  Files 
>  Permalink 
>  
>  
> Failed to load latest commit information.
>  
>  Type 
>  Name 
>  Latest commit message 
>  Commit time 
>  
>  
>  
>  
>  reqs-already-client 
>  
>  
>  
>  
>  
>  About 
>  
> Client with Jakarta EE 8, JAX-WS, Wsdl4J, JPA, Hibernate, CDI and JUnit 3.8 for unit tests
>  
>  Resources 
>  
>  
> Readme
>  
>  Stars 
>  
>  
>  0 
> stars
>  
>  Watchers 
>  
>  
>  1 
> watching
>  
>  Forks 
>  
>  
>  0 
> forks
>  
>  
>  ||||I|||| Skip to content
> Toggle navigation
> Sign up
> * Product
> + Actions
> Automate any workflow
> + Packages
> Host and manage packages
> + Security
> Find and fix vulnerabilities
> + Codespaces
> Instant dev environments
> + Copilot
> Write better code with AI
> + Code review
> Manage code changes
> + Issues
> Plan and track work
> + Discussions
> Collaborate outside of code
> + Explore
> + All features
> + Documentation
> + GitHub Skills
> + Blog
> * Solutions
> + For
> + Enterprise
> + Teams
> + Startups
> + Education
> + By Solution
> + CI/CD & Automation
> + DevOps
> + DevSecOps
> + Case Studies
> + Customer Stories
> + Resources
> * Open Source
> + GitHub Sponsors
> Fund open source developers
> + The ReadME Project
> GitHub community articles
> + Repositories
> + Topics
> + Trending
> + Collections
> * Pricing
> * In this repository All GitHub ↵
> Jump to ↵
> * No suggested jump to results
> * In this repository All GitHub ↵
> Jump to ↵
> * In this user All GitHub ↵
> Jump to ↵
> * In this repository All GitHub ↵
> Jump to ↵
> Sign in
> Sign up
> {{ message }}
> depandabot1 / reqs-already-client Public
> * Notifications
> * Fork 0
> * Star 0
> Client with Jakarta EE 8, JAX-WS, Wsdl4J, JPA, Hibernate, CDI and JUnit 3.8 for unit tests
> 0 stars 0 forks
> Star
> Notifications
> * Code
> * Issues 0
> * Pull requests 0
> * Actions
> * Projects 0
> * Security
> * Insights
> More
> * Code
> * Issues
> * Pull requests
> * Actions
> * Projects
> * Security
> * Insights
> depandabot1/reqs-already-client
> This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.
> master
> Switch branches/tags
> Branches Tags
> Could not load branches
> Nothing to show
> {{ refName }} default
> View all branches
> Could not load tags
> Nothing to show
> {{ refName }} default
> View all tags
> Name already in use
> A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?
> Cancel Create
> 1 branch 0 tags
> Code
> * Local
> * Codespaces
> * Clone
> HTTPS GitHub CLI
> Use Git or checkout with SVN using the web URL.
> Work fast with our official CLI. Learn more.
> * Open with GitHub Desktop
> * Download ZIP
> Sign In Required
> Please sign in to use Codespaces.
> Launching GitHub Desktop
> If nothing happens, download GitHub Desktop and try again.
> Launching GitHub Desktop
> If nothing happens, download GitHub Desktop and try again.
> Launching Xcode
> If nothing happens, download Xcode and try again.
> Launching Visual Studio Code
> Your codespace will open once ready.
> There was a problem preparing your codespace, please try again.
> Latest commit
> Git stats
> * 28 commits
> Files
> Permalink
> Failed to load latest commit information.
> Type
> Name
> Latest commit message
> Commit time
> .settings
> src
> target
> .classpath
> .gitignore
> .project
> README.md
> pom.xml
> View code
> README.md
> reqs-already-client
> About
> Client with Jakarta EE 8, JAX-WS, Wsdl4J, JPA, Hibernate, CDI and JUnit 3.8 for unit tests
> Resources
> Readme
> Stars
> 0 stars
> Watchers
> 1 watching
> Forks
> 0 forks
> Releases
> No releases published
> Packages 0
> No packages published
> Languages
> * Java 100.0%
> Footer
> © 2023 GitHub, Inc.
> Footer navigation
> * Terms
> * Privacy
> * Security
> * Status
> * Docs
> * Contact GitHub
> * Pricing
> * API
> * Training
> * Blog
> * About
> You can’t perform that action at this time.
> You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.
> 
> Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
> Sign up
> 
> Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
> Sign up
> 
> OpenJDK / jdk / jdk 
>  directory /test/jdk/java/net/httpclient/offline/ @ 60819:ee1d592a9f53 tip 
>  
>  
>  name 
>  size 
>  permissions 
>  
>  
>  
>  [up] 
>  
>  drwxr-xr-x 
>  
>  
>  
>  
> DelegatingHttpClient.java
>  
>  
>  3497 
>  -rw-r--r-- 
>  
>  
>  
>  
> FixedHttpResponse.java
>  
>  
>  3273 
>  -rw-r--r-- 
>  
>  
>  
>  
> FixedResponseHttpClient.java
>  
>  
>  9594 
>  -rw-r--r-- 
>  
>  
>  
>  
> OfflineTesting.java
>  
>  
>  7520 
>  -rw-r--r--
> 
> Requirements 
>  
>  Java 21 (use sdkman ) 
>  TCC and GPU enabled zone or run Ollama locally 
>  OpenAI API key openai.api-key defined in src/main/resources/application.properties or provided as an environment variable OPENAI_API_KEY 
>  
>  Description 
>  This project serves as an example of how to test GenAI applications by using a Large Language Model (LLM). 
>  The main challenge with verifying answers from LLMs is that they generate responses in natural language that are non-deterministic, making traditional testing methods, which rely on predictable outcomes, unsuitable.
> To address this, the proposed solution involves using one LLM to assess the adequacy of another LLM's responses. This involves setting detailed validation criteria and employing an LLM as a 'Validator Agent' to ensure the responses meet these criteria. This method can be used to validate answers that require both general and specialized knowledge: 
>  String question = "Does 'good' have the same meaning as 'bad'?";
> String reference = "good is the opposite of bad";
> @Test
> void verifyValidatorDetectsWrongAnswer() {
> String answer = "Yes";
> ValidatorAgent.ValidatorResponse validate = validatorAgent.validate(question, answer, reference);
> assertThat(validate.response()).isEqualTo("no");
> }
> @Test
> void verifyValidatorDetectsGoodAnswer() {
> String answer = "No";
> ValidatorAgent.ValidatorResponse validate = validatorAgent.validate(question, answer, reference);
> assertThat(validate.response()).isEqualTo("yes");
> }
>  
>  The ValidatorAgent is an AI Service responsible for validating the answers. It will verify if the answer is correct or not based on the reference provided. 
>  Learn more about the details in the blog post: A Promising Methodology for Testing GenAI Applications in Java 
>  How to run tests 
>  How to run backend 
>  How to run frontend 
>  cd frontend
> npm install
> npm start
> 
> jwilhelm 
>  
>  
>  date 
>  Mon, 28 Sep 2020 19:12:52 +0200 
>  
>  
>  parents 
>  ee6f7a61f3a5 
>  
>  
>  children 
>  
>  
>  
>  line wrap: on 
>  line source 
>  /* 
> * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved. 
> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. 
> * 
> * This code is free software; you can redistribute it and/or modify it 
> * under the terms of the GNU General Public License version 2 only, as 
> * published by the Free Software Foundation. 
> * 
> * This code is distributed in the hope that it will be useful, but WITHOUT 
> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
> * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
> * version 2 for more details (a copy is included in the LICENSE file that 
> * accompanied this code). 
> * 
> * You should have received a copy of the GNU General Public License version 
> * 2 along with this work; if not, write to the Free Software Foundation, 
> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. 
> * 
> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA 
> * or visit www.oracle.com if you need additional information or have any 
> * questions. 
> */ 
>  
> /* 
> * @test 
> * @summary Demonstrates how to achieve testing without network connections 
> * @build DelegatingHttpClient FixedHttpResponse FixedResponseHttpClient 
> * @run testng/othervm OfflineTesting 
> */ 
>  
> import java.io.IOException; 
> import java.net.URI; 
> import java.net.http.HttpClient; 
> import java.net.http.HttpHeaders; 
> import java.net.http.HttpRequest; 
> import java.net.http.HttpRequest.BodyPublishers; 
> import java.net.http.HttpResponse; 
> import java.net.http.HttpResponse.BodyHandlers; 
> import java.util.HashMap; 
> import java.util.List; 
> import java.util.Map; 
> import java.util.function.BiPredicate; 
> import org.testng.annotations.Test; 
> import static java.lang.String.format; 
> import static java.nio.charset.StandardCharsets.UTF_8; 
> import static java.util.Objects.requireNonNull; 
> import static org.testng.Assert.assertEquals; 
> import static org.testng.Assert.assertTrue; 
> import static org.testng.Assert.fail; 
>  
> public class OfflineTesting { 
>  
> private static HttpClient getClient() { 
> // be sure to return the appropriate client when testing 
> //return HttpClient.newHttpClient(); 
> return FixedResponseHttpClient.createClientFrom( 
> HttpClient.newBuilder(), 
> 200, 
> headersOf("Server", "nginx", 
> "Content-Type", "text/html"), 
> "A response message"); 
> } 
>  
> @Test 
> public void testResponseAsString() { 
> HttpClient client = getClient(); 
>  
> HttpRequest request = HttpRequest.newBuilder() 
> .uri(URI.create("http://openjdk.java.net/")) 
> .build(); 
>  
> client.sendAsync(request, BodyHandlers.ofString()) 
> .thenAccept(response -&gt; { 
> System.out.println("response: " + response); 
> assertEquals(response.statusCode(), 200); 
> assertTrue(response.headers().firstValue("Server").isPresent()); 
> assertEquals(response.body(), "A response message"); } ) 
> .join(); 
> } 
>  
> @Test 
> public void testResponseAsByteArray() { 
> HttpClient client = getClient(); 
>  
> HttpRequest request = HttpRequest.newBuilder() 
> .uri(URI.create("http://openjdk.java.net/")) 
> .build(); 
>  
> client.sendAsync(request, BodyHandlers.ofByteArray()) 
> .thenAccept(response -&gt; { 
> System.out.println("response: " + response); 
> assertEquals(response.statusCode(), 200); 
> assertTrue(response.headers().firstValue("Content-Type").isPresent()); 
> assertEquals(response.body(), "A response message".getBytes(UTF_8)); } ) 
> .join(); 
> } 
>  
> @Test 
> public void testFileNotFound() { 
> //HttpClient client = HttpClient.newHttpClient(); 
> HttpClient client = FixedResponseHttpClient.createClientFrom( 
> HttpClient.newBuilder(), 
> 404, 
> headersOf("Connection", "keep-alive", 
> "Content-Length", "162", 
> "Content-Type", "text/html", 
> "Date", "Mon, 15 Jan 2018 15:01:16 GMT", 
> "Server", "nginx"), 
> "&lt;html&gt;\n" + 
> "&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\n" + 
> "&lt;body bgcolor=\"white\"&gt;\n" + 
> "&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\n" + 
> "&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;\n" + 
> "&lt;/body&gt;\n" + 
> "&lt;/html&gt;"); 
>  
> HttpRequest request = HttpRequest.newBuilder() 
> .uri(URI.create("http://openjdk.java.net/notFound")) 
> .build(); 
>  
> client.sendAsync(request, BodyHandlers.ofString()) 
> .thenAccept(response -&gt; { 
> assertEquals(response.statusCode(), 404); 
> response.headers().firstValue("Content-Type") 
> .ifPresentOrElse(type -&gt; assertEquals(type, "text/html"), 
> () -&gt; fail("Content-Type not present")); 
> assertTrue(response.body().contains("404 Not Found")); } ) 
> .join(); 
> } 
>  
> @Test 
> public void testEcho() { 
> HttpClient client = FixedResponseHttpClient.createEchoClient( 
> HttpClient.newBuilder(), 
> 200, 
> headersOf("Connection", "keep-alive")); 
>  
> HttpRequest request = HttpRequest.newBuilder() 
> .uri(URI.create("http://openjdk.java.net/echo")) 
> .POST(BodyPublishers.ofString("Hello World")) 
> .build(); 
>  
> client.sendAsync(request, BodyHandlers.ofString()) 
> .thenAccept(response -&gt; { 
> System.out.println("response: " + response); 
> assertEquals(response.statusCode(), 200); 
> assertEquals(response.body(), "Hello World"); } ) 
> .join(); 
> } 
>  
> @Test 
> public void testEchoBlocking() throws IOException, InterruptedException { 
> HttpClient client = FixedResponseHttpClient.createEchoClient( 
> HttpClient.newBuilder(), 
> 200, 
> headersOf("Connection", "keep-alive")); 
>  
> HttpRequest request = HttpRequest.newBuilder() 
> .uri(URI.create("http://openjdk.java.net/echo")) 
> .POST(BodyPublishers.ofString("Hello chegar!!")) 
> .build(); 
>  
> HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString()); 
> System.out.println("response: " + response); 
> assertEquals(response.statusCode(), 200); 
> assertEquals(response.body(), "Hello chegar!!"); 
> } 
>  
> // --- 
>  
> public static IllegalArgumentException newIAE(String message, Object... args) { 
> return new IllegalArgumentException(format(message, args)); 
> } 
>  
> static final BiPredicate&lt;String,String&gt; ACCEPT_ALL = (x, y) -&gt; true; 
>  
> static HttpHeaders headersOf(String... params) { 
> Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 
> requireNonNull(params); 
> if (params.length == 0 || params.length % 2 != 0) { 
> throw newIAE("wrong number, %d, of parameters", params.length); 
> } 
> for (int i = 0; i &lt; params.length; i += 2) { 
> String name = params[i]; 
> String value = params[i + 1]; 
> map.put(name, List.of(value)); 
> } 
> return HttpHeaders.of(map, ACCEPT_ALL); 
> } 
> } 
>  ||||I|||| * log
> * graph
> * tags
> * branches
> * changeset
> * browse
> * file
> * latest
> * diff
> * comparison
> * annotate
> * file log
> * raw
> * help
> OpenJDK / jdk / jdk
> view test/jdk/java/net/httpclient/offline/OfflineTesting.java @ 60819:ee1d592a9f53
> Find changesets by keywords (author, files, the commit message), revision number or hash, or revset expression.
> Merge
> author jwilhelm
> date Mon, 28 Sep 2020 19:12:52 +0200
> parents ee6f7a61f3a5
> children
> line wrap: on
> line source
> /*
> * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
> *
> * This code is free software; you can redistribute it and/or modify it
> * under the terms of the GNU General Public License version 2 only, as
> * published by the Free Software Foundation.
> *
> * This code is distributed in the hope that it will be useful, but WITHOUT
> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
> * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
> * version 2 for more details (a copy is included in the LICENSE file that
> * accompanied this code).
> *
> * You should have received a copy of the GNU General Public License version
> * 2 along with this work; if not, write to the Free Software Foundation,
> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
> *
> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
> * or visit www.oracle.com if you need additional information or have any
> * questions.
> */
> /*
> * @test
> * @summary Demonstrates how to achieve testing without network connections
> * @build DelegatingHttpClient FixedHttpResponse FixedResponseHttpClient
> * @run testng/othervm OfflineTesting
> */
> import java.io.IOException;
> import java.net.URI;
> import java.net.http.HttpClient;
> import java.net.http.HttpHeaders;
> import java.net.http.HttpRequest;
> import java.net.http.HttpRequest.BodyPublishers;
> import java.net.http.HttpResponse;
> import java.net.http.HttpResponse.BodyHandlers;
> import java.util.HashMap;
> import java.util.List;
> import java.util.Map;
> import java.util.function.BiPredicate;
> import org.testng.annotations.Test;
> import static java.lang.String.format;
> import static java.nio.charset.StandardCharsets.UTF_8;
> import static java.util.Objects.requireNonNull;
> import static org.testng.Assert.assertEquals;
> import static org.testng.Assert.assertTrue;
> import static org.testng.Assert.fail;
> public class OfflineTesting {
> private static HttpClient getClient() {
> // be sure to return the appropriate client when testing
> //return HttpClient.newHttpClient();
> return FixedResponseHttpClient.createClientFrom(
> HttpClient.newBuilder(),
> 200,
> headersOf("Server", "nginx",
> "Content-Type", "text/html"),
> "A response message");
> }
> @Test
> public void testResponseAsString() {
> HttpClient client = getClient();
> HttpRequest request = HttpRequest.newBuilder()
> .uri(URI.create("http://openjdk.java.net/"))
> .build();
> client.sendAsync(request, BodyHandlers.ofString())
> .thenAccept(response -> {
> System.out.println("response: " + response);
> assertEquals(response.statusCode(), 200);
> assertTrue(response.headers().firstValue("Server").isPresent());
> assertEquals(response.body(), "A response message"); } )
> .join();
> }
> @Test
> public void testResponseAsByteArray() {
> HttpClient client = getClient();
> HttpRequest request = HttpRequest.newBuilder()
> .uri(URI.create("http://openjdk.java.net/"))
> .build();
> client.sendAsync(request, BodyHandlers.ofByteArray())
> .thenAccept(response -> {
> System.out.println("response: " + response);
> assertEquals(response.statusCode(), 200);
> assertTrue(response.headers().firstValue("Content-Type").isPresent());
> assertEquals(response.body(), "A response message".getBytes(UTF_8)); } )
> .join();
> }
> @Test
> public void testFileNotFound() {
> //HttpClient client = HttpClient.newHttpClient();
> HttpClient client = FixedResponseHttpClient.createClientFrom(
> HttpClient.newBuilder(),
> 404,
> headersOf("Connection", "keep-alive",
> "Content-Length", "162",
> "Content-Type", "text/html",
> "Date", "Mon, 15 Jan 2018 15:01:16 GMT",
> "Server", "nginx"),
> " \n" +
> " 404 Not Found \n" +
> " \n" +
> " 404 Not Found \n" +
> " nginx \n" +
> " \n" +
> " ");
> HttpRequest request = HttpRequest.newBuilder()
> .uri(URI.create("http://openjdk.java.net/notFound"))
> .build();
> client.sendAsync(request, BodyHandlers.ofString())
> .thenAccept(response -> {
> assertEquals(response.statusCode(), 404);
> response.headers().firstValue("Content-Type")
> .ifPresentOrElse(type -> assertEquals(type, "text/html"),
> () -> fail("Content-Type not present"));
> assertTrue(response.body().contains("404 Not Found")); } )
> .join();
> }
> @Test
> public void testEcho() {
> HttpClient client = FixedResponseHttpClient.createEchoClient(
> HttpClient.newBuilder(),
> 200,
> headersOf("Connection", "keep-alive"));
> HttpRequest request = HttpRequest.newBuilder()
> .uri(URI.create("http://openjdk.java.net/echo"))
> .POST(BodyPublishers.ofString("Hello World"))
> .build();
> client.sendAsync(request, BodyHandlers.ofString())
> .thenAccept(response -> {
> System.out.println("response: " + response);
> assertEquals(response.statusCode(), 200);
> assertEquals(response.body(), "Hello World"); } )
> .join();
> }
> @Test
> public void testEchoBlocking() throws IOException, InterruptedException {
> HttpClient client = FixedResponseHttpClient.createEchoClient(
> HttpClient.newBuilder(),
> 200,
> headersOf("Connection", "keep-alive"));
> HttpRequest request = HttpRequest.newBuilder()
> .uri(URI.create("http://openjdk.java.net/echo"))
> .POST(BodyPublishers.ofString("Hello chegar!!"))
> .build();
> HttpResponse response = client.send(request, BodyHandlers.ofString());
> System.out.println("response: " + response);
> assertEquals(response.statusCode(), 200);
> assertEquals(response.body(), "Hello chegar!!");
> }
> // ---
> public static IllegalArgumentException newIAE(String message, Object... args) {
> return new IllegalArgumentException(format(message, args));
> }
> static final BiPredicate ACCEPT_ALL = (x, y) -> true;
> static HttpHeaders headersOf(String... params) {
> Map<String,List > map = new HashMap ();
> requireNonNull(params);
> if (params.length == 0 || params.length % 2 != 0) {
> throw newIAE("wrong number, %d, of parameters", params.length);
> }
> for (int i = 0; i < params.length; i += 2) {
> String name = params[i];
> String value = params[i + 1];
> map.put(name, List.of(value));
> }
> return HttpHeaders.of(map, ACCEPT_ALL);
> }
> }
> © 2007, 2023 Oracle and/or its affiliates
> Terms of Use · Privacy · Trademarks
> 
> OpenAPI Generator &gt; https://github.com/OpenAPITools/openapi-generator Config Options for java &gt; https://openapi-generator.tech/docs/generators/java/ This article will automatically build a full REST WS client from a OpenAPI (former Swagger) spec file. Note: Although this technique is not specific to Spring Boot, the example assumes we're working on an Spring Boot project using SpringDoc (org.springdoc:springdoc-openapi-ui). Place the OpenAPI spec file inside the Maven project folder: src/main/resources/openapis/ Note: For the example, the spec file name "CouOauth.json" will be used; which content is: { "openapi": "3.0.1", "info": { "title": "COU OAuth (handcrafted)", "description": "This is a handcrafted OpenAPI 3 spec for the COU OAuth userinfo operation.", "contact": { "email": "wsparcie.techniczne@cou.edu" }, "version": "0.0.1" }, "servers": [ { "url": "https://auth.test.cou.edu:443" }, { "url": "https://oauth.test.am.cou.es:443" } ], "paths": { "/userinfo": { "get": { "tags": [ "oauth" ], "summary": "Get user info (employee number, affiliations, etc.)", "operationId": "getUserinfo", "responses": { "200": { "description": "OK", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Oauth2Userinfo" } } } }, "401": { "description": "Unauthenticated", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Oauth2Error" } } } }, "default": { "description": "Default error", "content": { "application/json": { "schema": { "$ref": "#/components/schemas/Oauth2Error" } } } } }, "security": [ { "bearer-key": [] } ] } } }, "components": { "schemas": { "Oauth2Userinfo": { "description": "COU OAuth2 Userinfo structure", "type": "object", "required": [ "sub" ], "properties": { "campusSession": { "type": "string" }, "eduPersonAffiliation": { "uniqueItems": true, "type": "array", "items": { "type": "string" } }, "email": { "type": "string" }, "employeeNumber": { "type": "string" }, "rat": { "type": "integer", "format": "int64" }, "sub": { "type": "string" }, "username": { "type": "string" } } }, "Oauth2Error": { "required": [ "error" ], "properties": { "error": { "$ref": "#/components/schemas/Oauth2ErrorObject" } } }, "Oauth2ErrorObject": { "required": [ "code" ], "properties": { "code": { "type": "integer", "format": "int32" }, "status": { "type": "string" }, "reason": { "type": "string" }, "message": { "type": "string" } } } }, "securitySchemes": { "bearer-key": { "type": "http", "scheme": "bearer" } } } } Remark: It should work in the same way if using a spec file in .yaml format instead of .json. 4.1 Let's configure the Maven project POM file for automatically generate Java client classes for the REST WS out of the OpenAPI spec file Note: Spring Boot 3 uses jakarta instead of javax and therefore it's nedeed to activate useSpringBoot3 flag as shown in the example below. At the 'properties' section, declare the openapi-generator version: &lt;!-- build-helper compatible w/ openapi-generator --&gt; &lt;build-helper-maven-plugin.version&gt;3.0.0&lt;/build-helper-maven-plugin.version&gt; &lt;openapi-generator.version&gt;5.0.0-beta3&lt;/openapi-generator.version&gt; At the 'build.pluginManagements.plugins' section, add Eclipse lifecycle mapping: &lt;plugin&gt; &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt; &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;configuration&gt; &lt;lifecycleMappingMetadata&gt; &lt;pluginExecutions&gt; &lt;pluginExecution&gt; &lt;pluginExecutionFilter&gt; &lt;groupId&gt;org.openapitools&lt;/groupId&gt; &lt;artifactId&gt;openapi-generator-maven-plugin&lt;/artifactId&gt; &lt;versionRange&gt;[${openapi-generator.version},)&lt;/versionRange&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;/pluginExecutionFilter&gt; &lt;action&gt; &lt;execute/&gt; &lt;/action&gt; &lt;/pluginExecution&gt; &lt;/pluginExecutions&gt; &lt;/lifecycleMappingMetadata&gt; &lt;/configuration&gt; &lt;/plugin&gt; At the 'build.plugins' section, add the generation for Java sources out of the OpenAPI spec file: &lt;plugin&gt; &lt;!-- Generate Java Client for OpenAPI REST WS, eg: CouOauth --&gt; &lt;groupId&gt;org.openapitools&lt;/groupId&gt; &lt;artifactId&gt;openapi-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;${openapi-generator.version}&lt;/version&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;couoauth-openapi-contract&lt;/id&gt; &lt;goals&gt; &lt;goal&gt;generate&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;inputSpec&gt;${project.basedir}/src/main/resources/openapis/CouOauth.json&lt;/inputSpec&gt; &lt;skipValidateSpec&gt;false&lt;/skipValidateSpec&gt; &lt;!-- generatorName: {java, spring} --&gt; &lt;generatorName&gt;java&lt;/generatorName&gt; &lt;configOptions&gt; &lt;apiPackage&gt;${package.generated}.uocoauth.api&lt;/apiPackage&gt; &lt;dateLibrary&gt;java8&lt;/dateLibrary&gt; &lt;invokerPackage&gt;${package.generated}.couoauth.invoker&lt;/invokerPackage&gt; &lt;!-- library: {resttemplate, spring-boot} --&gt; &lt;library&gt;resttemplate&lt;/library&gt; &lt;modelPackage&gt;${package.generated}.couoauth.model&lt;/modelPackage&gt; &lt;!-- useJakartaEe: Client jakarta vs javax --&gt; &lt;useJakartaEe&gt;true&lt;/useJakartaEe&gt; &lt;!-- useSpringBoot3: Server jakarta vs javax --&gt; &lt;useSpringBoot3&gt;true&lt;/useSpringBoot3&gt; &lt;/configOptions&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; Try to build the project for checking if any additional dependency is missing (it might depend on the specific OpenAPI spec file being used). 4.2 Adding, if needed, additional dependencies If project compilation fails, probably openapi-generator generated Java sources with "import" statements pointing to dependencies not available in the project. Fortunately, openapi-generator also generated a pom.xml file with all the dependencies used by the generated sources: target/generated-sources/openapi/pom.xml In our example, a dependency for swagger annotations is needed, so let's add it to the project pom.xml: &lt;!-- openapi-generator-maven-plugin: Swagger v3 annotations --&gt; &lt;dependency&gt; &lt;groupId&gt;io.swagger.parser.v3&lt;/groupId&gt; &lt;artifactId&gt;swagger-parser&lt;/artifactId&gt; &lt;version&gt;2.0.24&lt;/version&gt; &lt;/dependency&gt; Note: io.swagger.parser.v3 is used because of compatibility with SpringDoc. 4.3 Add the generated sources folder to the Eclipse build_class_path At section "build.plugins": &lt;plugin&gt; &lt;!-- adding generated source (it adds a new build_class_path to the project) --&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt; &lt;executions&gt; &lt;execution&gt; &lt;id&gt;add-source&lt;/id&gt; &lt;phase&gt;generate-sources&lt;/phase&gt; &lt;goals&gt; &lt;goal&gt;add-source&lt;/goal&gt; &lt;/goals&gt; &lt;configuration&gt; &lt;sources&gt; &lt;source&gt;${project.build.directory}/generated-sources/openapi/src/main/java&lt;/source&gt; &lt;/sources&gt; &lt;/configuration&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;/plugin&gt; 5. Configure Spring Boot to use the generated OpenAPI client 5.1. PortRestCouOauthConfig.java Remark: The oauthPort bean is annotated with scope prototype because, in this specific need, we need a new instance of its ApiClient since it'll hold the unique oauth token for that request. Create this file at the same level than the main Spring Boot application one (annotated with @SpringBoot application): package edu.cou.myapp; import java.security.SecureRandom; import javax.inject.Inject; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import org.springframework.beans.factory.annotation.Value; import org.springframework.context.annotation.Bean; import org.springframework.beans.factory.config.ConfigurableBeanFactory; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; import edu.cou.myapp.helper.SecurityHelper; import edu.cou.myapp.service.EnvironmentService; import myapp_back.generated.couoauth.api.OauthApi; import myapp_back.generated.couoauth.invoker.ApiClient; import lombok.val; import lombok.extern.slf4j.Slf4j; /** * * CouOauth WS REST (Configure Java Client generated classes as beans).&lt;br&gt; * &lt;br&gt; * Remark: This class is part of a NonNullApi! */ @Configuration @Slf4j public class PortRestCouOauthConfig { /** * Path segment, after hostname and before the operation 'path' (REST couoauth.json).&lt;br&gt; */ private String couoauthWsPathSegment; /** Environment service. */ private EnvironmentService environmentService; /** * Environment helper service. * * @param environmentHelper - */ @Inject public PortRestCouOauthConfig(@Value("${couoauth.path.segment:''}") String couoauthWsPathSegment, EnvironmentService environmentService) { this.couoauthWsPathSegment = couoauthWsPathSegment; this.environmentService = environmentService; this.installAllTrustingTrustManager(); } /** * Invoker.&lt;br&gt; * &lt;br&gt; * DOC. @Scope(value = 'prototype') means that Spring will not instantiate the bean right on * start, but will do it later on demand. E.g: beanFactory.getBean(DefaultApi.class, * environmentHelper.getEndpointUrlBase())&lt;br&gt; * &lt;br&gt; * 'endpointUrlBase' eg: "http://sa-test.cou.org:80"&lt;br&gt; * * @return Invoker API client */ @Bean @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE) public OauthApi authPort() { log.info("oauthPort has been invoked"); return new OauthApi(newApiClient(this.environmentService.getEnvOpt( EnvironmentService.ENV_OAUTH_ISSUER).orElseThrow())); } /** * The ApiClient class is used for configuring authentication, the base path of the API, common * headers, and it's responsible for executing all API requests.&lt;br&gt; * &lt;br&gt; * OAuth token authentication can be provided with method:&lt;br&gt; * setBearerToken(oauthToken)&lt;br&gt; * * @param endpointUrlBase E.g: "http://sa-test.cou.org:80" * @return Invoker API client */ private ApiClient newApiClient(String endpointUrlBase) { log.info("apiClient has been invoked"); // Endpoint basePath final String endPointBasePath = endpointUrlBase + this.couoauthWsPathSegment; if (log.isInfoEnabled()) { log.info("CouOauth endpoint base path = " + endPointBasePath); } val apiClient = new ApiClient(); apiClient.setBasePath(endPointBasePath); // return apiClient; } /*- * */ private void installAllTrustingTrustManager() { // INI (needed to avoid SSL exception) // (a) Create a trust manager that does not validate certificate chains TrustManager[] trustAllCerts = SecurityHelper.getAllTrustingTrustManager(); // (b) Install the all-trusting trust manager try { SSLContext sc = SSLContext.getInstance("TLSv1.2"); sc.init(null, trustAllCerts, new SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); } catch (Exception e) { log.info("Exception caught installing the all-trusting trust manager", e); } // END (needed to avoid SSL exception) } } 5.2. Application configuration class (@SpringBootApplication) The application configuration class annotated with @SpringBootApplication should, by default, already be able to find the newly defined bean. If you're running into issues with this, you could explicitly add to the the annotation @Import(PortRestCouOauthConfig.class) Sample App.java: ... /** * App. */ @Slf4j @EnableJpaRepositories(repositoryFactoryBeanClass = EnversRevisionRepositoryFactoryBean.class) @ComponentScan(basePackages = { "edu.cou.myapp" }) @Configuration @SpringBootApplication public class App implements CommandLineRunner { ... } ... 6 Use the just configured remote OpenAPI REST WS Note the @Lookup annotation on the getOauthPort() method which garantees getting a new instance of the prototype bean every time it's invoked. @Service public class OauthClientHelper implements OauthClient { /** * Spring will override the method annotated with (at)Lookup. It then registers the * bean into the application context. Whenever we request the method, it returns a new * OauthApi instance. * * @return A new instance of OauthApi with its own unique ApiClient */ @Lookup public OauthApi getOauthPort() { return null; // NOSONAR } /** * Invokes oauth/userinfo (using uocOauthPort).&lt;br&gt; * * @param oauthToken oauthToken (w/out 'Bearer ') * @return Response from oauth/userinfo * @throws AppException */ @Override public Oauth2Userinfo userinfo(final String oauthToken) { try { // Since authorization can be different, we need a new instance of ApiClient every time OauthApi oauthPort = this.getOauthPort(); ApiClient apiclient = oauthPort.getApiClient(); log.info("apiClient should be a new object everythime: " + Integer.toHexString(System .identityHashCode(apiclient))); apiclient.setBearerToken(oauthToken); /*- INI remote call */ if (log.isInfoEnabled()) { log.info("INI couOauthPort.getUserinfo()"); } long callStart = System.nanoTime(); // Invocation start Oauth2Userinfo res = oauthPort.getUserinfo(); // Invocation finish long callFinish = System.nanoTime(); if (log.isInfoEnabled()) { log.info(String.format("END couOauthPort.getUserinfo. Elapsed (ms): %d. Result: %s", (callFinish - callStart) / 1_000_000L, "&lt;scrapped&gt;")); } /*- END remote call */ return res; } catch (RestClientException e) { log.error("RestClientException." + e.getMessage(), e); throw transformExceptionRestToAppException(e); } } /** * Transform the exception rest to a App exception.&lt;br&gt; * * @param restClientException - * @return NotNull */ private AppException transformExceptionRestToAppException(final RestClientException e) { AppException ret; String errMsg = null; if (e instanceof HttpClientErrorException) { // HTTP status 4xx errMsg = ((HttpClientErrorException) e).getResponseBodyAsString(); if (HttpStatus.BAD_REQUEST.equals(((HttpClientErrorException) e).getStatusCode())) { ret = new BadRequestAppException(errMsg, e.getCause()); } else if (HttpStatus.CONFLICT.equals(((HttpClientErrorException) e).getStatusCode())) { ret = new ConflictAppException(errMsg, e.getCause()); } else if (HttpStatus.FORBIDDEN.equals(((HttpClientErrorException) e).getStatusCode())) { ret = new ForbiddenAppException(errMsg, e.getCause()); } else if (HttpStatus.NOT_FOUND.equals(((HttpClientErrorException) e).getStatusCode())) { ret = new NotFoundAppException(errMsg, e.getCause()); } else { ret = new ServiceUnavailableAppException(errMsg, e.getCause()); } } else if (e instanceof HttpServerErrorException) { errMsg = ((HttpServerErrorException) e).getResponseBodyAsString(); if (HttpStatus.GATEWAY_TIMEOUT.equals(((HttpServerErrorException) e).getStatusCode())) { ret = new GatewayAppException(errMsg, e.getCause()); } else if (HttpStatus.INTERNAL_SERVER_ERROR.equals(((HttpServerErrorException) e) .getStatusCode())) { ret = new InternalServerErrorAppException(errMsg, e.getCause()); } else if (HttpStatus.SERVICE_UNAVAILABLE.equals(((HttpServerErrorException) e) .getStatusCode())) { ret = new ServiceUnavailableAppException(errMsg, e.getCause()); } else { ret = new ServiceUnavailableAppException(errMsg, e.getCause()); } } else { ret = new ServiceUnavailableAppException(e.getMessage(), e.getCause()); } return ret; } } 7. Unit tests, mocking OAuthApi Remark: It's necessary to also mock the getApiClient method, otherwise you'd get a null pointer exception when getting it out from the OAuthApi for setting the 'Authorization' header with the OAuth token bearer. TestConfig00.java: ... @TestConfiguration public class TestConfig00 { ... /** * OAuth port.&lt;br&gt; * * @return - */ @Bean @Primary public OauthApi oauthPortTest() { log.info("#### Mocking oauthPortTest"); final OauthApi oauthPortMock = Mockito.mock(OauthApi.class, new TestMockingIssueAnswer()); // getApiClient doReturn(new ApiClient()).when(oauthPortMock).getApiClient(); // userinfo Oauth2Userinfo userinfores = new Oauth2Userinfo(); userinfores.setEmployeeNumber(MICHAL_CODE.toString()); userinfores.addEduPersonAffiliationItem("1227"); userinfores.addEduPersonAffiliationItem("1234"); doReturn(userinfores).when(oauthPortMock).getUserinfo(); // return oauthPortMock; } ... } 8.1. SSL certificate validation exception when invoking a remote operation Relevant imports: import java.security.SecureRandom; import java.security.cert.X509Certificate; import javax.net.ssl.HttpsURLConnection; import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager; import lombok.experimental.UtilityClass; SecurityHelper.java: @UtilityClass public class SecurityHelper { /** Singleton of a all-trusting trust manager. */ private static TrustManager[] trustAllCerts; /** * Trust manager that does not validate certificate chains. * * @return Singleton of a all-trusting trust manager */ public static TrustManager[] getAllTrustingTrustManager() { if (null == SecurityHelper.trustAllCerts) { SecurityHelper.trustAllCerts = new TrustManager[] { new X509TrustManager() { @Override public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; } @Override public void checkClientTrusted(X509Certificate[] certs, String authType) throws java.security.cert.CertificateException { // Let's do nothing if (OffsetDateTime.now().isBefore(OffsetDateTime.MIN)) { throw new java.security.cert.CertificateException("Never thrown, it makes happy Sonar"); } } @Override public void checkServerTrusted(X509Certificate[] certs, String authType) throws java.security.cert.CertificateException { // Let's do nothing if (OffsetDateTime.now().isAfter(OffsetDateTime.MAX)) { throw new java.security.cert.CertificateException("Never thrown, making Sonar happy"); } } } }; } // return SecurityHelper.trustAllCerts.clone(); } } Install the all-trusting trust manager elsewhere: /*- * */ private void installAllTrustingTrustManager() { // INI (needed to avoid SSL exception) // (a) Create a trust manager that does not validate certificate chains TrustManager[] trustAllCerts = SecurityHelper.getAllTrustingTrustManager(); // (b) Install the all-trusting trust manager try { SSLContext sc = SSLContext.getInstance("TLSv1.2"); sc.init(null, trustAllCerts, new SecureRandom()); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory()); } catch (Exception e) { log.info("Exception caught installing the all-trusting trust manager", e); } // END (needed to avoid SSL exception) }
> 
> A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?
>  
>  ||||I|||| Skip to content
> Toggle navigation
> Sign up
> * Product
> + Actions
> Automate any workflow
> + Packages
> Host and manage packages
> + Security
> Find and fix vulnerabilities
> + Codespaces
> Instant dev environments
> + Copilot
> Write better code with AI
> + Code review
> Manage code changes
> + Issues
> Plan and track work
> + Discussions
> Collaborate outside of code
> + Explore
> + All features
> + Documentation
> + GitHub Skills
> + Blog
> * Solutions
> + For
> + Enterprise
> + Teams
> + Startups
> + Education
> + By Solution
> + CI/CD & Automation
> + DevOps
> + DevSecOps
> + Case Studies
> + Customer Stories
> + Resources
> * Open Source
> + GitHub Sponsors
> Fund open source developers
> + The ReadME Project
> GitHub community articles
> + Repositories
> + Topics
> + Trending
> + Collections
> * Pricing
> * In this repository All GitHub ↵
> Jump to ↵
> * No suggested jump to results
> * In this repository All GitHub ↵
> Jump to ↵
> * In this user All GitHub ↵
> Jump to ↵
> * In this repository All GitHub ↵
> Jump to ↵
> Sign in
> Sign up
> {{ message }}
> joseosuna-engineer / jersey-rest-jax-rs-java-client Public
> * Notifications
> * Fork 0
> * Star 1
> Eclipse Jersey framework is an open source framework for developing RESTful Web Services in Java. It provides support for JAX-RS APIs and serves as a JAX-RS (JSR 311 & JSR 339 & JSR 370) Reference Implementation.
> License
> Apache-2.0 license
> 1 star 0 forks
> Star
> Notifications
> * Code
> * Issues 0
> * Pull requests 0
> * Actions
> * Projects 0
> * Security
> * Insights
> More
> * Code
> * Issues
> * Pull requests
> * Actions
> * Projects
> * Security
> * Insights
> joseosuna-engineer/jersey-rest-jax-rs-java-client
> This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.
> main
> Switch branches/tags
> Branches Tags
> Could not load branches
> Nothing to show
> {{ refName }} default
> View all branches
> Could not load tags
> Nothing to show
> {{ refName }} default
> View all tags
> Name already in use
> A tag already exists with the provided branch name. Many Git commands accept both tag and branch names, so creating this branch may cause unexpected behavior. Are you sure you want to create this branch?
> Cancel Create
> 1 branch 0 tags
> Code
> * Local
> * Codespaces
> * Clone
> HTTPS GitHub CLI
> Use Git or checkout with SVN using the web URL.
> Work fast with our official CLI. Learn more.
> * Open with GitHub Desktop
> * Download ZIP
> Sign In Required
> Please sign in to use Codespaces.
> Launching GitHub Desktop
> If nothing happens, download GitHub Desktop and try again.
> Launching GitHub Desktop
> If nothing happens, download GitHub Desktop and try again.
> Launching Xcode
> If nothing happens, download Xcode and try again.
> Launching Visual Studio Code
> Your codespace will open once ready.
> There was a problem preparing your codespace, please try again.
> Latest commit
> Git stats
> * 6 commits
> Files
> Permalink
> Failed to load latest commit information.
> Type
> Name
> Latest commit message
> Commit time
> .github/ workflows
> src/ main
> .gitignore
> LICENSE
> README.md
> pom.xml
> View code
> README.md
> jersey-rest-jax-rs-java-client
> Eclipse Jersey framework is an open source framework for developing RESTful Web Services in Java. It provides support for JAX-RS APIs and serves as a JAX-RS (JSR 311 & JSR 339 & JSR 370) Reference Implementation.
> Include Generic Types / Raw Types / Entity Type
> About
> Eclipse Jersey framework is an open source framework for developing RESTful Web Services in Java. It provides support for JAX-RS APIs and serves as a JAX-RS (JSR 311 & JSR 339 & JSR 370) Reference Implementation.
> Resources
> Readme
> License
> Apache-2.0 license
> Stars
> 1 star
> Watchers
> 1 watching
> Forks
> 0 forks
> Releases
> No releases published
> Packages 0
> No packages published
> Languages
> * Java 100.0%
> Footer
> © 2023 GitHub, Inc.
> Footer navigation
> * Terms
> * Privacy
> * Security
> * Status
> * Docs
> * Contact GitHub
> * Pricing
> * API
> * Training
> * Blog
> * About
> You can’t perform that action at this time.
> You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
> Sign up
> 
> An OpenAPI JAX-RS client code generator 
>  
>  Generates Java code to call REST services. 
>  The API classes are intended for use with the MicroProfile client . 
>  The DTO classes can be generated for use with JSON Binding or Jackson FasterXML . 
>  The code generation is configured via 50+ options . 
>  As of version 0.11, this generator requires a Java 21 runtime. 
>  Inspiration 
>  Much of the behavior and templates are lifted more or less directly from openapi-generator . 
>  But the code is implemented from scratch, based on end-to-end tests. 
>  I plan to keep this generator much simpler: 
>  
>  it will only generate Java code, primarily intended for the MP client. 
>  it will never have as many features as openapi-generator. 
>  but its reduced complexity should allow me to acquire the output I desire and retain my sanity. 
>  
>  Examples 
>  A couple of official APIs are kept as examples: azure , bitbucket , and petstore .
> These should give you an idea of what the generator's output looks like - and they help me evaluate how changes affect the output on larger APIs. 
>  The output from many other test OpenApi documents and configuration settings can be seen in the test folder . 
>  Invocation 
>  Gradle 
>  A Gradle plugin allows easy declaration of OpenApi documents and generator options. 
>  Command Line 
>  Download the cli-jar release of the generator (and verify its signature !). 
>  Then you can run the generator with a Java 21 like this (or see full CLI usage ): 
>  $ java -jar ojc-x.y.z-cli.jar --api-package foo.bar.api --dto-package foo.bar.dto -i petstore.yaml -o /tmp/output 
>  [2022-02-26 15:08:47] [INFO] Reads OpenApi document from petstore.yaml 
>  [2022-02-26 15:08:47] [INFO] Generates files in /tmp/output 
>  [2022-02-26 15:08:47] [INFO] No configuration file found 
>  ... 
> $ tree /tmp/output/ 
>  /tmp/output/ 
>  └── foo 
>  └── bar 
>  ├── api 
>  │ └── PetsApi.java 
>  └── dto 
>  ├── Error.java 
>  └── Pet.java 
>  The output looks something like this (petstore) . 
>  Roadmap 
>  The current plans for future releases are (note, no time commitments): 
>  0.11.x 
>  
>  Native generator executables 
>  More code/package documentation. 
>  Documentation index with references to the various tests/examples. 
>  
>  1.0.x ideas 
>  
>  For operations with many query parameters, make builder-like flow-pattern call. 
>  Handling of extensions (e.g. annotation of in-house @LoggedSecrets operations) 
>  Options for adding @ClientHeaderParam and/or @RegisterClientHeaders 
>  Maybe add generation of server-side code 
>  
>  History/Rationale 
>  We generate client code (originally only DTOs) from a lot of different sources at work, and the input OpenApi documents are not all entirely spec-worthy. 
>  So I have spent a lot of hours in the past tweaking openapi-generator to generate code of usable quality.
> This was not always possible (because of its architecture), and it was always a pain the butt! 
>  To improve my sanity at work, I wrote the bulk of this generator during the Christmas holidays of 2021. 
>  More and more projects at work now use this generator, and many (weird) corner cases have been fixed over time.
> This has made it possible to deprecated my old generator, so in my book, this is great! 
>  The project has a lot of tests to help ensure I do not (accidentally) break behavior. 
>  While the code generation output is the primary goal of the project, I also use it as a test bed for use of code quality tooling and Gradle build logic organization. 
>  Community Collaboration 
>  I like Open Source just as much as the next guy. 
>  This tool provides infrastructure to whomever uses it, so it should be Open Source. And it is (Apache License). 
>  But (my definition of) stability and quality of the generator's output is more important to me than being able to accept changes from other parties. 
> It is a tool I rely on to provide a difference for colleagues at work. 
>  So while you are welcome to access and fork the source code, I am not as such interested in contributions. 
> Unless they just happen to align with my interests, of course. 
>  If you are itching to make some changes, please open an issue first, so we can discuss. 
> I do not want you to waste your time! 
>  I welcome bug reports if you use the generator and experience problems. 
>  Consultancy 
>  The project is Open Source and I am happy for you to use the generator, report bugs and suggest changes. 
>  But while the source code is free, it does not come bundled with promises or guarantees of free work. 
>  I will try to fix reported bugs, but will commit to no time tables. 
>  However, I am willing to implement feature requests as a paid service (1,200DKK/hour) assuming: 
>  
>  I agree with the suggested feature 
>  Approval from my employer to work for you (not expected to be a problem, as the context will be this project) 
>  I have not reached my limit of hours (40 hours - Danish VAT limit is 50,000DKK/running-12-months) 
>  
>  Please reach out to me via email if you would like to make use of this offer. 
>  If the above requirements are not agreeable, you are more than welcome to fork the project and do your own thing.
> 
> jwilhelm
> date
> Mon, 28 Sep 2020 19:12:52 +0200
> parents
>  4254bed3c09d 
> children
>  
>  line wrap: on 
>  line source 
>  /* 
>  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved. 
>  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. 
>  * 
>  * This code is free software; you can redistribute it and/or modify it 
>  * under the terms of the GNU General Public License version 2 only, as 
>  * published by the Free Software Foundation. 
>  * 
>  * This code is distributed in the hope that it will be useful, but WITHOUT 
>  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
>  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
>  * version 2 for more details (a copy is included in the LICENSE file that 
>  * accompanied this code). 
>  * 
>  * You should have received a copy of the GNU General Public License version 
>  * 2 along with this work; if not, write to the Free Software Foundation, 
>  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. 
>  * 
>  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA 
>  * or visit www.oracle.com if you need additional information or have any 
>  * questions. 
>  */ 
>  
>  /* 
>  * @test 
>  * @summary Demonstrates how to achieve testing without network connections 
>  * @build DelegatingHttpClient FixedHttpResponse FixedResponseHttpClient 
>  * @run testng/othervm OfflineTesting 
>  */ 
>  
>  import java.io.IOException; 
>  import java.net.URI; 
>  import java.net.http.HttpClient; 
>  import java.net.http.HttpHeaders; 
>  import java.net.http.HttpRequest; 
>  import java.net.http.HttpRequest.BodyPublishers; 
>  import java.net.http.HttpResponse; 
>  import java.net.http.HttpResponse.BodyHandlers; 
>  import java.util.HashMap; 
>  import java.util.List; 
>  import java.util.Map; 
>  import java.util.function.BiPredicate; 
>  import org.testng.annotations.Test; 
>  import static java.lang.String.format; 
>  import static java.nio.charset.StandardCharsets.UTF_8; 
>  import static java.util.Objects.requireNonNull; 
>  import static org.testng.Assert.assertEquals; 
>  import static org.testng.Assert.assertTrue; 
>  import static org.testng.Assert.fail; 
>  
>  public class OfflineTesting { 
>  
>  private static HttpClient getClient() { 
>  // be sure to return the appropriate client when testing 
>  //return HttpClient.newHttpClient(); 
>  return FixedResponseHttpClient.createClientFrom( 
>  HttpClient.newBuilder(), 
>  200, 
>  headersOf("Server", "nginx", 
>  "Content-Type", "text/html"), 
>  "A response message"); 
>  } 
>  
>  @Test 
>  public void testResponseAsString() { 
>  HttpClient client = getClient(); 
>  
>  HttpRequest request = HttpRequest.newBuilder() 
>  .uri(URI.create("http://openjdk.java.net/")) 
>  .build(); 
>  
>  client.sendAsync(request, BodyHandlers.ofString()) 
>  .thenAccept(response -&gt; { 
>  System.out.println("response: " + response); 
>  assertEquals(response.statusCode(), 200); 
>  assertTrue(response.headers().firstValue("Server").isPresent()); 
>  assertEquals(response.body(), "A response message"); } ) 
>  .join(); 
>  } 
>  
>  @Test 
>  public void testResponseAsByteArray() { 
>  HttpClient client = getClient(); 
>  
>  HttpRequest request = HttpRequest.newBuilder() 
>  .uri(URI.create("http://openjdk.java.net/")) 
>  .build(); 
>  
>  client.sendAsync(request, BodyHandlers.ofByteArray()) 
>  .thenAccept(response -&gt; { 
>  System.out.println("response: " + response); 
>  assertEquals(response.statusCode(), 200); 
>  assertTrue(response.headers().firstValue("Content-Type").isPresent()); 
>  assertEquals(response.body(), "A response message".getBytes(UTF_8)); } ) 
>  .join(); 
>  } 
>  
>  @Test 
>  public void testFileNotFound() { 
>  //HttpClient client = HttpClient.newHttpClient(); 
>  HttpClient client = FixedResponseHttpClient.createClientFrom( 
>  HttpClient.newBuilder(), 
>  404, 
>  headersOf("Connection", "keep-alive", 
>  "Content-Length", "162", 
>  "Content-Type", "text/html", 
>  "Date", "Mon, 15 Jan 2018 15:01:16 GMT", 
>  "Server", "nginx"), 
>  "&lt;html&gt;\n" + 
>  "&lt;head&gt;&lt;title&gt;404 Not Found&lt;/title&gt;&lt;/head&gt;\n" + 
>  "&lt;body bgcolor=\"white\"&gt;\n" + 
>  "&lt;center&gt;&lt;h1&gt;404 Not Found&lt;/h1&gt;&lt;/center&gt;\n" + 
>  "&lt;hr&gt;&lt;center&gt;nginx&lt;/center&gt;\n" + 
>  "&lt;/body&gt;\n" + 
>  "&lt;/html&gt;"); 
>  
>  HttpRequest request = HttpRequest.newBuilder() 
>  .uri(URI.create("http://openjdk.java.net/notFound")) 
>  .build(); 
>  
>  client.sendAsync(request, BodyHandlers.ofString()) 
>  .thenAccept(response -&gt; { 
>  assertEquals(response.statusCode(), 404); 
>  response.headers().firstValue("Content-Type") 
>  .ifPresentOrElse(type -&gt; assertEquals(type, "text/html"), 
>  () -&gt; fail("Content-Type not present")); 
>  assertTrue(response.body().contains("404 Not Found")); } ) 
>  .join(); 
>  } 
>  
>  @Test 
>  public void testEcho() { 
>  HttpClient client = FixedResponseHttpClient.createEchoClient( 
>  HttpClient.newBuilder(), 
>  200, 
>  headersOf("Connection", "keep-alive")); 
>  
>  HttpRequest request = HttpRequest.newBuilder() 
>  .uri(URI.create("http://openjdk.java.net/echo")) 
>  .POST(BodyPublishers.ofString("Hello World")) 
>  .build(); 
>  
>  client.sendAsync(request, BodyHandlers.ofString()) 
>  .thenAccept(response -&gt; { 
>  System.out.println("response: " + response); 
>  assertEquals(response.statusCode(), 200); 
>  assertEquals(response.body(), "Hello World"); } ) 
>  .join(); 
>  } 
>  
>  @Test 
>  public void testEchoBlocking() throws IOException, InterruptedException { 
>  HttpClient client = FixedResponseHttpClient.createEchoClient( 
>  HttpClient.newBuilder(), 
>  200, 
>  headersOf("Connection", "keep-alive")); 
>  
>  HttpRequest request = HttpRequest.newBuilder() 
>  .uri(URI.create("http://openjdk.java.net/echo")) 
>  .POST(BodyPublishers.ofString("Hello chegar!!")) 
>  .build(); 
>  
>  HttpResponse&lt;String&gt; response = client.send(request, BodyHandlers.ofString()); 
>  System.out.println("response: " + response); 
>  assertEquals(response.statusCode(), 200); 
>  assertEquals(response.body(), "Hello chegar!!"); 
>  } 
>  
>  // --- 
>  
>  public static IllegalArgumentException newIAE(String message, Object... args) { 
>  return new IllegalArgumentException(format(message, args)); 
>  } 
>  
>  static final BiPredicate&lt;String,String&gt; ACCEPT_ALL = (x, y) -&gt; true; 
>  
>  static HttpHeaders headersOf(String... params) { 
>  Map&lt;String,List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); 
>  requireNonNull(params); 
>  if (params.length == 0 || params.length % 2 != 0) { 
>  throw newIAE("wrong number, %d, of parameters", params.length); 
>  } 
>  for (int i = 0; i &lt; params.length; i += 2) { 
>  String name = params[i]; 
>  String value = params[i + 1]; 
>  map.put(name, List.of(value)); 
>  } 
>  return HttpHeaders.of(map, ACCEPT_ALL); 
>  } 
>  }
> 
> 8214339: SSLSocketImpl erroneously wraps SocketException
> Reviewed-by: ascarpino, jnimeh 
>  
>  xuelei 
>  
>  
>  date 
>  Fri, 14 Dec 2018 19:39:39 -0800 
>  
>  
>  parents 
>  
>  
>  
>  children 
>  945d9dae301e 
>  
>  
>  line wrap: on 
>  line source 
>  /* 
> * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved. 
> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. 
> * 
> * This code is free software; you can redistribute it and/or modify it 
> * under the terms of the GNU General Public License version 2 only, as 
> * published by the Free Software Foundation. 
> * 
> * This code is distributed in the hope that it will be useful, but WITHOUT 
> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
> * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
> * version 2 for more details (a copy is included in the LICENSE file that 
> * accompanied this code). 
> * 
> * You should have received a copy of the GNU General Public License version 
> * 2 along with this work; if not, write to the Free Software Foundation, 
> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. 
> * 
> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA 
> * or visit www.oracle.com if you need additional information or have any 
> * questions. 
> */ 
>  
> // 
> // Please run in othervm mode. SunJSSE does not support dynamic system 
> // properties, no way to re-use system properties in samevm/agentvm mode. 
> // 
>  
> import java.io.ByteArrayInputStream; 
> import java.security.KeyFactory; 
> import java.security.KeyStore; 
> import java.security.PrivateKey; 
> import java.security.cert.Certificate; 
> import java.security.cert.CertificateFactory; 
> import java.security.spec.PKCS8EncodedKeySpec; 
> import java.util.Base64; 
> import javax.net.ssl.KeyManagerFactory; 
> import javax.net.ssl.SSLContext; 
> import javax.net.ssl.TrustManagerFactory; 
>  
> /** 
> * SSLContext template to speed up JSSE tests. 
> */ 
> public interface SSLContextTemplate { 
> /* 
> * Create an instance of SSLContext for client use. 
> */ 
> default SSLContext createClientSSLContext() throws Exception { 
> return createSSLContext(trustedCertStrs, 
> endEntityCertStrs, endEntityPrivateKeys, 
> endEntityPrivateKeyAlgs, 
> endEntityPrivateKeyNames, 
> getClientContextParameters()); 
> } 
>  
> /* 
> * Create an instance of SSLContext for server use. 
> */ 
> default SSLContext createServerSSLContext() throws Exception { 
> return createSSLContext(trustedCertStrs, 
> endEntityCertStrs, endEntityPrivateKeys, 
> endEntityPrivateKeyAlgs, 
> endEntityPrivateKeyNames, 
> getServerContextParameters()); 
> } 
>  
> /* 
> * The parameters used to configure SSLContext. 
> */ 
> static final class ContextParameters { 
> final String contextProtocol; 
> final String tmAlgorithm; 
> final String kmAlgorithm; 
>  
> ContextParameters(String contextProtocol, 
> String tmAlgorithm, String kmAlgorithm) { 
>  
> this.contextProtocol = contextProtocol; 
> this.tmAlgorithm = tmAlgorithm; 
> this.kmAlgorithm = kmAlgorithm; 
> } 
> } 
>  
> /* 
> * Get the client side parameters of SSLContext. 
> */ 
> default ContextParameters getClientContextParameters() { 
> return new ContextParameters("TLS", "PKIX", "NewSunX509"); 
> } 
>  
> /* 
> * Get the server side parameters of SSLContext. 
> */ 
> default ContextParameters getServerContextParameters() { 
> return new ContextParameters("TLS", "PKIX", "NewSunX509"); 
> } 
>  
> /* 
> * ======================================= 
> * Certificates and keys used in the test. 
> */ 
> // Trusted certificates. 
> final static String[] trustedCertStrs = { 
> // SHA256withECDSA, curve prime256v1 
> // Validity 
> // Not Before: May 22 07:18:16 2018 GMT 
> // Not After : May 17 07:18:16 2038 GMT 
> // Subject Key Identifier: 
> // 60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\n" + 
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" + 
> "ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\n" + 
> "MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\n" + 
> "MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB/l11b5h0v\n" + 
> "LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\n" + 
> "A1UdDgQWBBRgz71z//oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z//oa\n" + 
> "MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH/MAoGCCqGSM49BAMCA0kAMEYCIQCG\n" + 
> "6wluh1r2/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\n" + 
> "2YEHlSQUAbwwqCDEVB5KxaqP\n" + 
> "-----END CERTIFICATE-----", 
> // -----BEGIN PRIVATE KEY----- 
> // MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg/HcHdoLJCdq3haVd 
> // XZTSKP00YzM3xX97l98vGL/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd 
> // LyyM5pAtwypVbpGU/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp 
> // -----END PRIVATE KEY----- 
>  
> // SHA256withRSA, 2048 bits 
> // Validity 
> // Not Before: May 22 07:18:16 2018 GMT 
> // Not After : May 17 07:18:16 2038 GMT 
> // Subject Key Identifier: 
> // 0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIIDSTCCAjGgAwIBAgIJAI4ZF3iy8zG+MA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\n" + 
> "BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\n" + 
> "aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYT\n" + 
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" + 
> "ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALpMcY7aWieXDEM1/YJf\n" + 
> "JW27b4nRIFZyEYhEloyGsKTuQiiQjc8cqRZFNXe2vwziDB4IyTEl0Hjl5QF6ZaQE\n" + 
> "huPzzwvQm1pv64KrRXrmj3FisQK8B5OWLty9xp6xDqsaMRoyObLK+oIb20T5fSlE\n" + 
> "evmo1vYjnh8CX0Yzx5Gr5ye6YSEHQvYOWEws8ad17OlyToR2KMeC8w4qo6rs59pW\n" + 
> "g7Mxn9vo22ImDzrtAbTbXbCias3xlE0Bp0h5luyf+5U4UgksoL9B9r2oP4GrLNEV\n" + 
> "oJk57t8lwaR0upiv3CnS8LcJELpegZub5ggqLY8ZPYFQPjlK6IzLOm6rXPgZiZ3m\n" + 
> "RL0CAwEAAaNQME4wHQYDVR0OBBYEFA3dk8n+S701t+iZeJD721o92xVMMB8GA1Ud\n" + 
> "IwQYMBaAFA3dk8n+S701t+iZeJD721o92xVMMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n" + 
> "hvcNAQELBQADggEBAJTRC3rKUUhVH07/1+stUungSYgpM08dY4utJq0BDk36BbmO\n" + 
> "0AnLDMbkwFdHEoqF6hQIfpm7SQTmXk0Fss6Eejm8ynYr6+EXiRAsaXOGOBCzF918\n" + 
> "/RuKOzqABfgSU4UBKECLM5bMfQTL60qx+HdbdVIpnikHZOFfmjCDVxoHsGyXc1LW\n" + 
> "Jhkht8IGOgc4PMGvyzTtRFjz01kvrVQZ75aN2E0GQv6dCxaEY0i3ypSzjUWAKqDh\n" + 
> "3e2OLwUSvumcdaxyCdZAOUsN6pDBQ+8VRG7KxnlRlY1SMEk46QgQYLbPDe/+W/yH\n" + 
> "ca4PejicPeh+9xRAwoTpiE2gulfT7Lm+fVM7Ruc=\n" + 
> "-----END CERTIFICATE-----", 
>  
> // -----BEGIN PRIVATE KEY----- 
> // MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6THGO2lonlwxD 
> // Nf2CXyVtu2+J0SBWchGIRJaMhrCk7kIokI3PHKkWRTV3tr8M4gweCMkxJdB45eUB 
> // emWkBIbj888L0Jtab+uCq0V65o9xYrECvAeTli7cvcaesQ6rGjEaMjmyyvqCG9tE 
> // +X0pRHr5qNb2I54fAl9GM8eRq+cnumEhB0L2DlhMLPGndezpck6EdijHgvMOKqOq 
> // 7OfaVoOzMZ/b6NtiJg867QG0212womrN8ZRNAadIeZbsn/uVOFIJLKC/Qfa9qD+B 
> // qyzRFaCZOe7fJcGkdLqYr9wp0vC3CRC6XoGbm+YIKi2PGT2BUD45SuiMyzpuq1z4 
> // GYmd5kS9AgMBAAECggEAFHSoU2MuWwJ+2jJnb5U66t2V1bAcuOE1g5zkWvG/G5z9 
> // rq6Qo5kmB8f5ovdx6tw3MGUOklLwnRXBG3RxDJ1iokz3AvkY1clMNsDPlDsUrQKF 
> // JSO4QUBQTPSZhnsyfR8XHSU+qJ8Y+ohMfzpVv95BEoCzebtXdVgxVegBlcEmVHo2 
> // kMmkRN+bYNsr8eb2r+b0EpyumS39ZgKYh09+cFb78y3T6IFMGcVJTP6nlGBFkmA/ 
> // 25pYeCF2tSki08qtMJZQAvKfw0Kviibk7ZxRbJqmc7B1yfnOEHP6ftjuvKl2+RP/ 
> // +5P5f8CfIP6gtA0LwSzAqQX/hfIKrGV5j0pCqrD0kQKBgQDeNR6Xi4sXVq79lihO 
> // a1bSeV7r8yoQrS8x951uO+ox+UIZ1MsAULadl7zB/P0er92p198I9M/0Jth3KBuS 
> // zj45mucvpiiGvmQlMKMEfNq4nN7WHOu55kufPswQB2mR4J3xmwI+4fM/nl1zc82h 
> // De8JSazRldJXNhfx0RGFPmgzbwKBgQDWoVXrXLbCAn41oVnWB8vwY9wjt92ztDqJ 
> // HMFA/SUohjePep9UDq6ooHyAf/Lz6oE5NgeVpPfTDkgvrCFVKnaWdwALbYoKXT2W 
> // 9FlyJox6eQzrtHAacj3HJooXWuXlphKSizntfxj3LtMR9BmrmRJOfK+SxNOVJzW2 
> // +MowT20EkwKBgHmpB8jdZBgxI7o//m2BI5Y1UZ1KE5vx1kc7VXzHXSBjYqeV9FeF 
> // 2ZZLP9POWh/1Fh4pzTmwIDODGT2UPhSQy0zq3O0fwkyT7WzXRknsuiwd53u/dejg 
> // iEL2NPAJvulZ2+AuiHo5Z99LK8tMeidV46xoJDDUIMgTG+UQHNGhK5gNAoGAZn/S 
> // Cn7SgMC0CWSvBHnguULXZO9wH1wZAFYNLL44OqwuaIUFBh2k578M9kkke7woTmwx 
> // HxQTjmWpr6qimIuY6q6WBN8hJ2Xz/d1fwhYKzIp20zHuv5KDUlJjbFfqpsuy3u1C 
> // kts5zwI7pr1ObRbDGVyOdKcu7HI3QtR5qqyjwaUCgYABo7Wq6oHva/9V34+G3Goh 
> // 63bYGUnRw2l5BD11yhQv8XzGGZFqZVincD8gltNThB0Dc/BI+qu3ky4YdgdZJZ7K 
> // z51GQGtaHEbrHS5caV79yQ8QGY5mUVH3E+VXSxuIqb6pZq2DH4sTAEFHyncddmOH 
> // zoXBInYwRG9KE/Bw5elhUw== 
> // -----END PRIVATE KEY----- 
>  
>  
> // SHA256withDSA, 2048 bits 
> // Validity 
> // Not Before: May 22 07:18:18 2018 GMT 
> // Not After : May 17 07:18:18 2038 GMT 
> // Subject Key Identifier: 
> // 76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIIErjCCBFSgAwIBAgIJAOktYLNCbr02MAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\n" + 
> "EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\n" + 
> "Y2UwHhcNMTgwNTIyMDcxODE4WhcNMzgwNTE3MDcxODE4WjA7MQswCQYDVQQGEwJV\n" + 
> "UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Uw\n" + 
> "ggNHMIICOQYHKoZIzjgEATCCAiwCggEBAO5GyPhSm0ze3LSu+gicdULLj05iOfTL\n" + 
> "UvZQ29sYz41zmqrLBQbdKiHqgJu2Re9sgTb5suLNjF047TOLPnU3jhPtWm2X8Xzi\n" + 
> "VGIcHym/Q/MeZxStt/88seqroI3WOKzIML2GcrishT+lcGrtH36Tf1+ue2Snn3PS\n" + 
> "WyxygNqPjllP5uUjYmFLvAf4QLMldkd/D2VxcwsHjB8y5iUZsXezc/LEhRZS/02m\n" + 
> "ivqlRw3AMkq/OVe/ZtxFWsP0nsfxEGdZuaUFpppGfixxFvymrB3+J51cTt+pZBDq\n" + 
> "D2y0DYfc+88iCs4jwHTfcDIpLb538HBjBj2rEgtQESQmB0ooD/+wsPsCIQC1bYch\n" + 
> "gElNtDYL3FgpLgNSUYp7gIWv9ehaC7LO2z7biQKCAQBitvFOnDkUja8NAF7lDpOV\n" + 
> "b5ipQ8SicBLW3kQamxhyuyxgZyy/PojZ/oPorkqW/T/A0rhnG6MssEpAtdiwVB+c\n" + 
> "rBYGo3bcwmExJhdOJ6dYuKFppPWhCwKMHs9npK+lqBMl8l5j58xlcFeC7ZfGf8GY\n" + 
> "GkhFW0c44vEQhMMbac6ZTTP4mw+1t7xJfmDMlLEyIpTXaAAk8uoVLWzQWnR40sHi\n" + 
> "ybvS0u3JxQkb7/y8tOOZu8qlz/YOS7lQ6UxUGX27Ce1E0+agfPphetoRAlS1cezq\n" + 
> "Wa7r64Ga0nkj1kwkcRqjgTiJx0NwnUXr78VAXFhVF95+O3lfqhvdtEGtkhDGPg7N\n" + 
> "A4IBBgACggEBAMmSHQK0w2i+iqUjOPzn0yNEZrzepLlLeQ1tqtn0xnlv5vBAeefD\n" + 
> "Pm9dd3tZOjufVWP7hhEz8xPobb1CS4e3vuQiv5UBfhdPL3f3l9T7JMAKPH6C9Vve\n" + 
> "OQXE5eGqbjsySbcmseHoYUt1WCSnSda1opX8zchX04e7DhGfE2/L9flpYEoSt8lI\n" + 
> "vMNjgOwvKdW3yvPt1/eBBHYNFG5gWPv/Q5KoyCtHS03uqGm4rNc/wZTIEEfd66C+\n" + 
> "QRaUltjOaHmtwOdDHaNqwhYZSVOip+Mo+TfyzHFREcdHLapo7ZXqbdYkRGxRR3d+\n" + 
> "3DfHaraJO0OKoYlPkr3JMvM/MSGR9AnZOcejUDBOMB0GA1UdDgQWBBR2Zp73O91F\n" + 
> "5TvZcjw/8FQ5hjEmUzAfBgNVHSMEGDAWgBR2Zp73O91F5TvZcjw/8FQ5hjEmUzAM\n" + 
> "BgNVHRMEBTADAQH/MAsGCWCGSAFlAwQDAgNHADBEAiBzriYE41M2y9Hy5ppkL0Qn\n" + 
> "dIlNc8JhXT/PHW7GDtViagIgMko8Qoj9gDGPK3+O9E8DC3wGiiF9CObM4LN387ok\n" + 
> "J+g=\n" + 
> "-----END CERTIFICATE-----" 
> // -----BEGIN PRIVATE KEY----- 
> // MIICZQIBADCCAjkGByqGSM44BAEwggIsAoIBAQDuRsj4UptM3ty0rvoInHVCy49O 
> // Yjn0y1L2UNvbGM+Nc5qqywUG3Soh6oCbtkXvbIE2+bLizYxdOO0ziz51N44T7Vpt 
> // l/F84lRiHB8pv0PzHmcUrbf/PLHqq6CN1jisyDC9hnK4rIU/pXBq7R9+k39frntk 
> // p59z0lsscoDaj45ZT+blI2JhS7wH+ECzJXZHfw9lcXMLB4wfMuYlGbF3s3PyxIUW 
> // Uv9Npor6pUcNwDJKvzlXv2bcRVrD9J7H8RBnWbmlBaaaRn4scRb8pqwd/iedXE7f 
> // qWQQ6g9stA2H3PvPIgrOI8B033AyKS2+d/BwYwY9qxILUBEkJgdKKA//sLD7AiEA 
> // tW2HIYBJTbQ2C9xYKS4DUlGKe4CFr/XoWguyzts+24kCggEAYrbxTpw5FI2vDQBe 
> // 5Q6TlW+YqUPEonAS1t5EGpsYcrssYGcsvz6I2f6D6K5Klv0/wNK4ZxujLLBKQLXY 
> // sFQfnKwWBqN23MJhMSYXTienWLihaaT1oQsCjB7PZ6SvpagTJfJeY+fMZXBXgu2X 
> // xn/BmBpIRVtHOOLxEITDG2nOmU0z+JsPtbe8SX5gzJSxMiKU12gAJPLqFS1s0Fp0 
> // eNLB4sm70tLtycUJG+/8vLTjmbvKpc/2Dku5UOlMVBl9uwntRNPmoHz6YXraEQJU 
> // tXHs6lmu6+uBmtJ5I9ZMJHEao4E4icdDcJ1F6+/FQFxYVRfefjt5X6ob3bRBrZIQ 
> // xj4OzQQjAiEAsceWOM8do4etxp2zgnoNXV8PUUyqWhz1+0srcKV7FR4= 
> // -----END PRIVATE KEY----- 
> }; 
>  
> // End entity certificate. 
> final static String[] endEntityCertStrs = { 
> // SHA256withECDSA, curve prime256v1 
> // Validity 
> // Not Before: May 22 07:18:16 2018 GMT 
> // Not After : May 17 07:18:16 2038 GMT 
> // Authority Key Identifier: 
> // 60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\n" + 
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" + 
> "ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\n" + 
> "MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\n" + 
> "MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\n" + 
> "QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\n" + 
> "xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c//6GjDSpOzT\n" + 
> "SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\n" + 
> "1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO//wJIGQ==\n" + 
> "-----END CERTIFICATE-----", 
>  
> // SHA256withRSA, 2048 bits 
> // Validity 
> // Not Before: May 22 07:18:16 2018 GMT 
> // Not After : May 17 07:18:16 2038 GMT 
> // Authority Key Identifier: 
> // 0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIIDNjCCAh6gAwIBAgIJAO2+yPcFryUTMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\n" + 
> "BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\n" + 
> "aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYT\n" + 
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" + 
> "ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOC\n" + 
> "AQ8AMIIBCgKCAQEAszfBobWfZIp8AgC6PiWDDavP65mSvgCXUGxACbxVNAfkLhNR\n" + 
> "QOsHriRB3X1Q3nvO9PetC6wKlvE9jlnDDj7D+1j1r1CHO7ms1fq8rfcQYdkanDtu\n" + 
> "4AlHo8v+SSWX16MIXFRYDj2VVHmyPtgbltcg4zGAuwT746FdLI94uXjJjq1IOr/v\n" + 
> "0VIlwE5ORWH5Xc+5Tj+oFWK0E4a4GHDgtKKhn2m72hN56/GkPKGkguP5NRS1qYYV\n" + 
> "/EFkdyQMOV8J1M7HaicSft4OL6eKjTrgo93+kHk+tv0Dc6cpVBnalX3TorG8QI6B\n" + 
> "cHj1XQd78oAlAC+/jF4pc0mwi0un49kdK9gRfQIDAQABoyMwITAfBgNVHSMEGDAW\n" + 
> "gBQN3ZPJ/ku9NbfomXiQ+9taPdsVTDANBgkqhkiG9w0BAQsFAAOCAQEApXS0nKwm\n" + 
> "Kp8gpmO2yG1rpd1+2wBABiMU4JZaTqmma24DQ3RzyS+V2TeRb29dl5oTUEm98uc0\n" + 
> "GPZvhK8z5RFr4YE17dc04nI/VaNDCw4y1NALXGs+AHkjoPjLyGbWpi1S+gfq2sNB\n" + 
> "Ekkjp6COb/cb9yiFXOGVls7UOIjnVZVd0r7KaPFjZhYh82/f4PA/A1SnIKd1+nfH\n" + 
> "2yk7mSJNC7Z3qIVDL8MM/jBVwiC3uNe5GPB2uwhd7k5LGAVN3j4HQQGB0Sz+VC1h\n" + 
> "92oi6xDa+YBva2fvHuCd8P50DDjxmp9CemC7rnZ5j8egj88w14X44Xjb/Fd/ApG9\n" + 
> "e57NnbT7KM+Grw==\n" + 
> "-----END CERTIFICATE-----", 
>  
> // SHA256withRSA, curv prime256v1 
> // Validity 
> // Not Before: May 22 07:18:16 2018 GMT 
> // Not After : May 21 07:18:16 2028 GMT 
> // Authority Key Identifier: 
> // 0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIICazCCAVOgAwIBAgIJAO2+yPcFryUUMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\n" + 
> "BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\n" + 
> "aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0yODA1MjEwNzE4MTZaMFUxCzAJBgNVBAYT\n" + 
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" + 
> "ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0D\n" + 
> "AQcDQgAE59MERNTlVZ1eeps8Z3Oue5ZkgQdPtD+WIE6tj3PbIKpxGPDxvfNP959A\n" + 
> "yQjEK/ehWQVrCMmNoEkIzY+IIBgB06MjMCEwHwYDVR0jBBgwFoAUDd2Tyf5LvTW3\n" + 
> "6Jl4kPvbWj3bFUwwDQYJKoZIhvcNAQELBQADggEBAFOTVEqs70ykhZiIdrEsF1Ra\n" + 
> "I3B2rLvwXZk52uSltk2/bzVvewA577ZCoxQ1pL7ynkisPfBN1uVYtHjM1VA3RC+4\n" + 
> "+TAK78dnI7otYjWoHp5rvs4l6c/IbOspS290IlNuDUxMErEm5wxIwj+Aukx/1y68\n" + 
> "hOyCvHBLMY2c1LskH1MMBbDuS1aI+lnGpToi+MoYObxGcV458vxuT8+wwV8Fkpvd\n" + 
> "ll8IIFmeNPRv+1E+lXbES6CSNCVaZ/lFhPgdgYKleN7sfspiz50DG4dqafuEAaX5\n" + 
> "xaK1NWXJxTRz0ROH/IUziyuDW6jphrlgit4+3NCzp6vP9hAJQ8Vhcj0n15BKHIQ=\n" + 
> "-----END CERTIFICATE-----", 
>  
> // SHA256withDSA, 2048 bits 
> // Validity 
> // Not Before: May 22 07:18:20 2018 GMT 
> // Not After : May 17 07:18:20 2038 GMT 
> // Authority Key Identifier: 
> // 76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53 
> "-----BEGIN CERTIFICATE-----\n" + 
> "MIIEnDCCBEGgAwIBAgIJAP/jh1qVhNVjMAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\n" + 
> "EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\n" + 
> "Y2UwHhcNMTgwNTIyMDcxODIwWhcNMzgwNTE3MDcxODIwWjBVMQswCQYDVQQGEwJV\n" + 
> "UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Ux\n" + 
> "GDAWBgNVBAMMD1JlZ3Jlc3Npb24gVGVzdDCCA0cwggI6BgcqhkjOOAQBMIICLQKC\n" + 
> "AQEAmlavgoJrMcjqWRVcDE2dmWAPREgnzQvneEDef68cprDzjSwvOs5QeFyx75ib\n" + 
> "ado1e6jO/rW1prCGWHDD1oA/Tn4Pk3vu0nUxzvl1qATc+aJbpUU5Op0bvp6LbCsQ\n" + 
> "QslV9FeRh7Eb7bP6gpc/kHCBzEgC1VCK7prccXWy+t6SMOHbND3h+UbckfSaUuaV\n" + 
> "sVJNTD1D6GElfRj4Nmz1BGPfSYvKorwNZEU3gXwFgtDoAcGx7tcyClLpDHfqRfw/\n" + 
> "7yiqLyeiP7D4hl5lMNouJWDlAdMFp0FMgS3s9VDFinIcr6VtBWMTG7+4+czHAB+3\n" + 
> "fvrwlqNzhBn3uFHrekN/w8fNxwIhAJo7Sae1za7IMW0Q6hE5B4b+s2B/FaKPoA4E\n" + 
> "jtZu13B9AoIBAQCOZqLMKfvqZWUgT0PQ3QjR7dAFdd06I9Y3+TOQzZk1+j+vw/6E\n" + 
> "X4vFItX4gihb/u5Q9CdmpwhVGi7bvo+7+/IKeTgoQ6f5+PSug7SrWWUQ5sPwaZui\n" + 
> "zXZJ5nTeZDucFc2yFx0wgnjbPwiUxZklOT7xGiOMtzOTa2koCz5KuIBL+/wPKKxm\n" + 
> "ypo9VoY9xfbdU6LMXZv/lpD5XTM9rYHr/vUTNkukvV6Hpm0YMEWhVZKUJiqCqTqG\n" + 
> "XHaleOxSw6uQWB/+TznifcC7gB48UOQjCqOKf5VuwQneJLhlhU/jhRV3xtr+hLZa\n" + 
> "hW1wYhVi8cjLDrZFKlgEQqhB4crnJU0mJY+tA4IBBQACggEAID0ezl00/X8mv7eb\n" + 
> "bzovum1+DEEP7FM57k6HZEG2N3ve4CW+0m9Cd+cWPz8wkZ+M0j/Eqa6F0IdbkXEc\n" + 
> "Q7CuzvUyJ57xQ3L/WCgXsiS+Bh8O4Mz7GwW22CGmHqafbVv+hKBfr8MkskO6GJUt\n" + 
> "SUF/CVLzB4gMIvZMH26tBP2xK+i7FeEK9kT+nGdzQSZBAhFYpEVCBplHZO24/OYq\n" + 
> "1DNoU327nUuXIhmsfA8N0PjiWbIZIjTPwBGr9H0LpATI7DIDNcvRRvtROP+pBU9y\n" + 
> "fuykPkptg9C0rCM9t06bukpOSaEz/2VIQdLE8fHYFA6pHZ6CIc2+5cfvMgTPhcjz\n" + 
> "W2jCt6MjMCEwHwYDVR0jBBgwFoAUdmae9zvdReU72XI8P/BUOYYxJlMwCwYJYIZI\n" + 
> "AWUDBAMCA0gAMEUCIQCeI5fN08b9BpOaHdc3zQNGjp24FOL/RxlBLeBAorswJgIg\n" + 
> "JEZ8DhYxQy1O7mmZ2UIT7op6epWMB4dENjs0qWPmcKo=\n" + 
> "-----END CERTIFICATE-----" 
> }; 
>  
> // Private key in the format of PKCS#8. 
> final static String[] endEntityPrivateKeys = { 
> // 
> // EC private key related to cert endEntityCertStrs[0]. 
> // 
> "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\n" + 
> "JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\n" + 
> "59bk2pyG8qd8l7L1WQnNHtAcu44RJ1/GVHurxghaCKHeJYsZ8H7DEeI6", 
>  
> // 
> // RSA private key related to cert endEntityCertStrs[1]. 
> // 
> "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzN8GhtZ9kinwC\n" + 
> "ALo+JYMNq8/rmZK+AJdQbEAJvFU0B+QuE1FA6weuJEHdfVDee870960LrAqW8T2O\n" + 
> "WcMOPsP7WPWvUIc7uazV+ryt9xBh2RqcO27gCUejy/5JJZfXowhcVFgOPZVUebI+\n" + 
> "2BuW1yDjMYC7BPvjoV0sj3i5eMmOrUg6v+/RUiXATk5FYfldz7lOP6gVYrQThrgY\n" + 
> "cOC0oqGfabvaE3nr8aQ8oaSC4/k1FLWphhX8QWR3JAw5XwnUzsdqJxJ+3g4vp4qN\n" + 
> "OuCj3f6QeT62/QNzpylUGdqVfdOisbxAjoFwePVdB3vygCUAL7+MXilzSbCLS6fj\n" + 
> "2R0r2BF9AgMBAAECggEASIkPkMCuw4WdTT44IwERus3IOIYOs2IP3BgEDyyvm4B6\n" + 
> "JP/iihDWKfA4zEl1Gqcni1RXMHswSglXra682J4kui02Ov+vzEeJIY37Ibn2YnP5\n" + 
> "ZjRT2s9GtI/S2o4hl8A/mQb2IMViFC+xKehTukhV4j5d6NPKk0XzLR7gcMjnYxwn\n" + 
> "l21fS6D2oM1xRG/di7sL+uLF8EXLRzfiWDNi12uQv4nwtxPKvuKhH6yzHt7YqMH0\n" + 
> "46pmDKDaxV4w1JdycjCb6NrCJOYZygoQobuZqOQ30UZoZsPJrtovkncFr1e+lNcO\n" + 
> "+aWDfOLCtTH046dEQh5oCShyXMybNlry/QHsOtHOwQKBgQDh2iIjs+FPpQy7Z3EX\n" + 
> "DGEvHYqPjrYO9an2KSRr1m9gzRlWYxKY46WmPKwjMerYtra0GP+TBHrgxsfO8tD2\n" + 
> "wUAII6sd1qup0a/Sutgf2JxVilLykd0+Ge4/Cs51tCdJ8EqDV2B6WhTewOY2EGvg\n" + 
> "JiKYkeNwgRX/9M9CFSAMAk0hUQKBgQDLJAartL3DoGUPjYtpJnfgGM23yAGl6G5r\n" + 
> "NSXDn80BiYIC1p0bG3N0xm3yAjqOtJAUj9jZbvDNbCe3GJfLARMr23legX4tRrgZ\n" + 
> "nEdKnAFKAKL01oM+A5/lHdkwaZI9yyv+hgSVdYzUjB8rDmzeVQzo1BT7vXypt2yV\n" + 
> "6O1OnUpCbQKBgA/0rzDChopv6KRcvHqaX0tK1P0rYeVQqb9ATNhpf9jg5Idb3HZ8\n" + 
> "rrk91BNwdVz2G5ZBpdynFl9G69rNAMJOCM4KZw5mmh4XOEq09Ivba8AHU7DbaTv3\n" + 
> "7QL7KnbaUWRB26HHzIMYVh0el6T+KADf8NXCiMTr+bfpfbL3dxoiF3zhAoGAbCJD\n" + 
> "Qse1dBs/cKYCHfkSOsI5T6kx52Tw0jS6Y4X/FOBjyqr/elyEexbdk8PH9Ar931Qr\n" + 
> "NKMvn8oA4iA/PRrXX7M2yi3YQrWwbkGYWYjtzrzEAdzmg+5eARKAeJrZ8/bg9l3U\n" + 
> "ttKaItJsDPlizn8rngy3FsJpR9aSAMK6/+wOiYkCgYEA1tZkI1rD1W9NYZtbI9BE\n" + 
> "qlJVFi2PBOJMKNuWdouPX3HLQ72GJSQff2BFzLTELjweVVJ0SvY4IipzpQOHQOBy\n" + 
> "5qh/p6izXJZh3IHtvwVBjHoEVplg1b2+I5e3jDCfqnwcQw82dW5SxOJMg1h/BD0I\n" + 
> "qAL3go42DYeYhu/WnECMeis=", 
>  
> // 
> // EC private key related to cert endEntityCertStrs[2]. 
> // 
> "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgGVc7hICpmp91jbYe\n" + 
> "nrr8nYHD37RZP3VENY+szuA7WjuhRANCAATn0wRE1OVVnV56mzxnc657lmSBB0+0\n" + 
> "P5YgTq2Pc9sgqnEY8PG980/3n0DJCMQr96FZBWsIyY2gSQjNj4ggGAHT", 
>  
> // 
> // DSA private key related to cert endEntityCertStrs[3]. 
> // 
> "MIICZQIBADCCAjoGByqGSM44BAEwggItAoIBAQCaVq+CgmsxyOpZFVwMTZ2ZYA9E\n" + 
> "SCfNC+d4QN5/rxymsPONLC86zlB4XLHvmJtp2jV7qM7+tbWmsIZYcMPWgD9Ofg+T\n" + 
> "e+7SdTHO+XWoBNz5olulRTk6nRu+notsKxBCyVX0V5GHsRvts/qClz+QcIHMSALV\n" + 
> "UIrumtxxdbL63pIw4ds0PeH5RtyR9JpS5pWxUk1MPUPoYSV9GPg2bPUEY99Ji8qi\n" + 
> "vA1kRTeBfAWC0OgBwbHu1zIKUukMd+pF/D/vKKovJ6I/sPiGXmUw2i4lYOUB0wWn\n" + 
> "QUyBLez1UMWKchyvpW0FYxMbv7j5zMcAH7d++vCWo3OEGfe4Uet6Q3/Dx83HAiEA\n" + 
> "mjtJp7XNrsgxbRDqETkHhv6zYH8Voo+gDgSO1m7XcH0CggEBAI5moswp++plZSBP\n" + 
> "Q9DdCNHt0AV13Toj1jf5M5DNmTX6P6/D/oRfi8Ui1fiCKFv+7lD0J2anCFUaLtu+\n" + 
> "j7v78gp5OChDp/n49K6DtKtZZRDmw/Bpm6LNdknmdN5kO5wVzbIXHTCCeNs/CJTF\n" + 
> "mSU5PvEaI4y3M5NraSgLPkq4gEv7/A8orGbKmj1Whj3F9t1Tosxdm/+WkPldMz2t\n" + 
> "gev+9RM2S6S9XoembRgwRaFVkpQmKoKpOoZcdqV47FLDq5BYH/5POeJ9wLuAHjxQ\n" + 
> "5CMKo4p/lW7BCd4kuGWFT+OFFXfG2v6EtlqFbXBiFWLxyMsOtkUqWARCqEHhyucl\n" + 
> "TSYlj60EIgIgLfA75+8KcKxdN8mr6gzGjQe7jPFGG42Ejhd7Q2F4wuw=" 
> }; 
>  
> // Private key algorithm of endEntityPrivateKeys. 
> final static String[] endEntityPrivateKeyAlgs = { 
> "EC", 
> "RSA", 
> "EC", 
> "DSA", 
> }; 
>  
> // Private key names of endEntityPrivateKeys. 
> static final String[] endEntityPrivateKeyNames = { 
> "ecdsa", 
> "rsa", 
> "ec-rsa", 
> "dsa", 
> }; 
>  
> /* 
> * Create an instance of SSLContext with the specified trust/key materials. 
> */ 
> private SSLContext createSSLContext( 
> String[] trustedMaterials, 
> String[] keyMaterialCerts, 
> String[] keyMaterialKeys, 
> String[] keyMaterialKeyAlgs, 
> String[] keyMaterialKeyNames, 
> ContextParameters params) throws Exception { 
>  
> KeyStore ts = null; // trust store 
> KeyStore ks = null; // key store 
> char passphrase[] = "passphrase".toCharArray(); 
>  
> // Generate certificate from cert string. 
> CertificateFactory cf = CertificateFactory.getInstance("X.509"); 
>  
> // Import the trused certs. 
> ByteArrayInputStream is; 
> if (trustedMaterials != null &amp;&amp; trustedMaterials.length != 0) { 
> ts = KeyStore.getInstance("JKS"); 
> ts.load(null, null); 
>  
> Certificate[] trustedCert = 
> new Certificate[trustedMaterials.length]; 
> for (int i = 0; i &lt; trustedMaterials.length; i++) { 
> String trustedCertStr = trustedMaterials[i]; 
>  
> is = new ByteArrayInputStream(trustedCertStr.getBytes()); 
> try { 
> trustedCert[i] = cf.generateCertificate(is); 
> } finally { 
> is.close(); 
> } 
>  
> ts.setCertificateEntry("trusted-cert-" + i, trustedCert[i]); 
> } 
> } 
>  
> // Import the key materials. 
> // 
> // Note that certification pathes bigger than one are not supported yet. 
> boolean hasKeyMaterials = 
> (keyMaterialCerts != null) &amp;&amp; (keyMaterialCerts.length != 0) &amp;&amp; 
> (keyMaterialKeys != null) &amp;&amp; (keyMaterialKeys.length != 0) &amp;&amp; 
> (keyMaterialKeyAlgs != null) &amp;&amp; (keyMaterialKeyAlgs.length != 0) &amp;&amp; 
> (keyMaterialCerts.length == keyMaterialKeys.length) &amp;&amp; 
> (keyMaterialCerts.length == keyMaterialKeyAlgs.length); 
> if (hasKeyMaterials) { 
> ks = KeyStore.getInstance("JKS"); 
> ks.load(null, null); 
>  
> for (int i = 0; i &lt; keyMaterialCerts.length; i++) { 
> String keyCertStr = keyMaterialCerts[i]; 
>  
> // generate the private key. 
> PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec( 
> Base64.getMimeDecoder().decode(keyMaterialKeys[i])); 
> KeyFactory kf = 
> KeyFactory.getInstance(keyMaterialKeyAlgs[i]); 
> PrivateKey priKey = kf.generatePrivate(priKeySpec); 
>  
> // generate certificate chain 
> is = new ByteArrayInputStream(keyCertStr.getBytes()); 
> Certificate keyCert = null; 
> try { 
> keyCert = cf.generateCertificate(is); 
> } finally { 
> is.close(); 
> } 
>  
> Certificate[] chain = new Certificate[] { keyCert }; 
>  
> // import the key entry. 
> ks.setKeyEntry("cert-" + keyMaterialKeyNames[i], 
> priKey, passphrase, chain); 
> } 
> } 
>  
> // Create an SSLContext object. 
> TrustManagerFactory tmf = 
> TrustManagerFactory.getInstance(params.tmAlgorithm); 
> tmf.init(ts); 
>  
> SSLContext context = SSLContext.getInstance(params.contextProtocol); 
> if (hasKeyMaterials &amp;&amp; ks != null) { 
> KeyManagerFactory kmf = 
> KeyManagerFactory.getInstance(params.kmAlgorithm); 
> kmf.init(ks, passphrase); 
>  
> context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null); 
> } else { 
> context.init(null, tmf.getTrustManagers(), null); 
> } 
>  
> return context; 
> } 
> } 
>  ||||I|||| * log
> * graph
> * tags
> * branches
> * changeset
> * browse
> * file
> * latest
> * diff
> * comparison
> * annotate
> * file log
> * raw
> * help
> OpenJDK / jdk-updates / jdk11u
> view test/jdk/javax/net/ssl/templates/SSLContextTemplate.java @ 51588:18b4acfaaa97
> Find changesets by keywords (author, files, the commit message), revision number or hash, or revset expression.
> 8214339: SSLSocketImpl erroneously wraps SocketException Reviewed-by: ascarpino, jnimeh
> author xuelei
> date Fri, 14 Dec 2018 19:39:39 -0800
> parents
> children 945d9dae301e
> line wrap: on
> line source
> /*
> * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved.
> * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
> *
> * This code is free software; you can redistribute it and/or modify it
> * under the terms of the GNU General Public License version 2 only, as
> * published by the Free Software Foundation.
> *
> * This code is distributed in the hope that it will be useful, but WITHOUT
> * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
> * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
> * version 2 for more details (a copy is included in the LICENSE file that
> * accompanied this code).
> *
> * You should have received a copy of the GNU General Public License version
> * 2 along with this work; if not, write to the Free Software Foundation,
> * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
> *
> * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
> * or visit www.oracle.com if you need additional information or have any
> * questions.
> */
> //
> // Please run in othervm mode. SunJSSE does not support dynamic system
> // properties, no way to re-use system properties in samevm/agentvm mode.
> //
> import java.io.ByteArrayInputStream;
> import java.security.KeyFactory;
> import java.security.KeyStore;
> import java.security.PrivateKey;
> import java.security.cert.Certificate;
> import java.security.cert.CertificateFactory;
> import java.security.spec.PKCS8EncodedKeySpec;
> import java.util.Base64;
> import javax.net.ssl.KeyManagerFactory;
> import javax.net.ssl.SSLContext;
> import javax.net.ssl.TrustManagerFactory;
> /**
> * SSLContext template to speed up JSSE tests.
> */
> public interface SSLContextTemplate {
> /*
> * Create an instance of SSLContext for client use.
> */
> default SSLContext createClientSSLContext() throws Exception {
> return createSSLContext(trustedCertStrs,
> endEntityCertStrs, endEntityPrivateKeys,
> endEntityPrivateKeyAlgs,
> endEntityPrivateKeyNames,
> getClientContextParameters());
> }
> /*
> * Create an instance of SSLContext for server use.
> */
> default SSLContext createServerSSLContext() throws Exception {
> return createSSLContext(trustedCertStrs,
> endEntityCertStrs, endEntityPrivateKeys,
> endEntityPrivateKeyAlgs,
> endEntityPrivateKeyNames,
> getServerContextParameters());
> }
> /*
> * The parameters used to configure SSLContext.
> */
> static final class ContextParameters {
> final String contextProtocol;
> final String tmAlgorithm;
> final String kmAlgorithm;
> ContextParameters(String contextProtocol,
> String tmAlgorithm, String kmAlgorithm) {
> this.contextProtocol = contextProtocol;
> this.tmAlgorithm = tmAlgorithm;
> this.kmAlgorithm = kmAlgorithm;
> }
> }
> /*
> * Get the client side parameters of SSLContext.
> */
> default ContextParameters getClientContextParameters() {
> return new ContextParameters("TLS", "PKIX", "NewSunX509");
> }
> /*
> * Get the server side parameters of SSLContext.
> */
> default ContextParameters getServerContextParameters() {
> return new ContextParameters("TLS", "PKIX", "NewSunX509");
> }
> /*
> * =======================================
> * Certificates and keys used in the test.
> */
> // Trusted certificates.
> final static String[] trustedCertStrs = {
> // SHA256withECDSA, curve prime256v1
> // Validity
> // Not Before: May 22 07:18:16 2018 GMT
> // Not After : May 17 07:18:16 2038 GMT
> // Subject Key Identifier:
> // 60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86
> "-----BEGIN CERTIFICATE-----\n" +
> "MIIBvjCCAWOgAwIBAgIJAIvFG6GbTroCMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\n" +
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" +
> "ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYTAlVT\n" +
> "MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTBZ\n" +
> "MBMGByqGSM49AgEGCCqGSM49AwEHA0IABBz1WeVb6gM2mh85z3QlvaB/l11b5h0v\n" +
> "LIzmkC3DKlVukZT+ltH2Eq1oEkpXuf7QmbM0ibrUgtjsWH3mULfmcWmjUDBOMB0G\n" +
> "A1UdDgQWBBRgz71z//oaMNKk7NNJcUbvGjWghjAfBgNVHSMEGDAWgBRgz71z//oa\n" +
> "MNKk7NNJcUbvGjWghjAMBgNVHRMEBTADAQH/MAoGCCqGSM49BAMCA0kAMEYCIQCG\n" +
> "6wluh1r2/T6L31mZXRKf9JxeSf9pIzoLj+8xQeUChQIhAJ09wAi1kV8yePLh2FD9\n" +
> "2YEHlSQUAbwwqCDEVB5KxaqP\n" +
> "-----END CERTIFICATE-----",
> // -----BEGIN PRIVATE KEY-----
> // MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQg/HcHdoLJCdq3haVd
> // XZTSKP00YzM3xX97l98vGL/RI1KhRANCAAQc9VnlW+oDNpofOc90Jb2gf5ddW+Yd
> // LyyM5pAtwypVbpGU/pbR9hKtaBJKV7n+0JmzNIm61ILY7Fh95lC35nFp
> // -----END PRIVATE KEY-----
> // SHA256withRSA, 2048 bits
> // Validity
> // Not Before: May 22 07:18:16 2018 GMT
> // Not After : May 17 07:18:16 2038 GMT
> // Subject Key Identifier:
> // 0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C
> "-----BEGIN CERTIFICATE-----\n" +
> "MIIDSTCCAjGgAwIBAgIJAI4ZF3iy8zG+MA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\n" +
> "BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\n" +
> "aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMDsxCzAJBgNVBAYT\n" +
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" +
> "ZTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALpMcY7aWieXDEM1/YJf\n" +
> "JW27b4nRIFZyEYhEloyGsKTuQiiQjc8cqRZFNXe2vwziDB4IyTEl0Hjl5QF6ZaQE\n" +
> "huPzzwvQm1pv64KrRXrmj3FisQK8B5OWLty9xp6xDqsaMRoyObLK+oIb20T5fSlE\n" +
> "evmo1vYjnh8CX0Yzx5Gr5ye6YSEHQvYOWEws8ad17OlyToR2KMeC8w4qo6rs59pW\n" +
> "g7Mxn9vo22ImDzrtAbTbXbCias3xlE0Bp0h5luyf+5U4UgksoL9B9r2oP4GrLNEV\n" +
> "oJk57t8lwaR0upiv3CnS8LcJELpegZub5ggqLY8ZPYFQPjlK6IzLOm6rXPgZiZ3m\n" +
> "RL0CAwEAAaNQME4wHQYDVR0OBBYEFA3dk8n+S701t+iZeJD721o92xVMMB8GA1Ud\n" +
> "IwQYMBaAFA3dk8n+S701t+iZeJD721o92xVMMAwGA1UdEwQFMAMBAf8wDQYJKoZI\n" +
> "hvcNAQELBQADggEBAJTRC3rKUUhVH07/1+stUungSYgpM08dY4utJq0BDk36BbmO\n" +
> "0AnLDMbkwFdHEoqF6hQIfpm7SQTmXk0Fss6Eejm8ynYr6+EXiRAsaXOGOBCzF918\n" +
> "/RuKOzqABfgSU4UBKECLM5bMfQTL60qx+HdbdVIpnikHZOFfmjCDVxoHsGyXc1LW\n" +
> "Jhkht8IGOgc4PMGvyzTtRFjz01kvrVQZ75aN2E0GQv6dCxaEY0i3ypSzjUWAKqDh\n" +
> "3e2OLwUSvumcdaxyCdZAOUsN6pDBQ+8VRG7KxnlRlY1SMEk46QgQYLbPDe/+W/yH\n" +
> "ca4PejicPeh+9xRAwoTpiE2gulfT7Lm+fVM7Ruc=\n" +
> "-----END CERTIFICATE-----",
> // -----BEGIN PRIVATE KEY-----
> // MIIEvAIBADANBgkqhkiG9w0BAQEFAASCBKYwggSiAgEAAoIBAQC6THGO2lonlwxD
> // Nf2CXyVtu2+J0SBWchGIRJaMhrCk7kIokI3PHKkWRTV3tr8M4gweCMkxJdB45eUB
> // emWkBIbj888L0Jtab+uCq0V65o9xYrECvAeTli7cvcaesQ6rGjEaMjmyyvqCG9tE
> // +X0pRHr5qNb2I54fAl9GM8eRq+cnumEhB0L2DlhMLPGndezpck6EdijHgvMOKqOq
> // 7OfaVoOzMZ/b6NtiJg867QG0212womrN8ZRNAadIeZbsn/uVOFIJLKC/Qfa9qD+B
> // qyzRFaCZOe7fJcGkdLqYr9wp0vC3CRC6XoGbm+YIKi2PGT2BUD45SuiMyzpuq1z4
> // GYmd5kS9AgMBAAECggEAFHSoU2MuWwJ+2jJnb5U66t2V1bAcuOE1g5zkWvG/G5z9
> // rq6Qo5kmB8f5ovdx6tw3MGUOklLwnRXBG3RxDJ1iokz3AvkY1clMNsDPlDsUrQKF
> // JSO4QUBQTPSZhnsyfR8XHSU+qJ8Y+ohMfzpVv95BEoCzebtXdVgxVegBlcEmVHo2
> // kMmkRN+bYNsr8eb2r+b0EpyumS39ZgKYh09+cFb78y3T6IFMGcVJTP6nlGBFkmA/
> // 25pYeCF2tSki08qtMJZQAvKfw0Kviibk7ZxRbJqmc7B1yfnOEHP6ftjuvKl2+RP/
> // +5P5f8CfIP6gtA0LwSzAqQX/hfIKrGV5j0pCqrD0kQKBgQDeNR6Xi4sXVq79lihO
> // a1bSeV7r8yoQrS8x951uO+ox+UIZ1MsAULadl7zB/P0er92p198I9M/0Jth3KBuS
> // zj45mucvpiiGvmQlMKMEfNq4nN7WHOu55kufPswQB2mR4J3xmwI+4fM/nl1zc82h
> // De8JSazRldJXNhfx0RGFPmgzbwKBgQDWoVXrXLbCAn41oVnWB8vwY9wjt92ztDqJ
> // HMFA/SUohjePep9UDq6ooHyAf/Lz6oE5NgeVpPfTDkgvrCFVKnaWdwALbYoKXT2W
> // 9FlyJox6eQzrtHAacj3HJooXWuXlphKSizntfxj3LtMR9BmrmRJOfK+SxNOVJzW2
> // +MowT20EkwKBgHmpB8jdZBgxI7o//m2BI5Y1UZ1KE5vx1kc7VXzHXSBjYqeV9FeF
> // 2ZZLP9POWh/1Fh4pzTmwIDODGT2UPhSQy0zq3O0fwkyT7WzXRknsuiwd53u/dejg
> // iEL2NPAJvulZ2+AuiHo5Z99LK8tMeidV46xoJDDUIMgTG+UQHNGhK5gNAoGAZn/S
> // Cn7SgMC0CWSvBHnguULXZO9wH1wZAFYNLL44OqwuaIUFBh2k578M9kkke7woTmwx
> // HxQTjmWpr6qimIuY6q6WBN8hJ2Xz/d1fwhYKzIp20zHuv5KDUlJjbFfqpsuy3u1C
> // kts5zwI7pr1ObRbDGVyOdKcu7HI3QtR5qqyjwaUCgYABo7Wq6oHva/9V34+G3Goh
> // 63bYGUnRw2l5BD11yhQv8XzGGZFqZVincD8gltNThB0Dc/BI+qu3ky4YdgdZJZ7K
> // z51GQGtaHEbrHS5caV79yQ8QGY5mUVH3E+VXSxuIqb6pZq2DH4sTAEFHyncddmOH
> // zoXBInYwRG9KE/Bw5elhUw==
> // -----END PRIVATE KEY-----
> // SHA256withDSA, 2048 bits
> // Validity
> // Not Before: May 22 07:18:18 2018 GMT
> // Not After : May 17 07:18:18 2038 GMT
> // Subject Key Identifier:
> // 76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53
> "-----BEGIN CERTIFICATE-----\n" +
> "MIIErjCCBFSgAwIBAgIJAOktYLNCbr02MAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\n" +
> "EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\n" +
> "Y2UwHhcNMTgwNTIyMDcxODE4WhcNMzgwNTE3MDcxODE4WjA7MQswCQYDVQQGEwJV\n" +
> "UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Uw\n" +
> "ggNHMIICOQYHKoZIzjgEATCCAiwCggEBAO5GyPhSm0ze3LSu+gicdULLj05iOfTL\n" +
> "UvZQ29sYz41zmqrLBQbdKiHqgJu2Re9sgTb5suLNjF047TOLPnU3jhPtWm2X8Xzi\n" +
> "VGIcHym/Q/MeZxStt/88seqroI3WOKzIML2GcrishT+lcGrtH36Tf1+ue2Snn3PS\n" +
> "WyxygNqPjllP5uUjYmFLvAf4QLMldkd/D2VxcwsHjB8y5iUZsXezc/LEhRZS/02m\n" +
> "ivqlRw3AMkq/OVe/ZtxFWsP0nsfxEGdZuaUFpppGfixxFvymrB3+J51cTt+pZBDq\n" +
> "D2y0DYfc+88iCs4jwHTfcDIpLb538HBjBj2rEgtQESQmB0ooD/+wsPsCIQC1bYch\n" +
> "gElNtDYL3FgpLgNSUYp7gIWv9ehaC7LO2z7biQKCAQBitvFOnDkUja8NAF7lDpOV\n" +
> "b5ipQ8SicBLW3kQamxhyuyxgZyy/PojZ/oPorkqW/T/A0rhnG6MssEpAtdiwVB+c\n" +
> "rBYGo3bcwmExJhdOJ6dYuKFppPWhCwKMHs9npK+lqBMl8l5j58xlcFeC7ZfGf8GY\n" +
> "GkhFW0c44vEQhMMbac6ZTTP4mw+1t7xJfmDMlLEyIpTXaAAk8uoVLWzQWnR40sHi\n" +
> "ybvS0u3JxQkb7/y8tOOZu8qlz/YOS7lQ6UxUGX27Ce1E0+agfPphetoRAlS1cezq\n" +
> "Wa7r64Ga0nkj1kwkcRqjgTiJx0NwnUXr78VAXFhVF95+O3lfqhvdtEGtkhDGPg7N\n" +
> "A4IBBgACggEBAMmSHQK0w2i+iqUjOPzn0yNEZrzepLlLeQ1tqtn0xnlv5vBAeefD\n" +
> "Pm9dd3tZOjufVWP7hhEz8xPobb1CS4e3vuQiv5UBfhdPL3f3l9T7JMAKPH6C9Vve\n" +
> "OQXE5eGqbjsySbcmseHoYUt1WCSnSda1opX8zchX04e7DhGfE2/L9flpYEoSt8lI\n" +
> "vMNjgOwvKdW3yvPt1/eBBHYNFG5gWPv/Q5KoyCtHS03uqGm4rNc/wZTIEEfd66C+\n" +
> "QRaUltjOaHmtwOdDHaNqwhYZSVOip+Mo+TfyzHFREcdHLapo7ZXqbdYkRGxRR3d+\n" +
> "3DfHaraJO0OKoYlPkr3JMvM/MSGR9AnZOcejUDBOMB0GA1UdDgQWBBR2Zp73O91F\n" +
> "5TvZcjw/8FQ5hjEmUzAfBgNVHSMEGDAWgBR2Zp73O91F5TvZcjw/8FQ5hjEmUzAM\n" +
> "BgNVHRMEBTADAQH/MAsGCWCGSAFlAwQDAgNHADBEAiBzriYE41M2y9Hy5ppkL0Qn\n" +
> "dIlNc8JhXT/PHW7GDtViagIgMko8Qoj9gDGPK3+O9E8DC3wGiiF9CObM4LN387ok\n" +
> "J+g=\n" +
> "-----END CERTIFICATE-----"
> // -----BEGIN PRIVATE KEY-----
> // MIICZQIBADCCAjkGByqGSM44BAEwggIsAoIBAQDuRsj4UptM3ty0rvoInHVCy49O
> // Yjn0y1L2UNvbGM+Nc5qqywUG3Soh6oCbtkXvbIE2+bLizYxdOO0ziz51N44T7Vpt
> // l/F84lRiHB8pv0PzHmcUrbf/PLHqq6CN1jisyDC9hnK4rIU/pXBq7R9+k39frntk
> // p59z0lsscoDaj45ZT+blI2JhS7wH+ECzJXZHfw9lcXMLB4wfMuYlGbF3s3PyxIUW
> // Uv9Npor6pUcNwDJKvzlXv2bcRVrD9J7H8RBnWbmlBaaaRn4scRb8pqwd/iedXE7f
> // qWQQ6g9stA2H3PvPIgrOI8B033AyKS2+d/BwYwY9qxILUBEkJgdKKA//sLD7AiEA
> // tW2HIYBJTbQ2C9xYKS4DUlGKe4CFr/XoWguyzts+24kCggEAYrbxTpw5FI2vDQBe
> // 5Q6TlW+YqUPEonAS1t5EGpsYcrssYGcsvz6I2f6D6K5Klv0/wNK4ZxujLLBKQLXY
> // sFQfnKwWBqN23MJhMSYXTienWLihaaT1oQsCjB7PZ6SvpagTJfJeY+fMZXBXgu2X
> // xn/BmBpIRVtHOOLxEITDG2nOmU0z+JsPtbe8SX5gzJSxMiKU12gAJPLqFS1s0Fp0
> // eNLB4sm70tLtycUJG+/8vLTjmbvKpc/2Dku5UOlMVBl9uwntRNPmoHz6YXraEQJU
> // tXHs6lmu6+uBmtJ5I9ZMJHEao4E4icdDcJ1F6+/FQFxYVRfefjt5X6ob3bRBrZIQ
> // xj4OzQQjAiEAsceWOM8do4etxp2zgnoNXV8PUUyqWhz1+0srcKV7FR4=
> // -----END PRIVATE KEY-----
> };
> // End entity certificate.
> final static String[] endEntityCertStrs = {
> // SHA256withECDSA, curve prime256v1
> // Validity
> // Not Before: May 22 07:18:16 2018 GMT
> // Not After : May 17 07:18:16 2038 GMT
> // Authority Key Identifier:
> // 60:CF:BD:73:FF:FA:1A:30:D2:A4:EC:D3:49:71:46:EF:1A:35:A0:86
> "-----BEGIN CERTIFICATE-----\n" +
> "MIIBqjCCAVCgAwIBAgIJAPLY8qZjgNRAMAoGCCqGSM49BAMCMDsxCzAJBgNVBAYT\n" +
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" +
> "ZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYTAlVT\n" +
> "MQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZjZTEY\n" +
> "MBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcD\n" +
> "QgAEb+9n05qfXnfHUb0xtQJNS4JeSi6IjOfW5NqchvKnfJey9VkJzR7QHLuOESdf\n" +
> "xlR7q8YIWgih3iWLGfB+wxHiOqMjMCEwHwYDVR0jBBgwFoAUYM+9c//6GjDSpOzT\n" +
> "SXFG7xo1oIYwCgYIKoZIzj0EAwIDSAAwRQIgWpRegWXMheiD3qFdd8kMdrkLxRbq\n" +
> "1zj8nQMEwFTUjjQCIQDRIrAjZX+YXHN9b0SoWWLPUq0HmiFIi8RwMnO//wJIGQ==\n" +
> "-----END CERTIFICATE-----",
> // SHA256withRSA, 2048 bits
> // Validity
> // Not Before: May 22 07:18:16 2018 GMT
> // Not After : May 17 07:18:16 2038 GMT
> // Authority Key Identifier:
> // 0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C
> "-----BEGIN CERTIFICATE-----\n" +
> "MIIDNjCCAh6gAwIBAgIJAO2+yPcFryUTMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\n" +
> "BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\n" +
> "aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0zODA1MTcwNzE4MTZaMFUxCzAJBgNVBAYT\n" +
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" +
> "ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MIIBIjANBgkqhkiG9w0BAQEFAAOC\n" +
> "AQ8AMIIBCgKCAQEAszfBobWfZIp8AgC6PiWDDavP65mSvgCXUGxACbxVNAfkLhNR\n" +
> "QOsHriRB3X1Q3nvO9PetC6wKlvE9jlnDDj7D+1j1r1CHO7ms1fq8rfcQYdkanDtu\n" +
> "4AlHo8v+SSWX16MIXFRYDj2VVHmyPtgbltcg4zGAuwT746FdLI94uXjJjq1IOr/v\n" +
> "0VIlwE5ORWH5Xc+5Tj+oFWK0E4a4GHDgtKKhn2m72hN56/GkPKGkguP5NRS1qYYV\n" +
> "/EFkdyQMOV8J1M7HaicSft4OL6eKjTrgo93+kHk+tv0Dc6cpVBnalX3TorG8QI6B\n" +
> "cHj1XQd78oAlAC+/jF4pc0mwi0un49kdK9gRfQIDAQABoyMwITAfBgNVHSMEGDAW\n" +
> "gBQN3ZPJ/ku9NbfomXiQ+9taPdsVTDANBgkqhkiG9w0BAQsFAAOCAQEApXS0nKwm\n" +
> "Kp8gpmO2yG1rpd1+2wBABiMU4JZaTqmma24DQ3RzyS+V2TeRb29dl5oTUEm98uc0\n" +
> "GPZvhK8z5RFr4YE17dc04nI/VaNDCw4y1NALXGs+AHkjoPjLyGbWpi1S+gfq2sNB\n" +
> "Ekkjp6COb/cb9yiFXOGVls7UOIjnVZVd0r7KaPFjZhYh82/f4PA/A1SnIKd1+nfH\n" +
> "2yk7mSJNC7Z3qIVDL8MM/jBVwiC3uNe5GPB2uwhd7k5LGAVN3j4HQQGB0Sz+VC1h\n" +
> "92oi6xDa+YBva2fvHuCd8P50DDjxmp9CemC7rnZ5j8egj88w14X44Xjb/Fd/ApG9\n" +
> "e57NnbT7KM+Grw==\n" +
> "-----END CERTIFICATE-----",
> // SHA256withRSA, curv prime256v1
> // Validity
> // Not Before: May 22 07:18:16 2018 GMT
> // Not After : May 21 07:18:16 2028 GMT
> // Authority Key Identifier:
> // 0D:DD:93:C9:FE:4B:BD:35:B7:E8:99:78:90:FB:DB:5A:3D:DB:15:4C
> "-----BEGIN CERTIFICATE-----\n" +
> "MIICazCCAVOgAwIBAgIJAO2+yPcFryUUMA0GCSqGSIb3DQEBCwUAMDsxCzAJBgNV\n" +
> "BAYTAlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2Vy\n" +
> "aXZjZTAeFw0xODA1MjIwNzE4MTZaFw0yODA1MjEwNzE4MTZaMFUxCzAJBgNVBAYT\n" +
> "AlVTMQ0wCwYDVQQKDARKYXZhMR0wGwYDVQQLDBRTdW5KU1NFIFRlc3QgU2VyaXZj\n" +
> "ZTEYMBYGA1UEAwwPUmVncmVzc2lvbiBUZXN0MFkwEwYHKoZIzj0CAQYIKoZIzj0D\n" +
> "AQcDQgAE59MERNTlVZ1eeps8Z3Oue5ZkgQdPtD+WIE6tj3PbIKpxGPDxvfNP959A\n" +
> "yQjEK/ehWQVrCMmNoEkIzY+IIBgB06MjMCEwHwYDVR0jBBgwFoAUDd2Tyf5LvTW3\n" +
> "6Jl4kPvbWj3bFUwwDQYJKoZIhvcNAQELBQADggEBAFOTVEqs70ykhZiIdrEsF1Ra\n" +
> "I3B2rLvwXZk52uSltk2/bzVvewA577ZCoxQ1pL7ynkisPfBN1uVYtHjM1VA3RC+4\n" +
> "+TAK78dnI7otYjWoHp5rvs4l6c/IbOspS290IlNuDUxMErEm5wxIwj+Aukx/1y68\n" +
> "hOyCvHBLMY2c1LskH1MMBbDuS1aI+lnGpToi+MoYObxGcV458vxuT8+wwV8Fkpvd\n" +
> "ll8IIFmeNPRv+1E+lXbES6CSNCVaZ/lFhPgdgYKleN7sfspiz50DG4dqafuEAaX5\n" +
> "xaK1NWXJxTRz0ROH/IUziyuDW6jphrlgit4+3NCzp6vP9hAJQ8Vhcj0n15BKHIQ=\n" +
> "-----END CERTIFICATE-----",
> // SHA256withDSA, 2048 bits
> // Validity
> // Not Before: May 22 07:18:20 2018 GMT
> // Not After : May 17 07:18:20 2038 GMT
> // Authority Key Identifier:
> // 76:66:9E:F7:3B:DD:45:E5:3B:D9:72:3C:3F:F0:54:39:86:31:26:53
> "-----BEGIN CERTIFICATE-----\n" +
> "MIIEnDCCBEGgAwIBAgIJAP/jh1qVhNVjMAsGCWCGSAFlAwQDAjA7MQswCQYDVQQG\n" +
> "EwJVUzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2\n" +
> "Y2UwHhcNMTgwNTIyMDcxODIwWhcNMzgwNTE3MDcxODIwWjBVMQswCQYDVQQGEwJV\n" +
> "UzENMAsGA1UECgwESmF2YTEdMBsGA1UECwwUU3VuSlNTRSBUZXN0IFNlcml2Y2Ux\n" +
> "GDAWBgNVBAMMD1JlZ3Jlc3Npb24gVGVzdDCCA0cwggI6BgcqhkjOOAQBMIICLQKC\n" +
> "AQEAmlavgoJrMcjqWRVcDE2dmWAPREgnzQvneEDef68cprDzjSwvOs5QeFyx75ib\n" +
> "ado1e6jO/rW1prCGWHDD1oA/Tn4Pk3vu0nUxzvl1qATc+aJbpUU5Op0bvp6LbCsQ\n" +
> "QslV9FeRh7Eb7bP6gpc/kHCBzEgC1VCK7prccXWy+t6SMOHbND3h+UbckfSaUuaV\n" +
> "sVJNTD1D6GElfRj4Nmz1BGPfSYvKorwNZEU3gXwFgtDoAcGx7tcyClLpDHfqRfw/\n" +
> "7yiqLyeiP7D4hl5lMNouJWDlAdMFp0FMgS3s9VDFinIcr6VtBWMTG7+4+czHAB+3\n" +
> "fvrwlqNzhBn3uFHrekN/w8fNxwIhAJo7Sae1za7IMW0Q6hE5B4b+s2B/FaKPoA4E\n" +
> "jtZu13B9AoIBAQCOZqLMKfvqZWUgT0PQ3QjR7dAFdd06I9Y3+TOQzZk1+j+vw/6E\n" +
> "X4vFItX4gihb/u5Q9CdmpwhVGi7bvo+7+/IKeTgoQ6f5+PSug7SrWWUQ5sPwaZui\n" +
> "zXZJ5nTeZDucFc2yFx0wgnjbPwiUxZklOT7xGiOMtzOTa2koCz5KuIBL+/wPKKxm\n" +
> "ypo9VoY9xfbdU6LMXZv/lpD5XTM9rYHr/vUTNkukvV6Hpm0YMEWhVZKUJiqCqTqG\n" +
> "XHaleOxSw6uQWB/+TznifcC7gB48UOQjCqOKf5VuwQneJLhlhU/jhRV3xtr+hLZa\n" +
> "hW1wYhVi8cjLDrZFKlgEQqhB4crnJU0mJY+tA4IBBQACggEAID0ezl00/X8mv7eb\n" +
> "bzovum1+DEEP7FM57k6HZEG2N3ve4CW+0m9Cd+cWPz8wkZ+M0j/Eqa6F0IdbkXEc\n" +
> "Q7CuzvUyJ57xQ3L/WCgXsiS+Bh8O4Mz7GwW22CGmHqafbVv+hKBfr8MkskO6GJUt\n" +
> "SUF/CVLzB4gMIvZMH26tBP2xK+i7FeEK9kT+nGdzQSZBAhFYpEVCBplHZO24/OYq\n" +
> "1DNoU327nUuXIhmsfA8N0PjiWbIZIjTPwBGr9H0LpATI7DIDNcvRRvtROP+pBU9y\n" +
> "fuykPkptg9C0rCM9t06bukpOSaEz/2VIQdLE8fHYFA6pHZ6CIc2+5cfvMgTPhcjz\n" +
> "W2jCt6MjMCEwHwYDVR0jBBgwFoAUdmae9zvdReU72XI8P/BUOYYxJlMwCwYJYIZI\n" +
> "AWUDBAMCA0gAMEUCIQCeI5fN08b9BpOaHdc3zQNGjp24FOL/RxlBLeBAorswJgIg\n" +
> "JEZ8DhYxQy1O7mmZ2UIT7op6epWMB4dENjs0qWPmcKo=\n" +
> "-----END CERTIFICATE-----"
> };
> // Private key in the format of PKCS#8.
> final static String[] endEntityPrivateKeys = {
> //
> // EC private key related to cert endEntityCertStrs[0].
> //
> "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgn5K03bpTLjEtFQRa\n" +
> "JUtx22gtmGEvvSUSQdimhGthdtihRANCAARv72fTmp9ed8dRvTG1Ak1Lgl5KLoiM\n" +
> "59bk2pyG8qd8l7L1WQnNHtAcu44RJ1/GVHurxghaCKHeJYsZ8H7DEeI6",
> //
> // RSA private key related to cert endEntityCertStrs[1].
> //
> "MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQCzN8GhtZ9kinwC\n" +
> "ALo+JYMNq8/rmZK+AJdQbEAJvFU0B+QuE1FA6weuJEHdfVDee870960LrAqW8T2O\n" +
> "WcMOPsP7WPWvUIc7uazV+ryt9xBh2RqcO27gCUejy/5JJZfXowhcVFgOPZVUebI+\n" +
> "2BuW1yDjMYC7BPvjoV0sj3i5eMmOrUg6v+/RUiXATk5FYfldz7lOP6gVYrQThrgY\n" +
> "cOC0oqGfabvaE3nr8aQ8oaSC4/k1FLWphhX8QWR3JAw5XwnUzsdqJxJ+3g4vp4qN\n" +
> "OuCj3f6QeT62/QNzpylUGdqVfdOisbxAjoFwePVdB3vygCUAL7+MXilzSbCLS6fj\n" +
> "2R0r2BF9AgMBAAECggEASIkPkMCuw4WdTT44IwERus3IOIYOs2IP3BgEDyyvm4B6\n" +
> "JP/iihDWKfA4zEl1Gqcni1RXMHswSglXra682J4kui02Ov+vzEeJIY37Ibn2YnP5\n" +
> "ZjRT2s9GtI/S2o4hl8A/mQb2IMViFC+xKehTukhV4j5d6NPKk0XzLR7gcMjnYxwn\n" +
> "l21fS6D2oM1xRG/di7sL+uLF8EXLRzfiWDNi12uQv4nwtxPKvuKhH6yzHt7YqMH0\n" +
> "46pmDKDaxV4w1JdycjCb6NrCJOYZygoQobuZqOQ30UZoZsPJrtovkncFr1e+lNcO\n" +
> "+aWDfOLCtTH046dEQh5oCShyXMybNlry/QHsOtHOwQKBgQDh2iIjs+FPpQy7Z3EX\n" +
> "DGEvHYqPjrYO9an2KSRr1m9gzRlWYxKY46WmPKwjMerYtra0GP+TBHrgxsfO8tD2\n" +
> "wUAII6sd1qup0a/Sutgf2JxVilLykd0+Ge4/Cs51tCdJ8EqDV2B6WhTewOY2EGvg\n" +
> "JiKYkeNwgRX/9M9CFSAMAk0hUQKBgQDLJAartL3DoGUPjYtpJnfgGM23yAGl6G5r\n" +
> "NSXDn80BiYIC1p0bG3N0xm3yAjqOtJAUj9jZbvDNbCe3GJfLARMr23legX4tRrgZ\n" +
> "nEdKnAFKAKL01oM+A5/lHdkwaZI9yyv+hgSVdYzUjB8rDmzeVQzo1BT7vXypt2yV\n" +
> "6O1OnUpCbQKBgA/0rzDChopv6KRcvHqaX0tK1P0rYeVQqb9ATNhpf9jg5Idb3HZ8\n" +
> "rrk91BNwdVz2G5ZBpdynFl9G69rNAMJOCM4KZw5mmh4XOEq09Ivba8AHU7DbaTv3\n" +
> "7QL7KnbaUWRB26HHzIMYVh0el6T+KADf8NXCiMTr+bfpfbL3dxoiF3zhAoGAbCJD\n" +
> "Qse1dBs/cKYCHfkSOsI5T6kx52Tw0jS6Y4X/FOBjyqr/elyEexbdk8PH9Ar931Qr\n" +
> "NKMvn8oA4iA/PRrXX7M2yi3YQrWwbkGYWYjtzrzEAdzmg+5eARKAeJrZ8/bg9l3U\n" +
> "ttKaItJsDPlizn8rngy3FsJpR9aSAMK6/+wOiYkCgYEA1tZkI1rD1W9NYZtbI9BE\n" +
> "qlJVFi2PBOJMKNuWdouPX3HLQ72GJSQff2BFzLTELjweVVJ0SvY4IipzpQOHQOBy\n" +
> "5qh/p6izXJZh3IHtvwVBjHoEVplg1b2+I5e3jDCfqnwcQw82dW5SxOJMg1h/BD0I\n" +
> "qAL3go42DYeYhu/WnECMeis=",
> //
> // EC private key related to cert endEntityCertStrs[2].
> //
> "MIGHAgEAMBMGByqGSM49AgEGCCqGSM49AwEHBG0wawIBAQQgGVc7hICpmp91jbYe\n" +
> "nrr8nYHD37RZP3VENY+szuA7WjuhRANCAATn0wRE1OVVnV56mzxnc657lmSBB0+0\n" +
> "P5YgTq2Pc9sgqnEY8PG980/3n0DJCMQr96FZBWsIyY2gSQjNj4ggGAHT",
> //
> // DSA private key related to cert endEntityCertStrs[3].
> //
> "MIICZQIBADCCAjoGByqGSM44BAEwggItAoIBAQCaVq+CgmsxyOpZFVwMTZ2ZYA9E\n" +
> "SCfNC+d4QN5/rxymsPONLC86zlB4XLHvmJtp2jV7qM7+tbWmsIZYcMPWgD9Ofg+T\n" +
> "e+7SdTHO+XWoBNz5olulRTk6nRu+notsKxBCyVX0V5GHsRvts/qClz+QcIHMSALV\n" +
> "UIrumtxxdbL63pIw4ds0PeH5RtyR9JpS5pWxUk1MPUPoYSV9GPg2bPUEY99Ji8qi\n" +
> "vA1kRTeBfAWC0OgBwbHu1zIKUukMd+pF/D/vKKovJ6I/sPiGXmUw2i4lYOUB0wWn\n" +
> "QUyBLez1UMWKchyvpW0FYxMbv7j5zMcAH7d++vCWo3OEGfe4Uet6Q3/Dx83HAiEA\n" +
> "mjtJp7XNrsgxbRDqETkHhv6zYH8Voo+gDgSO1m7XcH0CggEBAI5moswp++plZSBP\n" +
> "Q9DdCNHt0AV13Toj1jf5M5DNmTX6P6/D/oRfi8Ui1fiCKFv+7lD0J2anCFUaLtu+\n" +
> "j7v78gp5OChDp/n49K6DtKtZZRDmw/Bpm6LNdknmdN5kO5wVzbIXHTCCeNs/CJTF\n" +
> "mSU5PvEaI4y3M5NraSgLPkq4gEv7/A8orGbKmj1Whj3F9t1Tosxdm/+WkPldMz2t\n" +
> "gev+9RM2S6S9XoembRgwRaFVkpQmKoKpOoZcdqV47FLDq5BYH/5POeJ9wLuAHjxQ\n" +
> "5CMKo4p/lW7BCd4kuGWFT+OFFXfG2v6EtlqFbXBiFWLxyMsOtkUqWARCqEHhyucl\n" +
> "TSYlj60EIgIgLfA75+8KcKxdN8mr6gzGjQe7jPFGG42Ejhd7Q2F4wuw="
> };
> // Private key algorithm of endEntityPrivateKeys.
> final static String[] endEntityPrivateKeyAlgs = {
> "EC",
> "RSA",
> "EC",
> "DSA",
> };
> // Private key names of endEntityPrivateKeys.
> static final String[] endEntityPrivateKeyNames = {
> "ecdsa",
> "rsa",
> "ec-rsa",
> "dsa",
> };
> /*
> * Create an instance of SSLContext with the specified trust/key materials.
> */
> private SSLContext createSSLContext(
> String[] trustedMaterials,
> String[] keyMaterialCerts,
> String[] keyMaterialKeys,
> String[] keyMaterialKeyAlgs,
> String[] keyMaterialKeyNames,
> ContextParameters params) throws Exception {
> KeyStore ts = null; // trust store
> KeyStore ks = null; // key store
> char passphrase[] = "passphrase".toCharArray();
> // Generate certificate from cert string.
> CertificateFactory cf = CertificateFactory.getInstance("X.509");
> // Import the trused certs.
> ByteArrayInputStream is;
> if (trustedMaterials != null && trustedMaterials.length != 0) {
> ts = KeyStore.getInstance("JKS");
> ts.load(null, null);
> Certificate[] trustedCert =
> new Certificate[trustedMaterials.length];
> for (int i = 0; i < trustedMaterials.length; i++) {
> String trustedCertStr = trustedMaterials[i];
> is = new ByteArrayInputStream(trustedCertStr.getBytes());
> try {
> trustedCert[i] = cf.generateCertificate(is);
> } finally {
> is.close();
> }
> ts.setCertificateEntry("trusted-cert-" + i, trustedCert[i]);
> }
> }
> // Import the key materials.
> //
> // Note that certification pathes bigger than one are not supported yet.
> boolean hasKeyMaterials =
> (keyMaterialCerts != null) && (keyMaterialCerts.length != 0) &&
> (keyMaterialKeys != null) && (keyMaterialKeys.length != 0) &&
> (keyMaterialKeyAlgs != null) && (keyMaterialKeyAlgs.length != 0) &&
> (keyMaterialCerts.length == keyMaterialKeys.length) &&
> (keyMaterialCerts.length == keyMaterialKeyAlgs.length);
> if (hasKeyMaterials) {
> ks = KeyStore.getInstance("JKS");
> ks.load(null, null);
> for (int i = 0; i < keyMaterialCerts.length; i++) {
> String keyCertStr = keyMaterialCerts[i];
> // generate the private key.
> PKCS8EncodedKeySpec priKeySpec = new PKCS8EncodedKeySpec(
> Base64.getMimeDecoder().decode(keyMaterialKeys[i]));
> KeyFactory kf =
> KeyFactory.getInstance(keyMaterialKeyAlgs[i]);
> PrivateKey priKey = kf.generatePrivate(priKeySpec);
> // generate certificate chain
> is = new ByteArrayInputStream(keyCertStr.getBytes());
> Certificate keyCert = null;
> try {
> keyCert = cf.generateCertificate(is);
> } finally {
> is.close();
> }
> Certificate[] chain = new Certificate[] { keyCert };
> // import the key entry.
> ks.setKeyEntry("cert-" + keyMaterialKeyNames[i],
> priKey, passphrase, chain);
> }
> }
> // Create an SSLContext object.
> TrustManagerFactory tmf =
> TrustManagerFactory.getInstance(params.tmAlgorithm);
> tmf.init(ts);
> SSLContext context = SSLContext.getInstance(params.contextProtocol);
> if (hasKeyMaterials && ks != null) {
> KeyManagerFactory kmf =
> KeyManagerFactory.getInstance(params.kmAlgorithm);
> kmf.init(ks, passphrase);
> context.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);
> } else {
> context.init(null, tmf.getTrustManagers(), null);
> }
> return context;
> }
> }
> © 2007, 2023 Oracle and/or its affiliates
> Terms of Use · Privacy · Trademarks
> 
> jwilhelm
> date
> Mon, 28 Sep 2020 19:12:52 +0200
> parents
>  ee6f7a61f3a5 
> children
>  
>  line wrap: on 
>  line source 
>  /* 
>  * Copyright (c) 2018, Oracle and/or its affiliates. All rights reserved. 
>  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER. 
>  * 
>  * This code is free software; you can redistribute it and/or modify it 
>  * under the terms of the GNU General Public License version 2 only, as 
>  * published by the Free Software Foundation. 
>  * 
>  * This code is distributed in the hope that it will be useful, but WITHOUT 
>  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
>  * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License 
>  * version 2 for more details (a copy is included in the LICENSE file that 
>  * accompanied this code). 
>  * 
>  * You should have received a copy of the GNU General Public License version 
>  * 2 along with this work; if not, write to the Free Software Foundation, 
>  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA. 
>  * 
>  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA 
>  * or visit www.oracle.com if you need additional information or have any 
>  * questions. 
>  */ 
>  
>  import java.io.IOException; 
>  import java.io.UncheckedIOException; 
>  import java.nio.ByteBuffer; 
>  import java.nio.file.Files; 
>  import java.nio.file.Path; 
>  import java.util.ArrayList; 
>  import java.util.Collections; 
>  import java.util.List; 
>  import java.util.Optional; 
>  import java.util.concurrent.CompletableFuture; 
>  import java.util.concurrent.Flow; 
>  import java.util.concurrent.SubmissionPublisher; 
>  import java.net.http.HttpClient; 
>  import java.net.http.HttpHeaders; 
>  import java.net.http.HttpRequest; 
>  import java.net.http.HttpResponse; 
>  import java.net.http.HttpResponse.BodyHandler; 
>  import java.net.http.HttpResponse.BodySubscriber; 
>  import java.net.http.HttpResponse.PushPromiseHandler; 
>  import static java.nio.charset.StandardCharsets.UTF_8; 
>  import static java.nio.ByteBuffer.wrap; 
>  
>  /** 
>  * An HttpClient that returns a given fixed response. 
>  * Suitable for testing where network connections are to be avoided. 
>  */ 
>  public class FixedResponseHttpClient extends DelegatingHttpClient { 
>  private final ByteBuffer responseBodyBytes; 
>  private final int responseStatusCode; 
>  private final HttpHeaders responseHeaders; 
>  private final HttpClient.Version responseVersion; 
>  private final HttpResponse.ResponseInfo responseInfo; 
>  
>  private FixedResponseHttpClient(HttpClient.Builder builder, 
>  int responseStatusCode, 
>  HttpHeaders responseHeaders, 
>  ByteBuffer responseBodyBytes) { 
>  super(builder.build()); 
>  this.responseStatusCode = responseStatusCode; 
>  this.responseHeaders = responseHeaders; 
>  this.responseBodyBytes = responseBodyBytes; 
>  this.responseVersion = HttpClient.Version.HTTP_1_1; // should be added to constructor 
>  this.responseInfo = new FixedResponseInfo(); 
>  } 
>  
>  /** 
>  * Creates a new HttpClient that returns a fixed response, 
>  * constructed from the given values, for every request sent. 
>  */ 
>  public static HttpClient createClientFrom(HttpClient.Builder builder, 
>  int responseStatusCode, 
>  HttpHeaders responseHeaders, 
>  String responseBody) { 
>  return new FixedResponseHttpClient(builder, 
>  responseStatusCode, 
>  responseHeaders, 
>  wrap(responseBody.getBytes(UTF_8))); 
>  } 
>  
>  /** 
>  * Creates a new HttpClient that returns a fixed response, 
>  * constructed from the given values, for every request sent. 
>  */ 
>  public static HttpClient createClientFrom(HttpClient.Builder builder, 
>  int responseStatusCode, 
>  HttpHeaders responseHeaders, 
>  Path path) { 
>  try { 
>  return new FixedResponseHttpClient(builder, 
>  responseStatusCode, 
>  responseHeaders, 
>  wrap(Files.readAllBytes(path))); 
>  } catch (IOException ioe) { 
>  throw new UncheckedIOException(ioe); 
>  } 
>  } 
>  
>  /** 
>  * Creates a new HttpClient that returns a fixed response, 
>  * constructed from the given values, for every request sent. 
>  */ 
>  public static HttpClient createClientFrom(HttpClient.Builder builder, 
>  int responseStatusCode, 
>  HttpHeaders responseHeaders, 
>  byte[] responseBody) { 
>  return new FixedResponseHttpClient(builder, 
>  responseStatusCode, 
>  responseHeaders, 
>  wrap(responseBody)); 
>  } 
>  
>  private static final ByteBuffer ECHO_SENTINAL = ByteBuffer.wrap(new byte[] {}); 
>  
>  /** 
>  * Creates a new HttpClient that returns a fixed response, 
>  * constructed from the given values, for every request sent. 
>  */ 
>  public static HttpClient createEchoClient(HttpClient.Builder builder, 
>  int responseStatusCode, 
>  HttpHeaders responseHeaders) { 
>  return new FixedResponseHttpClient(builder, 
>  responseStatusCode, 
>  responseHeaders, 
>  ECHO_SENTINAL); 
>  } 
>  
>  @Override 
>  public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; 
>  sendAsync(HttpRequest request, BodyHandler&lt;T&gt; responseBodyHandler) { 
>  return sendAsync(request, responseBodyHandler, null); 
>  } 
>  
>  @Override 
>  public &lt;T&gt; HttpResponse&lt;T&gt; send(HttpRequest request, 
>  BodyHandler&lt;T&gt; responseBodyHandler) 
>  throws IOException, InterruptedException { 
>  return sendAsync(request, responseBodyHandler).join(); // unwrap exceptions if needed 
>  } 
>  
>  class FixedResponseInfo implements HttpResponse.ResponseInfo { 
>  private final int statusCode; 
>  private final HttpHeaders headers; 
>  private final HttpClient.Version version; 
>  
>  FixedResponseInfo() { 
>  this.statusCode = responseStatusCode; 
>  this.headers = responseHeaders; 
>  this.version = HttpClient.Version.HTTP_1_1; 
>  } 
>  
>  /** 
>  * Provides the response status code 
>  * @return the response status code 
>  */ 
>  public int statusCode() { 
>  return statusCode; 
>  } 
>  
>  /** 
>  * Provides the response headers 
>  * @return the response headers 
>  */ 
>  public HttpHeaders headers() { 
>  return headers; 
>  } 
>  
>  /** 
>  * provides the response protocol version 
>  * @return the response protocol version 
>  */ 
>  public HttpClient.Version version() { 
>  return version; 
>  } 
>  } 
>  
>  @Override 
>  public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; 
>  sendAsync(HttpRequest request, 
>  BodyHandler&lt;T&gt; responseBodyHandler, 
>  PushPromiseHandler&lt;T&gt; pushPromiseHandler) { 
>  List&lt;ByteBuffer&gt; responseBody = List.of(responseBodyBytes.duplicate()); 
>  
>  // Push promises can be mocked too, if needed 
>  
>  Optional&lt;HttpRequest.BodyPublisher&gt; obp = request.bodyPublisher(); 
>  if (obp.isPresent()) { 
>  ConsumingSubscriber subscriber = new ConsumingSubscriber(); 
>  obp.get().subscribe(subscriber); 
>  if (responseBodyBytes == ECHO_SENTINAL) { 
>  responseBody = subscriber.buffers; 
>  } 
>  } 
>  
>  BodySubscriber&lt;T&gt; bodySubscriber = 
>  responseBodyHandler.apply(responseInfo); 
>  SubmissionPublisher&lt;List&lt;ByteBuffer&gt;&gt; publisher = new SubmissionPublisher&lt;&gt;(); 
>  publisher.subscribe(bodySubscriber); 
>  publisher.submit(responseBody); 
>  publisher.close(); 
>  
>  CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; cf = new CompletableFuture&lt;&gt;(); 
>  bodySubscriber.getBody().whenComplete((body, throwable) -&gt; { 
>  if (body != null) 
>  cf.complete(new FixedHttpResponse&lt;&gt;( 
>  responseStatusCode, 
>  request, 
>  responseHeaders, 
>  body, 
>  null, 
>  request.uri(), 
>  request.version().orElse(Version.HTTP_2))); 
>  else 
>  cf.completeExceptionally(throwable); 
>  } 
>  ); 
>  
>  return cf; 
>  } 
>  
>  /** 
>  * A Subscriber that demands and consumes all the Publishers data, 
>  * after which makes it directly available. 
>  */ 
>  private static class ConsumingSubscriber implements Flow.Subscriber&lt;ByteBuffer&gt; { 
>  final List&lt;ByteBuffer&gt; buffers = Collections.synchronizedList(new ArrayList&lt;&gt;()); 
>  
>  @Override 
>  public void onSubscribe(Flow.Subscription subscription) { 
>  subscription.request(Long.MAX_VALUE); 
>  } 
>  
>  @Override public void onNext(ByteBuffer item) { 
>  buffers.add(item.duplicate()); 
>  } 
>  
>  @Override public void onError(Throwable throwable) { assert false : "Unexpected"; } 
>  
>  @Override public void onComplete() { /* do nothing */ } 
>  } 
>  }
> 
> This project is set up using Gradle 7.6 and JDK 19. 
>  Clone the project, then run ./gradlew clean build at the root. 
>  Then you can see some sample generated json strings emitted by tests at the following location: build/reports/tests/test/classes/json.generator.demo.AppTest.html 
>  The report looks like this. 
>  
>  
>  See build.gradle file for how to add the dependency. 
>  You will need to use your GitHub user and a personal access token on your system to build this project. The token is used by build gradle script to download the dependency from github, as documented here regarding Using a published package from GitHub Packages Gradle Registry.
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> transitive
> java.management
> 
> Defines the Java Management Extensions (JMX) API.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> (without comments) canonicalization method algorithm URI.
> 
> javax.xml.crypto.dsig.CanonicalizationMethod.INCLUSIVE_11_WITH_COMMENTS
> 13
> 
> The 
>  Canonical XML 1.1 with comments canonicalization method algorithm
>  URI.
> 
> javax.xml.crypto.dsig.SignatureMethod.ED25519
> 21
> 
> The 
>  ED25519 signature method algorithm URI.
> 
> javax.xml.crypto.dsig.SignatureMethod.ED448
> 21
> 
> The 
>  ED448 signature method algorithm URI.
> 
> javax.xml.crypto.dsig.SignatureMethod.RSA_PSS
> 17
> 
> The
> 
> and a DoubleConsumer, and returns no result.
> 
> java.util.stream.IntStream.IntMapMultiConsumer
> 16
> 
> Represents an operation that accepts an int-valued argument
>  and an IntConsumer, and returns no result.
> 
> java.util.stream.LongStream.LongMapMultiConsumer
> 16
> 
> Represents an operation that accepts a long-valued argument
>  and a LongConsumer, and returns no result.
> 
> javax.crypto.KEMSpi
> 21
> 
> This class defines the Service Provider Interface (SPI) for the KEM
>  class.
> 
> javax.crypto.KEMSpi.DecapsulatorSpi
> 
> Language Updates 
>                                             
>                                             			  Core Libraries 
>                                             
>                                             			  JDK HTTP Client 
>                                             
>                                             			  Java Tutorials
> 
> Language Updates 
>                                             
>                                             			  Core Libraries 
>                                             
>                                             			  JDK HTTP Client 
>                                             
>                                             			  Java Tutorials
> 
> Language Updates 
>                                             
>                                             			  Core Libraries 
>                                             
>                                             			  JDK HTTP Client 
>                                             
>                                             			  Java Tutorials
> 
> Language Updates 
>                                             
>                                             			  Core Libraries 
>                                             
>                                             			  JDK HTTP Client 
>                                             
>                                             			  Java Tutorials
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> A simple HTTP file server and its components (intended for testing,
>  development and debugging purposes only).
> 
> java.lang.constant.ConstantDescs
> 12
> 
> Predefined values of nominal descriptor
>  for common constants, including descriptors for primitive class types and
>  other common platform types, and descriptors for method handles for standard
>  bootstrap methods.
> 
> java.lang.constant.DynamicCallSiteDesc
> 12
> 
> A nominal descriptor for an
>  invokedynamic call site.
> 
> java.lang.constant.DynamicConstantDesc
> 
> java.io.ObjectStreamException(String, Throwable)
> 19
> 
> Create an ObjectStreamException with the specified message and
>  cause.
> 
> java.io.ObjectStreamException(Throwable)
> 19
> 
> Create an ObjectStreamException with the specified cause.
> 
> java.lang.IndexOutOfBoundsException(long)
> 16
> 
> Constructs a new IndexOutOfBoundsException class with an
>  argument indicating the illegal index.
> 
> java.net.ServerSocket(SocketImpl)
> 12
> 
> Creates a server socket with a user-specified SocketImpl.
> 
> Use RoundingMode.UNNECESSARY instead.
> 
> java.math.BigDecimal.ROUND_UP
> 9
> 
> Use RoundingMode.UP instead.
> 
> java.net.HttpURLConnection.HTTP_SERVER_ERROR
> 
> 
> it is misplaced and shouldn't have existed.
> 
> java.rmi.server.RemoteRef.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.rmi.server.ServerRef.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> Requires
> 
> 
> 
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> java.rmi.server.RemoteCall
> 
> 
> no replacement.
> 
> java.rmi.server.ServerRef
> 
> 
> No replacement. This interface is unused and is obsolete.
> 
> java.rmi.server.Skeleton
> 
> 
> no replacement.  Skeletons are no longer required for remote
>  method calls in the Java 2 platform v1.2 and greater.
> 
> java.security.Certificate
> 1.2
> 
> This class is deprecated and subject to removal in a future
>      version of Java SE. It has been replaced by
>      java.security.cert.Certificate and related classes.
> 
> Client Technologies
>                                             
>                                                     
>                                                     
>                                             		
>                                             			  Java Accessibility Guide
> 
> constant pool entries or invokedynamic call sites.
> 
> java.lang.runtime
> 14
> 
> The java.lang.runtime package provides low-level runtime support
>  for the Java language.
> 
> java.util.random
> 17
> 
> This package contains classes and interfaces that support a generic API
>  for random number generation.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Interfaces
> 
> 
> 
> 
> 
> 
> com.sun.net.httpserver.Request
> 18
> 
> A view of the immutable request state of an HTTP exchange.
> 
> com.sun.source.doctree.EscapeTree
> 21
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> ```java
> // src/main/test/java/com/atproto/codegen/TestUtils.java
> // src/test/java/com/atproto/codegen/TestUtils.java
> 
> 
> 
> package com.atproto.codegen;
> 
> 
> 
> import com.atproto.lexicon.models.*;
> 
> 
> 
> import javax.tools.*;
> 
> import java.io.ByteArrayInputStream;
> 
> import java.io.IOException;
> 
> import java.io.InputStream;
> 
> import java.io.OutputStream;
> 
> import java.net.URI;
> 
> import java.net.URISyntaxException;
> 
> import java.nio.CharBuffer;
> 
> import java.nio.charset.StandardCharsets;
> 
> import java.util.*;
> 
> import java.util.stream.Stream;
> 
> 
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> 
> 
> public class TestUtils {
> 
> 
> 
>     public static LexiconDoc createSimpleQueryLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.simpleQuery", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createSimpleQueryLexiconWithDescription() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>()); // Added description
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.simpleQueryWithDescription", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createQueryWithParamsLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> params = new HashMap<>();
> 
>         params.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty()));
> 
>         params.put("p_int", new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
> 
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.paramsQuery", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createProcedureLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         Map<String, LexPrimitive> properties = new HashMap<>();
> 
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
> 
> 
>         LexXrpcBody input = new LexXrpcBody("application/json", Optional.of(new LexObject(
> 
>                 Optional.empty(), Optional.empty(), properties,
> 
>                 new ArrayList<>())), Optional.empty());
> 
> 
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(),
> 
>                 Optional.empty());
> 
> 
> 
>         LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(input), Optional.empty(), Optional.of(output),
> 
>                 new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "procedure", procedure));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.procedure", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createSubscriptionLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         Map<String, LexPrimitive> properties = new HashMap<>(); // Properties, for message
> 
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty())); // Add string property
> 
> 
> 
>         LexXrpcSubscription subscription = new LexXrpcSubscription(Optional.empty(), Optional.empty()); // Declare
> 
>                                                                                                         // subscription
> 
> 
> 
>         defs.add(new LexDefinition("main", "subscription", subscription)); // Add to Definitions.
> 
> 
> 
>         return new LexiconDoc(1, "com.example.subscription", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createMultiMethodLexicon() {  // Multiple Method Lexicon.
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Query
> 
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
> 
>             Optional.empty());   //Create Output
> 
> 
> 
>         LexXrpcQuery query =
> 
>             new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(outputQuery), new ArrayList<>());  //Create Query
> 
>         defs.add(new LexDefinition("queryMethod", "query", query)); //Add Definition
> 
> 
> 
>         // Procedure
> 
>         LexXrpcBody inputProcedure =
> 
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create input
> 
>         LexXrpcBody outputProcedure =
> 
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create output
> 
> 
> 
>         LexXrpcProcedure procedure =
> 
>             new LexXrpcProcedure(Optional.of(inputProcedure), Optional.empty(),
> 
>                 Optional.of(outputProcedure), new ArrayList<>());  //Create Procedure
> 
> 
> 
>         defs.add(new LexDefinition("procedureMethod", "procedure", procedure));   //Add Definition
> 
> 
> 
>         return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
> 
>             defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                 java.util.function.Function.identity))); //Convert Def List to Map
> 
>     }
> 
> 
> 
>     private static LexiconDoc createDuplicateMethodLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
> 
>                 Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(outputQuery), new ArrayList<>());
> 
>         defs.add(new LexDefinition("queryMethod", "query", query));
> 
>         defs.add(new LexDefinition("queryMethod", "query", query)); // Duplicate
> 
> 
> 
>         return new LexiconDoc(1, "com.example.duplicateMethod", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createNestedObjectLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Define the nested object type
> 
>         Map<String, LexPrimitive> nestedProperties = new HashMap<>();
> 
>         nestedProperties.put("innerString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexObject nestedObject = new LexObject(Optional.empty(), Optional.empty(), nestedProperties, new ArrayList<>());
> 
> 
> 
>         // Main query with an object containing the nested object
> 
>         Map<String, LexType> properties = new HashMap<>();
> 
>         properties.put("outerObject", nestedObject);
> 
> 
> 
>         LexXrpcBody output = new LexXrpcBody("application/json",
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), properties, new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(), Optional.of(output),
> 
>                 new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.nestedObject", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithParams(String id, Map<String, ? extends LexType> params) {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, id, Optional.of(0), Optional.empty(), defs.stream().collect(
> 
>                 java.util.stream.Collectors.toMap(LexDefinition::getId, java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithRefUnionParams() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Define the referenced types
> 
>         Map<String, LexPrimitive> recordDef1Props = new HashMap<>();
> 
>         recordDef1Props.put("name1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef1 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef1Props, new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         Map<String, LexPrimitive> recordDef2Props = new HashMap<>();
> 
>         recordDef2Props.put("name2",
> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef2 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef2Props,
> 
>                         new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         defs.add(new LexDefinition("recordDef1", "record", recordDef1));
> 
>         defs.add(new LexDefinition("recordDef2", "record", recordDef2));
> 
> 
> 
>         // Main query with a ref-union parameter
> 
>         Map<String, LexType> params = new HashMap<>();
> 
>         List<String> refs = List.of("#recordDef1", "#recordDef2");
> 
>         params.put("refUnionParam", new LexRefUnion(refs, Optional.empty()));
> 
> 
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.refUnionParams", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithMultipleDefs() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         LexXrpcBody output1 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query1 = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output1), new ArrayList<>());
> 
>         defs.add(new LexDefinition("query1", "query", query1));
> 
> 
> 
>         Map<String, LexPrimitive> params2 = new HashMap<>();
> 
>         params2.put("param1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty()));
> 
>         LexXrpcParameters xrpcParams2 = new LexObject(Optional.of("params"), Optional.empty(), params2,
> 
>                 new ArrayList<>());
> 
> 
> 
>         LexXrpcBody output2 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query2 = new LexXrpcQuery(Optional.of(xrpcParams2), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output2), new ArrayList<>());
> 
>         defs.add(new LexDefinition("query2", "query", query2));
> 
> 
> 
>         Map<String, LexPrimitive> recordProperties = new HashMap<>();
> 
>         recordProperties.put("name", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordProperties, new ArrayList<>())),
> 
>                 Optional.empty());
> 
>         defs.add(new LexDefinition("record1", "record", recordDef));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.multipleDefs", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithoutDefs() {
> 
>         // Create a LexiconDoc without 'defs'. This is invalid.
> 
>         return new LexiconDoc(1, "com.example.invalid", Optional.of(0), Optional.empty(), Map.of());
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithInvalidType() {
> 
>         // Create a LexiconDoc with an invalid parameter type within a query.
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> params = new HashMap<>();
> 
>         // Add an invalid type.
> 
>         params.put("invalidParam", new LexString(Optional.of("invalidtype"), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
> 
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query)); //
> 
> 
> 
>         return new LexiconDoc(1, "com.example.invalidType", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static InputStream stringToInputStream(String str) {
> 
>         return new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8));
> 
>     }
> 
> 
> 
>     public static class InMemoryCompiler {
> 
>         private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
> 
> 
> 
>         public static Class<?> compile(String className, String sourceCode)
> 
>                 throws URISyntaxException, ClassNotFoundException {
> 
>             JavaFileManager fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));
> 
> 
> 
>             List<JavaFileObject> compilationUnits = List.of(
> 
>                     new SourceFileObject(className, sourceCode));
> 
> 
> 
>             // Create a compilation task
> 
>             JavaCompiler.CompilationTask task = compiler.getTask(
> 
>                     null, // No writer, write to memory.
> 
>                     fileManager,
> 
>                     null, // No diagnostics listener
> 
>                     null, // No options
> 
>                     null, // No classes to be processed (for annotation processing)
> 
>                     compilationUnits);
> 
> 
> 
>             // Perform the compilation
> 
>             boolean success = task.call();
> 
> 
> 
>             if (!success) {
> 
>                 // For proper error reporting, we need to collect the diagnostics.
> 
>                 DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector<>();
> 
>                 JavaFileManager fileManager2 = new ClassFileManager(
> 
>                         compiler.getStandardFileManager(diagnostics, null, null));
> 
>                 compiler.getTask(
> 
>                         null, // No writer, write to memory.
> 
>                         fileManager2,
> 
>                         diagnostics,
> 
>                         null, // No options
> 
>                         null, // No classes to be processed
> 
>                         compilationUnits).call(); // Don't check success; we want to see the diagnostics in either case.
> 
> 
> 
>                 StringBuilder errorMsg = new StringBuilder();
> 
>                 errorMsg.append("Compilation failed:\n");
> 
>                 for (Diagnostic<? extends JavaFileObject> diagnostic : diagnostics.getDiagnostics()) {
> 
>                     errorMsg.append(diagnostic.toString()).append("\n");
> 
>                 }
> 
>                 throw new RuntimeException(errorMsg.toString());
> 
>             }
> 
> 
> 
>             // Load the compiled class
> 
>             return fileManager.getClassLoader(null).loadClass(className);
> 
>         }
> 
> 
> 
>         private static class SourceFileObject extends SimpleJavaFileObject {
> 
>             private final String sourceCode;
> 
> 
> 
>             SourceFileObject(String name, String sourceCode) throws URISyntaxException {
> 
>                 super(new URI("string:///" + name.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
> 
>                 this.sourceCode = sourceCode;
> 
>             }
> 
> 
> 
>             @Override
> 
>             public CharSequence getCharContent(boolean ignoreEncodingErrors) {
> 
>                 return CharBuffer.wrap(sourceCode);
> 
>             }
> 
>         }
> 
> 
> 
>         private static class ClassFileObject extends SimpleJavaFileObject {
> 
>             private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
> 
> 
> 
>             ClassFileObject(String name, Kind kind) throws URISyntaxException {
> 
>                 super(new URI("byte:///" + name.replace('.', '/') + kind.extension), kind);
> 
>             }
> 
> 
> 
>             byte[] getBytes() {
> 
>                 return outputStream.toByteArray();
> 
>             }
> 
> 
> 
>             @Override
> 
>             public OutputStream openOutputStream() {
> 
>                 return outputStream;
> 
>             }
> 
>         }
> 
> 
> 
>         private static class ClassFileManager extends ForwardingJavaFileManager<JavaFileManager> {
> 
>             private final Map<String, ClassFileObject> compiledClasses = new HashMap<>();
> 
> 
> 
>             ClassFileManager(JavaFileManager fileManager) {
> 
>                 super(fileManager);
> 
>             }
> 
> 
> 
>             @Override
> 
>             public ClassLoader getClassLoader(Location location) {
> 
>                 return new ClassLoader() {
> 
>                     @Override
> 
>                     protected Class<?> findClass(String name) throws ClassNotFoundException {
> 
>                         ClassFileObject classFile = compiledClasses.get(name);
> 
>                         if (classFile == null) {
> 
>                             throw new ClassNotFoundException(name);
> 
>                         }
> 
>                         byte[] bytes = classFile.getBytes();
> 
>                         return defineClass(name, bytes, 0, bytes.length);
> 
>                     }
> 
>                 };
> 
>             }
> 
> 
> 
>             @Override
> 
>             public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,
> 
>                     FileObject sibling) throws IOException {
> 
>                 try {
> 
>                     ClassFileObject fileObject = new ClassFileObject(className, kind);
> 
>                     compiledClasses.put(className, fileObject); // Store the compiled class
> 
> 
> 
>                     return fileObject;
> 
>                 } catch (URISyntaxException ex) {
> 
>                     throw new RuntimeException(ex);
> 
>                 }
> 
>             }
> 
>         }
> 
> 
> 
>         public static LexiconDoc createLexiconWithStringConstraints() {
> 
>             List<LexDefinition> defs = new ArrayList<>();
> 
>             Map<String, LexPrimitive> params = new HashMap<>();
> 
> 
> 
>             // String with maxLength
> 
>             params.put("maxLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.of(10),
> 
>                     Optional.empty(), Optional.empty()));
> 
> 
> 
>             // String with minLength
> 
>             params.put("minLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                     Optional.of(5), Optional.empty()));
> 
> 
> 
>             // String with const
> 
>             params.put("constString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                     Optional.empty(), Optional.of(List.of("constantValue"))));
> 
> 
> 
>             // String with pattern
> 
>             params.put("patternString", new LexString(Optional.empty(), Optional.of("[a-zA-Z]+"), Optional.empty(),
> 
>                     Optional.empty(), Optional.empty()));
> 
>             // String with enum
> 
> 
> 
>             List<String> enumValues = Arrays.asList("value1", "value2", "value3");
> 
>             params.put("enumString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                     Optional.empty(), Optional.of(enumValues)));
> 
> 
> 
>             LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                     new ArrayList<>());
> 
>             LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>             LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                     Optional.of(output), new ArrayList<>());
> 
>             defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>             return new LexiconDoc(1, "com.example.stringConstraints", Optional.of(0), Optional.empty(),
> 
>                     defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                             java.util.function.Function.identity())));
> 
>         }
> 
> 
> 
>         public static Stream<Arguments> provideLexiconsForStringConstraints() {
> 
>             return Stream.of(
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "maxLengthString", "String", 10, null, null,
> 
>                             null), // maxLength
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "minLengthString", "String", null, 5, null,
> 
>                             null), // minLength
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "constString", "String", null, null,
> 
>                             "constantValue", null), // const value
> 
>                     Arguments.of(createLexiconWithStringConstraints(), "patternString", "String", null, null, null,
> 
>                             "[a-zA-Z]+") // Regex pattern
> 
>             // Arguments.of(createLexiconWithStringConstraints(), "enumString", "String",
> 
>             // null, null, null,enumValues)
> 
>             );
> 
>         }
> 
> 
> 
>     }
> 
> }
> ```
> 
> ClientGeneratorTest.java  Java 21 LTS TestUtils.java Continue your response exactly where you left off:

#### _Assistant_

> ```java
> UPPER_CASE() + " = \"" + constValue + "\";"));
>         }
> 
>         // Regex pattern (using annotation value)
>         if (pattern != null) {
>             Annotation patternAnnotation = paramField.getAnnotation(Pattern.class);
>             assertNotNull(patternAnnotation, "Pattern annotation not found.");
>             assertEquals(pattern, ((Pattern) patternAnnotation).regexp(), "Pattern regexp() value mismatch.");
>         }
> 
>         // Test constraint violations by *attempting* to set bad values.
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
> 
>         // Test maxLength violation
>         if (maxLength != null) {
>             String longString = "a".repeat(maxLength + 1);
>             assertThrows(ConstraintViolationException.class, () -> {
>                 paramField.setAccessible(true);  // Make it accessible.
>                 paramField.set(paramInstance, longString); //Set the parameter, throw if invalid.
>             });
> 
>         }
> 
>         // Test minLength violation
>         if (minLength != null) {
>             String shortString = "a".repeat(minLength - 1);
>             assertThrows(ConstraintViolationException.class, () -> {
>                 paramField.setAccessible(true);  // Make it accessible.
>                 paramField.set(paramInstance, shortString);  //Set the parameter, throw if invalid.
>             });
>         }
> 
>         // Test const violation (we set to the valid, and then an invalid value)
> 
>         if(constValue != null){
>             String validValue = constValue;
>             paramField.setAccessible(true); //Make field accessible.
>             paramField.set(paramInstance, validValue);  //Set GOOD.
>             String invalidValue = validValue + "_INVALID";
> 
>             assertThrows(ConstraintViolationException.class, () -> {
>                  paramField.setAccessible(true);  // Make it accessible.
>                  paramField.set(paramInstance, invalidValue);    //Try set invalid value.
>             });
>         }
> 
>         // Test pattern violation
>         if(pattern != null){
>             //Try setting invalid input.
>             assertThrows(ConstraintViolationException.class, () -> {
>                 paramField.setAccessible(true);  // Make it accessible.
>                 paramField.set(paramInstance, "123");    //Try set invalid numerical value.
>             });
>         }
> 
>     }
> 
>     // Data Providers (Continued)
> 
>     // Parameterized Test for Ref Union Params: Now provides Lexicons, Method Name, and expected Parameter Type.
>     private static Stream<Arguments> provideLexiconsForRefUnionParams() {
>         return Stream.of(
>                 Arguments.of(TestUtils.createLexiconWithRefUnionParams(), "refUnionParams", "java.lang.Object") //Object for now, may be refined
>         );
>     }
> 
> 
> 
>       // Added Invalid Lex Version Test
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForInvalidLexVersions")
>     public void testInvalidLexiconVersion(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
>         ClientGenerator generator = new ClientGenerator();
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc)); // Expect an exception
>     }
> 
>     private static Stream<Arguments> provideLexiconsForInvalidLexVersions() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
>                 Optional.of(output), new ArrayList<>()); // Added description
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return Stream.of(
>                  // lex value of 0 is invalid 
>                 Arguments.of(new LexiconDoc(0, "com.example.invalidVersion", Optional.of(0), Optional.empty(),
>                         defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                                 java.util.function.Function.identity()))), IllegalArgumentException.class) // Invalid Version
> 
>         );
>     }
> 
> 
>     // Added Valid Lex Version test
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForValidLexVersions")
>     public void testValidLexiconVersion(LexiconDoc lexiconDoc) throws Exception {
>         //Valid Lex Version
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         // --- Compilation and Reflection ---
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className,
>                 generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>          // Inject mockXrpcClient
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>     }
> 
>     private static Stream<Arguments> provideLexiconsForValidLexVersions() {
>           List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
>                 Optional.of(output), new ArrayList<>()); // Added description
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return Stream.of(
>                 // lex value of 1
>                 Arguments.of(new LexiconDoc(1, "com.example.validversion", Optional.of(0), Optional.empty(),
>                         defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                                 java.util.function.Function.identity()))))
> 
>         );
>     }
> 
> 
> }
> ```
> 
> ```java
> // src/test/java/com/atproto/codegen/TestUtils.java
> package com.atproto.codegen;
> 
> import com.atproto.lexicon.models.*;
> 
> import javax.tools.*;
> import java.io.ByteArrayInputStream;
> import java.io.IOException;
> import java.io.InputStream;
> import java.io.OutputStream;
> import java.net.URI;
> import java.net.URISyntaxException;
> import java.nio.CharBuffer;
> import java.nio.charset.StandardCharsets;
> import java.util.*;
> import java.util.stream.Stream;
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> public class TestUtils {
> 
>     public static LexiconDoc createSimpleQueryLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
>         return new LexiconDoc(1, "com.example.simpleQuery", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createSimpleQueryLexiconWithDescription() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
>                 Optional.of(output), new ArrayList<>()); // Added description
>         defs.add(new LexDefinition("main", "query", query));
>         return new LexiconDoc(1, "com.example.simpleQueryWithDescription", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createQueryWithParamsLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
>         Map<String, LexPrimitive> params = new HashMap<>();
>         params.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty()));
>         params.put("p_int", new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                 new ArrayList<>());
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                 Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.paramsQuery", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createProcedureLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> properties = new HashMap<>();
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
> 
>         LexXrpcBody input = new LexXrpcBody("application/json", Optional.of(new LexObject(
>                 Optional.empty(), Optional.empty(), properties,
>                 new ArrayList<>())), Optional.empty());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(),
>                 Optional.empty());
> 
>         LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(input), Optional.empty(), Optional.of(output),
>                 new ArrayList<>());
>         defs.add(new LexDefinition("main", "procedure", procedure));
> 
>         return new LexiconDoc(1, "com.example.procedure", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createSubscriptionLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> properties = new HashMap<>(); // Properties, for message
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty())); // Add string property
> 
>         LexXrpcSubscription subscription = new LexXrpcSubscription(Optional.empty(), Optional.empty()); // Declare
>                                                                                                         // subscription
> 
>         defs.add(new LexDefinition("main", "subscription", subscription)); // Add to Definitions.
> 
>         return new LexiconDoc(1, "com.example.subscription", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createMultiMethodLexicon() {  // Multiple Method Lexicon.
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         // Query
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
>             Optional.empty());   //Create Output
> 
>         LexXrpcQuery query =
>             new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.of(outputQuery), new ArrayList<>());  //Create Query
>         defs.add(new LexDefinition("queryMethod", "query", query)); //Add Definition
> 
>         // Procedure
>         LexXrpcBody inputProcedure =
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create input
>         LexXrpcBody outputProcedure =
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create output
> 
>         LexXrpcProcedure procedure =
>             new LexXrpcProcedure(Optional.of(inputProcedure), Optional.empty(),
>                 Optional.of(outputProcedure), new ArrayList<>());  //Create Procedure
> 
>         defs.add(new LexDefinition("procedureMethod", "procedure", procedure));   //Add Definition
> 
>         return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
>             defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                 java.util.function.Function.identity))); //Convert Def List to Map
>     }
> 
>     private static LexiconDoc createDuplicateMethodLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
>                 Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.of(outputQuery), new ArrayList<>());
>         defs.add(new LexDefinition("queryMethod", "query", query));
>         defs.add(new LexDefinition("queryMethod", "query", query)); // Duplicate
> 
>         return new LexiconDoc(1, "com.example.duplicateMethod", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createNestedObjectLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         // Define the nested object type
>         Map<String, LexPrimitive> nestedProperties = new HashMap<>();
>         nestedProperties.put("innerString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
>         LexObject nestedObject = new LexObject(Optional.empty(), Optional.empty(), nestedProperties, new ArrayList<>());
> 
>         // Main query with an object containing the nested object
>         Map<String, LexType> properties = new HashMap<>();
>         properties.put("outerObject", nestedObject);
> 
>         LexXrpcBody output = new LexXrpcBody("application/json",
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), properties, new ArrayList<>())),
>                 Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(), Optional.of(output),
>                 new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.nestedObject", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createLexiconWithParams(String id, Map<String, ? extends LexType> params) {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                 new ArrayList<>());
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                 Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
>         return new LexiconDoc(1, id, Optional.of(0), Optional.empty(), defs.stream().collect(
>                 java.util.stream.Collectors.toMap(LexDefinition::getId, java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createLexiconWithRefUnionParams() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         // Define the referenced types
>         Map<String, LexPrimitive> recordDef1Props = new HashMap<>();
>         recordDef1Props.put("name1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
>         LexRecord recordDef1 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef1Props, new ArrayList<>())),
>                 Optional.empty());
> 
>         Map<String, LexPrimitive> recordDef2Props = new HashMap<>();
>         recordDef2Props.put("name2",
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>         LexRecord recordDef2 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef2Props,
>                         new ArrayList<>())),
>                 Optional.empty());
> 
>         defs.add(new LexDefinition("recordDef1", "record", recordDef1));
>         defs.add(new LexDefinition("recordDef2", "record", recordDef2));
> 
>         // Main query with a ref-union parameter
>         Map<String, LexType> params = new HashMap<>();
>         List<String> refs = List.of("#recordDef1", "#recordDef2

#### _User_

> ```git diff
> diff --git a/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java b/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> index d2c6468..fb911ed 100644
> --- a/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> +++ b/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> @@ -1,5 +1,4 @@
> -// src/test/java/com/atproto/codegen/ClientGeneratorTest.java
> -
> +// src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
>  package com.atproto.codegen;
>  
>  import static org.junit.jupiter.api.Assertions.*;
> @@ -10,6 +9,9 @@ import com.atproto.api.xrpc.XRPCException;
>  import com.atproto.lexicon.models.*;
>  
>  import java.io.IOException;
> +import java.lang.annotation.Annotation;
> +import java.lang.reflect.Field;
> +import java.time.Instant;
>  import java.util.ArrayList;
>  import java.util.HashMap;
>  import java.util.List;
> @@ -17,6 +19,8 @@ import java.util.Map;
>  import java.util.Optional;
>  import java.util.stream.Stream;
>  
> +import javax.validation.constraints.*;
> +
>  import org.junit.jupiter.api.BeforeEach;
>  import org.junit.jupiter.api.Test;
>  import org.junit.jupiter.params.ParameterizedTest;
> @@ -39,34 +43,35 @@ public class ClientGeneratorTest {
>          generator = new ClientGenerator();
>      }
>  
> -
>      @Test
> -    public void testGenerateClientForSimpleQuery() throws Exception { // Added Exception
> -        //Test simple Client
> -        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); //Create Lexicon.
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +    public void testGenerateClientForSimpleQuery() throws Exception {
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();
> +        ClientGenerator generator = new ClientGenerator();
> +        String generatedCode = generator.generateClient(lexiconDoc);
>  
> -        // Basic checks (These are very basic. It should use a Java parser for real validation)
> -        assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class SimpleQueryClient"));  //Has class name
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Returns AtpResponse
> -        assertTrue(generatedCode.contains("simpleQuery(")); // Method name (same as ID)
> +        assertTrue(generatedCode.contains("package com.example;"));
> +        assertTrue(generatedCode.contains("public class SimpleQueryClient"));
> +        assertTrue(generatedCode.contains("public AtpResponse"));
> +        assertTrue(generatedCode.contains("simpleQuery("));
>          assertTrue(generatedCode.contains(
> -            "xrpcClient.sendQuery"));    //Use XRPC. (should we mock for this kind of test?)
> +                "xrpcClient.sendQuery"));
>          assertFalse(generatedCode.contains(
> -            "import com.atproto.api.xrpc.XRPCException;"));    //Doesn't import XRPC
> -
> +                "import com.atproto.api.xrpc.XRPCException;"));
>  
>          // --- Compilation and Reflection ---
> -        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient", generatedCode);
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",
> +                generatedCode);
>          Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
>          java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>          xrpcClientField.setAccessible(true);
>          xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -        //Invoke and check return type.
> +        // Stub the mockXrpcClient to return a successful response
> +        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                .thenReturn(new AtpResponse<>(null, Optional.empty()));
> +
> +        // Invoke and check return type.
>          java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
>          Object result = method.invoke(clientInstance);
>          assertInstanceOf(AtpResponse.class, result);
> @@ -75,116 +80,128 @@ public class ClientGeneratorTest {
>  
>      @Test
>      public void testGenerateClientForQueryWithParams() throws Exception { // Added Exception
> -        //Test params Client
> -        LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon();    //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test params Client
> +        LexiconDoc lexiconDoc = TestUtils.createQueryWithParamsLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Basic checks
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class ParamsQueryClient"));    //Class Name.
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Returns AtpResponse
> +        assertTrue(generatedCode.contains("public class ParamsQueryClient")); // Class Name.
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>          assertTrue(generatedCode.contains(
> -            "paramsQuery(ParamsQueryParams params"));   //Query method with parameters and type
> -        assertTrue(generatedCode.contains("xrpcClient.sendQuery"));  //Use XRPC
> +                "paramsQuery(ParamsQueryParams params")); // Query method with parameters and type
> +        assertTrue(generatedCode.contains("xrpcClient.sendQuery")); // Use XRPC
>  
>          // --- Compilation and Reflection ---
> -        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient", generatedCode);
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ParamsQueryClient",
> +                generatedCode);
>          Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
>          java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>          xrpcClientField.setAccessible(true);
>          xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> +        // Stub
> +        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                .thenReturn(new AtpResponse<>(null, Optional.empty()));
> +
>          Class<?> paramClass = Class.forName("com.example.ParamsQueryParams");
>          Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
>  
> -        //Invoke and check return type
> +        // Invoke and check return type
>          java.lang.reflect.Method method = generatedClientClass.getMethod("paramsQuery", paramClass);
>          Object result = method.invoke(clientInstance, paramInstance); // Pass the parameter instance
>          assertInstanceOf(AtpResponse.class, result);
> -    }
>  
> +    }
>  
>      @Test
>      public void testGenerateClientForProcedure() throws Exception { // Added Exception
> -        //Test Procedure
> -        LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon();   //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test Procedure
> +        LexiconDoc lexiconDoc = TestUtils.createProcedureLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Basic checks
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class ProcedureClient")); //Class name
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Return AtpResponse
> -        assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input"));  //Proper params
> +        assertTrue(generatedCode.contains("public class ProcedureClient")); // Class name
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Return AtpResponse
> +        assertTrue(generatedCode.contains("procedure(ProcedureProcedureInput input")); // Proper params
>          assertTrue(generatedCode.contains(
> -            "xrpcClient.sendProcedure"));  //Check for XRPC call (should be checked in its own test)
> -
> +                "xrpcClient.sendProcedure")); // Check for XRPC call (should be checked in its own test)
>  
>          // --- Compilation and Reflection ---
> -        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient", generatedCode);
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.ProcedureClient",
> +                generatedCode);
>          Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
>          java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>          xrpcClientField.setAccessible(true);
>          xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> +        // Stub
> +        when(mockXrpcClient.sendProcedure(anyString(), any(), any(), any()))
> +                .thenReturn(new AtpResponse<>(null, Optional.empty()));
> +
>          Class<?> inputClass = Class.forName("com.example.ProcedureProcedureInput");
>          Object inputInstance = inputClass.getDeclaredConstructor().newInstance();
>  
> -
>          // Execute and test
> -        java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method signature
> -        Object result = method.invoke(clientInstance, inputInstance);  // Invoke with parameter
> +        java.lang.reflect.Method method = generatedClientClass.getMethod("procedure", inputClass); // Get method
> +                                                                                                   // signature
> +        Object result = method.invoke(clientInstance, inputInstance); // Invoke with parameter
>          assertInstanceOf(AtpResponse.class, result);
>      }
> -      @Test
> +
> +    @Test
>      public void testGenerateClientForSubscription() throws IOException {
> -        //Test Subscription
> -        LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon();    //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();  //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Test Subscription
> +        LexiconDoc lexiconDoc = TestUtils.createSubscriptionLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Basic checks (subscriptions might have a very different structure)
> -        assertTrue(generatedCode.contains("package com.example;"));    //Package name
> +        assertTrue(generatedCode.contains("package com.example;")); // Package name
>          assertTrue(generatedCode.contains(
> -            "public class SubscriptionClient"));    //Class exists (name should automatically be generated from the name)
> -        assertTrue(generatedCode.contains("public void"));  //void return type.
> +                "public class SubscriptionClient")); // Class exists (name should automatically be generated from the
> +                                                     // name)
> +        assertTrue(generatedCode.contains("public void")); // void return type.
>          assertTrue(
> -            generatedCode.contains("subscription(")); //Subscription Method. (name should automatically be generated
> +                generatedCode.contains("subscription(")); // Subscription Method. (name should automatically be
> +                                                          // generated
>          // from the name)
>          assertTrue(generatedCode.contains(
> -            "throw new UnsupportedOperationException"));   //Subscription not implemented
> +                "throw new UnsupportedOperationException")); // Subscription not implemented
>      }
>  
>      @Test
>      public void testGenerateClientWithMultipleMethods() throws IOException {
> -        //Multiple Definitions
> -        LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon();   //Create Lexicon
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator Instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        // Multiple Definitions
> +        LexiconDoc lexiconDoc = TestUtils.createMultiMethodLexicon(); // Create Lexicon
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator Instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          // Check for multiple methods
> -        assertTrue(generatedCode.contains("queryMethod("));    //Query exists
> -        assertTrue(generatedCode.contains("procedureMethod("));    //Procedure Exists
> +        assertTrue(generatedCode.contains("queryMethod(")); // Query exists
> +        assertTrue(generatedCode.contains("procedureMethod(")); // Procedure Exists
>      }
>  
> -
>      // Test for duplicate method names. Should de-dupe
>      @Test
>      public void testGenerateClientWithDuplicateMethods() throws IOException {
>          LexiconDoc lexiconDoc = TestUtils.createDuplicateMethodLexicon();
> -         ClientGenerator generator = new ClientGenerator();
> +        ClientGenerator generator = new ClientGenerator();
>  
> -         String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
> -         // Check for multiple methods
> -         assertEquals(1, countOccurrences(generatedCode, "queryMethod"));    //Query exists
> +        // Check for multiple methods
> +        assertEquals(1, countOccurrences(generatedCode, "queryMethod")); // Query exists
>  
>      }
>  
> -    // Helper Method. (Need to find something more formal; maybe write one of my own)
> +    // Helper Method. (Need to find something more formal; maybe write one of my
> +    // own)
>      public int countOccurrences(String text, String word) {
>  
>          int count = 0; // Initialize a counter variable
> @@ -199,49 +216,63 @@ public class ClientGeneratorTest {
>          return count;
>      }
>  
> +    // Test that XRPC Exception gets thrown.
> +    @Test
> +    public void testXRPCException() throws Exception {
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon();
> +        ClientGenerator generator = new ClientGenerator();
> +        String generatedCode = generator.generateClient(lexiconDoc);
>  
> +        assertTrue(generatedCode.contains("import com.atproto.api.xrpc.XRPCException;"));
>  
> -    //Test that XRPC Exception gets thrown.
> -    @Test
> -    public void testXRPCException() throws IOException {
> -        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); //Create Lexicon. (doesn't really matter which Lexicon
> -        // we make, just need one)
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClient",
> +                generatedCode);
> +        Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> +        xrpcClientField.setAccessible(true);
> +        xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -        assertTrue(generatedCode.contains(
> -            "import com.atproto.api.xrpc.XRPCException;")); // Should import exception
> +        // Stub the mock to throw the exception
> +        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenThrow(new XRPCException(null, null));
> +
> +        java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> +
> +        // Assert that the method call throws the expected exception
> +        assertThrows(XRPCException.class, () -> {
> +            method.invoke(clientInstance);
> +        });
>      }
>  
> -    //Test that AtpResponse gets imported.
> +    // Test that AtpResponse gets imported.
>      @Test
>      public void testAtpResponseType() throws IOException {
> -        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); //Create Lexicon. (doesn't really matter which Lexicon
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexicon(); // Create Lexicon. (doesn't really matter which
> +                                                                      // Lexicon
>          // we make, just need one)
>  
> -        ClientGenerator generator = new ClientGenerator();   //ClientGenerator instance
> -        String generatedCode = generator.generateClient(lexiconDoc); //Generate
> +        ClientGenerator generator = new ClientGenerator(); // ClientGenerator instance
> +        String generatedCode = generator.generateClient(lexiconDoc); // Generate
>  
>          assertTrue(generatedCode.contains(
> -            "import com.atproto.api.AtpResponse;"));        //Should import AtpResponse
> +                "import com.atproto.api.AtpResponse;")); // Should import AtpResponse
>      }
>  
> -
> -
>      // Helper methods for creating Lexicon structures (for test readability)
>      // These would ideally be in a separate test utility class.
>  
>      @ParameterizedTest
>      @MethodSource("provideLexiconsForAllParameterTypes")
> -    public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType) throws Exception { //Added Exception
> +    public void testGenerateClientForVariousParameterTypes(LexiconDoc lexiconDoc, String paramName, String expectedType)
> +            throws Exception { // Added Exception
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>  
>          // General checks (package, class name, etc.)
>          assertTrue(generatedCode.contains("package com.example;"));
>  
> -        // More specific checks based on parameter type.  This is where we use the paramName.
> +        // More specific checks based on parameter type. This is where we use the
> +        // paramName.
>          assertTrue(generatedCode.contains(paramName)); // Very basic, does the parameter exist?
>  
>          // Check that parameter type is correct
> @@ -257,8 +288,7 @@ public class ClientGeneratorTest {
>          xrpcClientField.setAccessible(true);
>          xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -
> -        // Find the method and its return type.  This assumes the method name is "main"
> +        // Find the method and its return type. This assumes the method name is "main"
>          java.lang.reflect.Method method = null;
>          for (java.lang.reflect.Method m : generatedClientClass.getMethods()) {
>              if (m.getName().equals("main")) { // Or whatever the method name is in your generated code
> @@ -271,171 +301,191 @@ public class ClientGeneratorTest {
>          // Get Return Type from Lexicon, create expected type from this
>          String expectedReturnType = "AtpResponse"; // Default
>          if (lexiconDoc.getDefs().get("main") instanceof LexXrpcQuery) {
> -                LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
> -                 if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
> -                   expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
> -                } else {
> -                   expectedReturnType = "AtpResponse<Void>";
> -                }
> +            LexXrpcQuery query = (LexXrpcQuery) lexiconDoc.getDefs().get("main");
> +            if (query.getOutput().isPresent() && query.getOutput().get().getSchema().isPresent()) {
> +                expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) query.getOutput().get()) + ">";
> +            } else {
> +                expectedReturnType = "AtpResponse<Void>";
> +            }
>          } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcProcedure) {
>              LexXrpcProcedure procedure = (LexXrpcProcedure) lexiconDoc.getDefs().get("main");
> -             if (procedure.getOutput().isPresent()&& procedure.getOutput().get().getSchema().isPresent()) {
> -                    expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get()) + ">";
> +            if (procedure.getOutput().isPresent() && procedure.getOutput().get().getSchema().isPresent()) {
> +                expectedReturnType = "AtpResponse<" + getExpectedJavaType((LexXrpcBody) procedure.getOutput().get())
> +                        + ">";
>  
> -             } else {
> +            } else {
>                  expectedReturnType = "AtpResponse<Void>";
> -             }
> +            }
>          } else if (lexiconDoc.getDefs().get("main") instanceof LexXrpcSubscription) {
>              expectedReturnType = "void";
>          }
>  
>          // Now we assert that the return type from code gen is as expected
> -        String actualReturnType = method.getGenericReturnType().getTypeName().replace("java.util.concurrent.CompletableFuture", "AtpResponse");
> +        String actualReturnType = method.getGenericReturnType().getTypeName()
> +                .replace("java.util.concurrent.CompletableFuture", "AtpResponse"); // Simplify for testing
>          assertEquals(expectedReturnType, actualReturnType);
> +
> +        // Stub Mockito for the method call (added)
> +        if (method.getParameterCount() > 0) { // For parameters
> +            when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                    .thenReturn(new AtpResponse<>(null, Optional.empty()));
> +        } else { // No Parameters
> +            when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                    .thenReturn(new AtpResponse<>(null, Optional.empty()));
> +        }
> +
>      }
>  
> -    //Helper function to return expected Java type String from Lexicon definition.
> +    // Helper function to return expected Java type String from Lexicon definition.
>      private String getExpectedJavaType(LexXrpcBody xrpcBody) {
>  
>          if (xrpcBody.getSchema().isEmpty()) {
> -          return "Void";
> +            return "Void";
>          }
>  
>          LexXrpcBody schema = xrpcBody;
>          if (schema.getSchema().get() instanceof LexObject) {
> -            return "Object"; // Placeholder,  replace with generated class name if using nested objects.
> +            return "Object"; // Placeholder, replace with generated class name if using nested objects.
>          } else if (schema.getSchema().get() instanceof LexArray) {
> -             LexArray lexArray = (LexArray) schema.getSchema().get();
> -              // Handle nested arrays
> +            LexArray lexArray = (LexArray) schema.getSchema().get();
> +            // Handle nested arrays
>              return getExpectedArrayType(lexArray);
>          } else if (schema.getSchema().get() instanceof LexPrimitive) {
>              return getExpectedPrimitiveType((LexPrimitive) schema.getSchema().get());
>          } else if (schema.getSchema().get() instanceof LexXrpcBody) {
> -             return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
> -        } else if (schema.getSchema().get() instanceof  LexRef ) {
> -            //Resolve references, including repository refs vs. defs refs.  This is very basic.
> -            LexRef ref = (LexRef)schema.getSchema().get();
> +            return getExpectedJavaType((LexXrpcBody) schema.getSchema().get());
> +        } else if (schema.getSchema().get() instanceof LexRef) {
> +            // Resolve references, including repository refs vs. defs refs. This is very
> +            // basic.
> +            LexRef ref = (LexRef) schema.getSchema().get();
>              String refStr = ref.getRef();
>              if (refStr.startsWith("#")) {
> -                return refStr.substring(refStr.lastIndexOf(".") + 1);  //Local ref
> +                return refStr.substring(refStr.lastIndexOf(".") + 1); // Local ref
>              } else {
> -                return refStr.replace(".", ""); //External ref
> +                return refStr.replace(".", ""); // External ref
>              }
> -        }  else if (schema.getSchema().get() instanceof LexString) {
> +        } else if (schema.getSchema().get() instanceof LexString) {
>              LexString lexString = (LexString) schema.getSchema().get();
>              if (lexString.getFormat().isPresent()) {
> -                if (lexString.getFormat().equals("datetime")) {
> -                   return "java.time.Instant";
> -                } else if (lexString.getFormat().equals("cid")) {
> -                  return   "com.atproto.common.Cid";
> -                }  else if (lexString.getFormat().equals("did")) {
> +                if (lexString.getFormat().get().equals("datetime")) {
> +                    return "java.time.Instant";
> +                } else if (lexString.getFormat().get().equals("cid")) {
> +                    return "com.atproto.common.Cid";
> +                } else if (lexString.getFormat().get().equals("did")) {
>                      return "com.atproto.syntax.Did";
> -                } else if (lexString.getFormat().equals("handle")) {
> -                     return "com.atproto.syntax.Handle";
> -                }  else if (lexString.getFormat().equals("at-uri")) {
> -                    return  "com.atproto.syntax.AtUri";
> -                }  else if (lexString.getFormat().equals("nsid")) {
> -                     return "com.atproto.syntax.Nsid";
> -                }  else if (lexString.getFormat().equals("uri")) {
> +                } else if (lexString.getFormat().get().equals("handle")) {
> +                    return "com.atproto.syntax.Handle";
> +                } else if (lexString.getFormat().get().equals("at-uri")) {
> +                    return "com.atproto.syntax.AtUri";
> +                } else if (lexString.getFormat().get().equals("nsid")) {
> +                    return "com.atproto.syntax.Nsid";
> +                } else if (lexString.getFormat().get().equals("uri")) {
>                      return "java.net.URI";
> -                }   else if (lexString.getFormat().equals("language")) {
> +                } else if (lexString.getFormat().get().equals("language")) {
>                      return "java.util.Locale";
> -                }  else if (lexString.getFormat().equals("uri-reference")) {
> -                    return "java.net.URI";  // Assuming URI for uri-reference
> -                }   else if (lexString.getFormat().equals("uri-template")) {
> -                     return "java.lang.String";  // Assuming String for uri-template (no built-in type)
> -                }   else if (lexString.getFormat().equals("email")) {
> -                     return "java.lang.String";       // Assuming String for email
> -                }   else if (lexString.getFormat().equals("hostname")) {
> -                      return "java.lang.String";       // Assuming String for hostname
> -                }  else if (lexString.getFormat().equals("ipv4")) {
> -                   return "java.net.InetAddress";    // Assuming InetAddress for IPv4
> -                }   else if (lexString.getFormat().equals("ipv6")) {
> -                     return "java.net.InetAddress";    // Assuming InetAddress for IPv6
> +                } else if (lexString.getFormat().get().equals("uri-reference")) {
> +                    return "java.net.URI"; // Assuming URI for uri-reference
> +                } else if (lexString.getFormat().get().equals("uri-template")) {
> +                    return "java.lang.String"; // Assuming String for uri-template (no built-in type)
> +                } else if (lexString.getFormat().get().equals("email")) {
> +                    return "java.lang.String"; // Assuming String for email
> +                } else if (lexString.getFormat().get().equals("hostname")) {
> +                    return "java.lang.String"; // Assuming String for hostname
> +                } else if (lexString.getFormat().get().equals("ipv4")) {
> +                    return "java.net.InetAddress"; // Assuming InetAddress for IPv4
> +                } else if (lexString.getFormat().get().equals("ipv6")) {
> +                    return "java.net.InetAddress"; // Assuming InetAddress for IPv6
>  
>                  }
>              }
> -             return  "String";
> -        } else if (schema.getSchema().get() instanceof LexRefUnion){
> -             return "Object";
> +            return "String";
> +        } else if (schema.getSchema().get() instanceof LexRefUnion) {
> +            return "Object";
>          }
>  
> -       return "Object"; //Unreachable? Error?
> +        return "Object"; // Unreachable? Error?
>      }
> -      private String getExpectedArrayType(LexArray lexArray) {
> -                StringBuilder sb = new StringBuilder();
> +
> +    private String getExpectedArrayType(LexArray lexArray) {
> +        StringBuilder sb = new StringBuilder();
>          sb.append("java.util.List<");
>          LexType itemType = lexArray.getItems();
>  
>          if (itemType instanceof LexPrimitive) {
> -            sb.append(getExpectedPrimitiveType((LexPrimitive)itemType));
> +            sb.append(getExpectedPrimitiveType((LexPrimitive) itemType));
>          } else if (itemType instanceof LexArray) {
>              sb.append(getExpectedArrayType((LexArray) itemType)); // Recurse for nested arrays
>          } else if (itemType instanceof LexRef) {
> -        	//Resolve references
> -        	LexRef ref = (LexRef)itemType;
> +            // Resolve references
> +            LexRef ref = (LexRef) itemType;
>              String refStr = ref.getRef();
>              if (refStr.startsWith("#")) {
> -                sb.append( refStr.substring(refStr.lastIndexOf(".") + 1));
> +                sb.append(refStr.substring(refStr.lastIndexOf(".") + 1));
>              } else {
> -                sb.append( refStr.replace(".", ""));
> +                sb.append(refStr.replace(".", ""));
>              }
>          } else if (itemType instanceof LexRefUnion) {
> -             sb.append("Object"); // No specific type in a refUnion
> -        } else if (itemType instanceof LexObject) { //Nested object not allowed as Array
> +            sb.append("Object"); // No specific type in a refUnion
> +        } else if (itemType instanceof LexObject) { // Nested object not allowed as Array
>              return "Object";
>          }
>  
>          sb.append(">");
>          return sb.toString();
>      }
> +
>      private String getExpectedPrimitiveType(LexPrimitive prim) {
>          if (prim instanceof LexBoolean) {
>              return "Boolean";
>          } else if (prim instanceof LexInteger) {
>              return "Integer";
>          } else if (prim instanceof LexString) {
> -           return "String";
> +            return "String";
>          } else if (prim instanceof LexNumber) {
> -           return "Float";
> +            return "Float";
>          } else if (prim instanceof LexBytes) {
> -           return "byte[]";
> -        }else if (prim instanceof LexUnknown){
> -          return "java.util.Map<String, Object>";
> +            return "byte[]";
> +        } else if (prim instanceof LexUnknown) {
> +            return "java.util.Map<String, Object>";
>          }
>          return "Object"; // Should not happen in valid Lexicon
>      }
>  
>      @Test
> -    public void testGenerateClientForNestedObject() throws Exception { //Added Exception
> +    public void testGenerateClientForNestedObject() throws Exception { // Added Exception
>          LexiconDoc lexiconDoc = TestUtils.createNestedObjectLexicon();
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>  
>          // Basic checks
>          assertTrue(generatedCode.contains("package com.example;")); // Package name
> -        assertTrue(generatedCode.contains("public class NestedObjectClient"));    //Class Name.
> -        assertTrue(generatedCode.contains("public AtpResponse"));    //Returns AtpResponse
> +        assertTrue(generatedCode.contains("public class NestedObjectClient")); // Class Name.
> +        assertTrue(generatedCode.contains("public AtpResponse")); // Returns AtpResponse
>          assertTrue(generatedCode.contains(
> -                "nestedObject("));   //Query method with parameters and type
> +                "nestedObject(")); // Query method with parameters and type
>  
> +        // --- Compilation and Reflection, as before, BUT: ---
> +        // 1. Compile and Get Class:
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient",
> +                generatedCode);
> +        Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
>  
> -       // --- Compilation and Reflection, as before, BUT: ---
> -       // 1.  Compile and Get Class:
> -       Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.NestedObjectClient", generatedCode);
> -       Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> +        // 2. Inject Mock:
> +        java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> +        xrpcClientField.setAccessible(true);
> +        xrpcClientField.set(clientInstance, mockXrpcClient);
>  
> -       // 2. Inject Mock:
> -       java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> -       xrpcClientField.setAccessible(true);
> -       xrpcClientField.set(clientInstance, mockXrpcClient);
> +        // 3. Stub Mockito
> +        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                .thenReturn(new AtpResponse<>(null, Optional.empty()));
>  
> -       // 3.  Get and Invoke Method, Assert Return Type
> -       java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
> -       Object result = method.invoke(clientInstance);
> -       assertInstanceOf(AtpResponse.class, result); // Very basic check
> +        // 4. Get and Invoke Method, Assert Return Type
> +        java.lang.reflect.Method method = generatedClientClass.getMethod("nestedObject");
> +        Object result = method.invoke(clientInstance);
> +        assertInstanceOf(AtpResponse.class, result); // Very basic check
>  
> -        //You could add in more specific checks with Mockito here to check call parameters
> +        // You could add in more specific checks with Mockito here to check call
> +        // parameters
>      }
>  
>      @ParameterizedTest
> @@ -445,36 +495,54 @@ public class ClientGeneratorTest {
>          assertThrows(expectedException, () -> generator.generateClient(lexiconDoc));
>      }
>  
> -
>      @Test
> -    public void  testMultipleDefs() throws IOException{
> +    public void testMultipleDefs() throws IOException {
>          LexiconDoc lexiconDoc = TestUtils.createLexiconWithMultipleDefs();
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>          assertTrue(generatedCode.contains("class Query1Client"));
>          assertTrue(generatedCode.contains("class Query2Client"));
> -        assertTrue(generatedCode.contains("class Record1Record")); //Check for records.
> +        assertTrue(generatedCode.contains("class Record1Record")); // Check for records.
>  
>      }
>  
> -    @Test
> -    public void testGenerateClientForRefUnionParams() throws Exception {    //Added Exception
> -        LexiconDoc lexiconDoc = TestUtils.createLexiconWithRefUnionParams();
> +    @ParameterizedTest // Enhanced to be parameterized
> +    @MethodSource("provideLexiconsForRefUnionParams")
> +    public void testGenerateClientForRefUnionParams(LexiconDoc lexiconDoc, String methodName, String expectedParamType)
> +            throws Exception {
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
>  
>          assertTrue(generatedCode.contains("package com.example;"));
> -        assertTrue(generatedCode.contains("public class RefUnionParamsClient"));
> -        // Check that the generated code includes the expected parameter and return type (adjust as per codegen)
> -        // NOTE: This will likely need changing based on how you generate method signatures.
> -        assertTrue(generatedCode.contains("public AtpResponse refUnionParams(Object params)")); //Object because it could be either one of the Record Types.
> +        String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> +
> +        assertTrue(generatedCode.contains("public class " + className));
> +
> +        // Dynamic method name check
> +        assertTrue(generatedCode.contains("public AtpResponse " + methodName + "(" + expectedParamType + " params)"));
> +
> +        // --- Compilation, Reflection, and Mockito Stubbing ---
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> +        Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> +        Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> +        xrpcClientField.setAccessible(true);
> +        xrpcClientField.set(clientInstance, mockXrpcClient);
> +
> +        // Find the method dynamically
> +        java.lang.reflect.Method method = generatedClientClass.getMethod(methodName, Class.forName(expectedParamType));
> +        assertNotNull(method, "Method '" + methodName + "' not found in generated class");
> +
> +        // Basic stubbing (you'd expand this for specific test cases)
> +        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                .thenReturn(new AtpResponse<>(null, Optional.empty()));
>  
>      }
> -      @Test
> -   public void testJavadocGeneration() throws Exception { //Added Exception
> -       LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
> -       ClientGenerator generator = new ClientGenerator();
> -       String generatedCode = generator.generateClient(lexiconDoc);
> +
> +    @Test
> +    public void testJavadocGeneration() throws Exception { // Added Exception
> +        LexiconDoc lexiconDoc = TestUtils.createSimpleQueryLexiconWithDescription();
> +        ClientGenerator generator = new ClientGenerator();
> +        String generatedCode = generator.generateClient(lexiconDoc);
>  
>          // Basic Javadoc checks
>          assertTrue(generatedCode.contains("/**"));
> @@ -482,17 +550,18 @@ public class ClientGeneratorTest {
>          assertTrue(generatedCode.contains("*/"));
>          assertTrue(generatedCode.contains("public class SimpleQueryClientWithDescription"));
>  
> -       // Compile and load the class, then verify with reflection
> -       Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example.SimpleQueryClientWithDescription", generatedCode);
> +        // Compile and load the class, then verify with reflection
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler
> +                .compile("com.example.SimpleQueryClientWithDescription", generatedCode);
>          java.lang.reflect.Method method = generatedClientClass.getMethod("simpleQuery");
> -        assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more thorough.
> +        assertNotNull(method.getAnnotations(), "Method should have annotations"); // A very basic check. Could be more
> +                                                                                  // thorough.
>  
> +    }
>  
> -   }
> -    
> -   @ParameterizedTest
> -   @MethodSource("provideLexiconsForStringConstraints")
> -   public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
> +    @ParameterizedTest
> +    @MethodSource("provideLexiconsForStringConstraints")
> +    public void testStringConstraints(LexiconDoc lexiconDoc, String paramName, String expectedType,
>              Integer maxLength, Integer minLength, String constValue, String pattern) throws Exception {
>          ClientGenerator generator = new ClientGenerator();
>          String generatedCode = generator.generateClient(lexiconDoc);
> @@ -514,190 +583,170 @@ public class ClientGeneratorTest {
>              }
>          }
>          Class<?> paramClass = method.getParameterTypes()[0];
> -          // Now using reflection
> +        // Now using reflection
>          java.lang.reflect.Field paramField = null;
> -         try {
> -              paramField = paramClass.getDeclaredField(paramName);
> -
> -          } catch (Exception e) {
> -                 failCount++;
> -               fail("parameter not found in parameters of generated class.");
> -          }
> +        try {
> +            paramField = paramClass.getDeclaredField(paramName);
>  
> +        } catch (Exception e) {
>  
> +            fail("parameter not found in parameters of generated class.");
> +        }
>  
>          // maxLength constraint
>          if (maxLength != null) {
> -            assertTrue(generatedCode.contains("@MaxLength(" + maxLength + ")"));
> +            Annotation maxLengthAnnotation = paramField.getAnnotation(MaxLength.class);
> +            assertNotNull(maxLengthAnnotation, "MaxLength annotation not found");
> +            assertEquals(maxLength.intValue(), ((MaxLength) maxLengthAnnotation).value(),
> +                    "MaxLength value mismatch");
>          }
>  
>          // minLength constraint
>          if (minLength != null) {
> -            assertTrue(generatedCode.contains("@MinLength(" + minLength + ")"));
> +            Annotation minLengthAnnotation = paramField.getAnnotation(MinLength.class);
> +            assertNotNull(minLengthAnnotation, "MinLength annotation not found");
> +            assertEquals(minLength.intValue(), ((MinLength) minLengthAnnotation).value(),
> +                    "MinLength value mismatch");
>          }
>  
>          // const constraint
>          if (constValue != null) {
> -            assertTrue(generatedCode.contains("public static final String " + paramName.toUpperCase() + " = \"" + constValue + "\";"));
> -       }
> +            assertTrue(generatedCode
> +                    .contains("public static final String " + paramName.UPPER_CASE() + " = \"" + constValue + "\";"));
> +        }
> +
> +        // Regex pattern (using annotation value)
> +        if (pattern != null) {
> +            Annotation patternAnnotation = paramField.getAnnotation(Pattern.class);
> +            assertNotNull(patternAnnotation, "Pattern annotation not found.");
> +            assertEquals(pattern, ((Pattern) patternAnnotation).regexp(), "Pattern regexp() value mismatch.");
> +        }
> +
> +        // Test constraint violations by *attempting* to set bad values.
> +        Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
> +
> +        // Test maxLength violation
> +        if (maxLength != null) {
> +            String longString = "a".repeat(maxLength + 1);
> +            assertThrows(ConstraintViolationException.class, () -> {
> +                paramField.setAccessible(true); // Make it accessible.
> +                paramField.set(paramInstance, longString); // Set the parameter, throw if invalid.
> +            });
> +
> +        }
> +
> +        // Test minLength violation
> +        if (minLength != null) {
> +            String shortString = "a".repeat(minLength - 1);
> +            assertThrows(ConstraintViolationException.class, () -> {
> +                paramField.setAccessible(true); // Make it accessible.
> +                paramField.set(paramInstance, shortString); // Set the parameter, throw if invalid.
> +            });
> +        }
> +
> +        // Test const violation (we set to the valid, and then an invalid value)
> +
> +        if (constValue != null) {
> +            String validValue = constValue;
> +            paramField.setAccessible(true); // Make field accessible.
> +            paramField.set(paramInstance, validValue); // Set GOOD.
> +            String invalidValue = validValue + "_INVALID";
> +
> +            assertThrows(ConstraintViolationException.class, () -> {
> +                paramField.setAccessible(true); // Make it accessible.
> +                paramField.set(paramInstance, invalidValue); // Try set invalid value.
> +            });
> +        }
> +
> +        // Test pattern violation
> +        if (pattern != null) {
> +            // Try setting invalid input.
> +            assertThrows(ConstraintViolationException.class, () -> {
> +                paramField.setAccessible(true); // Make it accessible.
> +                paramField.set(paramInstance, "123"); // Try set invalid numerical value.
> +            });
> +        }
> +
>      }
>  
> +    // Data Providers (Continued)
> +
> +    // Parameterized Test for Ref Union Params: Now provides Lexicons, Method Name,
> +    // and expected Parameter Type.
> +    private static Stream<Arguments> provideLexiconsForRefUnionParams() {
> +        return Stream.of(
> +                Arguments.of(TestUtils.createLexiconWithRefUnionParams(), "refUnionParams", "java.lang.Object") // Object
> +                                                                                                                // for
> +                                                                                                                // now,
> +                                                                                                                // may
> +                                                                                                                // be
> +                                                                                                                // refined
> +        );
> +    }
>  
> -    // Data Providers
> -    private static Stream<Arguments> provideLexiconsForAllParameterTypes() {
> -        List<Arguments> argList = new ArrayList<>();
> -
> -        // Integer types
> -        Map<String, LexPrimitive> intParams = new HashMap<>();
> -        intParams.put("intParam",
> -                new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.intParams", intParams), "intParam",
> -                "Integer"));
> -
> -        // Number types (float/double) part of LexNumber
> -        Map<String, LexPrimitive> numberParams = new HashMap<>();
> -        numberParams.put("floatParam",
> -                new LexNumber(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.floatParams", numberParams),
> -                "floatParam", "Float")); // Double, double
> -
> -        // String types
> -        Map<String, LexPrimitive> stringParams = new HashMap<>();
> -        stringParams.put("stringParam", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> -                Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.stringParams", stringParams),
> -                "stringParam", "String"));
> -
> -        // Boolean types
> -        Map<String, LexPrimitive> boolParams = new HashMap<>();
> -        boolParams.put("boolParam", new LexBoolean(Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.boolParams", boolParams), "boolParam",
> -                "Boolean"));
> -
> -        // Bytes type
> -        Map<String, LexPrimitive> bytesParams = new HashMap<>();
> -        bytesParams.put("bytesParam",
> -                new LexBytes(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.bytesParams", bytesParams),
> -                "bytesParam", "byte[]"));
> -
> -        // CidLink
> -        Map<String, LexPrimitive> cidLinkParams = new HashMap<>();
> -        cidLinkParams.put("cidLinkParam", new LexCidLink(Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.cidLinkParams", cidLinkParams),
> -                "cidLinkParam", "com.atproto.common.Cid"));
> -
> -        // Array of primitives
> -        Map<String, LexType> arrayParams = new HashMap<>();
> -        arrayParams.put("intArrayParam", new LexArray(
> -                new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()),
> -                Optional.empty(), Optional.empty(), Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.arrayParams", arrayParams),
> -                "intArrayParam", "java.util.List<Integer>"));
> -
> -        // Unknown
> -        Map<String, LexPrimitive> unknownParams = new HashMap<>();
> -        unknownParams.put("unknownParam", new LexUnknown(Optional.empty()));
> -        argList.add(Arguments.of(TestUtils.createLexiconWithParams("com.example.unknownParams", unknownParams),
> -                "unknownParam", "java.util.Map<String, Object>"));
> -
> -        // String Formats.
> -        Map<String, LexPrimitive> stringFormatParams = new HashMap<>();
> -        stringFormatParams.put("atUriParam", new LexString(Optional.of("at-uri"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("cidParam", new LexString(Optional.of("cid"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("didParam", new LexString(Optional.of("did"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("handleParam", new LexString(Optional.of("handle"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("nsidParam", new LexString(Optional.of("nsid"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("datetimeParam", new LexString(Optional.of("datetime"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("languageParam", new LexString(Optional.of("language"),
> -                Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> -        stringFormatParams.put("uriParam", new LexString(Optional.of("uri"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -        stringFormatParams.put("uriRefParam", new LexString(Optional.of("uri-reference"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -        stringFormatParams.put("uriTemplateParam", new LexString(Optional.of("uri-template"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -        stringFormatParams.put("emailParam", new LexString(Optional.of("email"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -        stringFormatParams.put("hostnameParam", new LexString(Optional.of("hostname"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -        stringFormatParams.put("ipv4Param", new LexString(Optional.of("ipv4"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -        stringFormatParams.put("ipv6Param", new LexString(Optional.of("ipv6"),
> -                Optional.empty(), Optional.empty(), Optional.empty(),Optional.empty()));
> -
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "atUriParam", "com.atproto.syntax.AtUri"));
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "cidParam", "com.atproto.common.Cid")); //Assuming you have a Cid class.
> -
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "didParam", "com.atproto.syntax.Did")); //Assuming you have a Did class
> -
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "handleParam", "com.atproto.syntax.Handle")); //Assuming you have a Handle class
> -
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "nsidParam", "com.atproto.syntax.Nsid")); //Assuming you have an NSID class.
> -
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "datetimeParam", "java.time.Instant"));
> -
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "languageParam", "java.util.Locale"));
> -	          argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "uriParam", "java.net.URI"));
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "uriRefParam", "java.net.URI"));  // Assuming URI for uri-reference
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "uriTemplateParam", "java.lang.String"));  // Assuming String for uri-template (no built-in type)
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "emailParam", "java.lang.String"));       // Assuming String for email
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "hostnameParam", "java.lang.String"));      // Assuming String for hostname
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "ipv4Param", "java.net.InetAddress"));    // Assuming InetAddress for IPv4
> -        argList.add(
> -                Arguments.of(TestUtils.createLexiconWithParams("com.example.stringFormatParams", stringFormatParams),
> -                        "ipv6Param", "java.net.InetAddress"));    // Assuming InetAddress for IPv6
> -        return argList.stream();
> +    // Added Invalid Lex Version Test
> +    @ParameterizedTest
> +    @MethodSource("provideLexiconsForInvalidLexVersions")
> +    public void testInvalidLexiconVersion(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
> +        ClientGenerator generator = new ClientGenerator();
> +        assertThrows(expectedException, () -> generator.generateClient(lexiconDoc)); // Expect an exception
>      }
>  
> -    private static Stream<Arguments> provideLexiconsForInvalidLexicons() {
> +    private static Stream<Arguments> provideLexiconsForInvalidLexVersions() {
> +        List<LexDefinition> defs = new ArrayList<>();
> +        LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> +        LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
> +                Optional.of(output), new ArrayList<>()); // Added description
> +        defs.add(new LexDefinition("main", "query", query));
> +
>          return Stream.of(
> -                // Missing 'defs'
> -                Arguments.of(TestUtils.createLexiconWithoutDefs(), IllegalArgumentException.class),
> -                // Invalid type within parameters
> -                Arguments.of(TestUtils.createLexiconWithInvalidType(), IllegalArgumentException.class)
> +                // lex value of 0 is invalid
> +                Arguments.of(new LexiconDoc(0, "com.example.invalidVersion", Optional.of(0), Optional.empty(),
> +                        defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> +                                java.util.function.Function.identity()))),
> +                        IllegalArgumentException.class) // Invalid Version
>  
>          );
> +    }
> +
> +    // Added Valid Lex Version test
> +    @ParameterizedTest
> +    @MethodSource("provideLexiconsForValidLexVersions")
> +    public void testValidLexiconVersion(LexiconDoc lexiconDoc) throws Exception {
> +        // Valid Lex Version
> +        ClientGenerator generator = new ClientGenerator();
> +        String generatedCode = generator.generateClient(lexiconDoc);
> +
> +        // --- Compilation and Reflection ---
> +        String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> +        Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className,
> +                generatedCode);
> +        Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> +
> +        // Inject mockXrpcClient
> +        java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> +        xrpcClientField.setAccessible(true);
> +        xrpcClientField.set(clientInstance, mockXrpcClient);
> +
> +        when(mockXrpcClient.sendQuery(anyString(), any(), any(), any()))
> +                .thenReturn(new AtpResponse<>(null, Optional.empty()));
>  
>      }
> -     private static Stream < Arguments > provideLexiconsForStringConstraints () { 
> -            return Stream . of ( 
> -                Arguments . of ( createLexiconWithStringConstraints (), "maxLengthString" , "String" , 10 , null , null , null ), 
> -                Arguments . of ( createLexiconWithStringConstraints (), "minLengthString" , "String" , null , 5 , null , null ), 
> -                Arguments . of ( createLexiconWithStringConstraints (), "constString" , "String" , null , null , "constantValue" , null ), 
> -                Arguments . of ( createLexiconWithStringConstraints (), "patternString" , "String" , null , null , null , "[a-zA-Z]+" ) 
> -            ); 
> -    } 
> +
> +    private static Stream<Arguments> provideLexiconsForValidLexVersions() {
> +        List<LexDefinition> defs = new ArrayList<>();
> +        LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> +        LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
> +                Optional.of(output), new ArrayList<>()); // Added description
> +        defs.add(new LexDefinition("main", "query", query));
> +
> +        return Stream.of(
> +                // lex value of 1
> +                Arguments.of(new LexiconDoc(1, "com.example.validversion", Optional.of(0), Optional.empty(),
> +                        defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> +                                java.util.function.Function.identity()))))
> +
> +        );
> +    }
> +
>  }
> \ No newline at end of file
> 
> diff --git a/src/main/test/java/com/atproto/codegen/TestUtils.java b/src/main/test/java/com/atproto/codegen/TestUtils.java
> index e19db33..1baeb4b 100644
> --- a/src/main/test/java/com/atproto/codegen/TestUtils.java
> +++ b/src/main/test/java/com/atproto/codegen/TestUtils.java
> @@ -127,7 +127,7 @@ public class TestUtils {
>  
>          return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
>              defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> -                java.util.function.Function.identity"))); //Convert Def List to Map
> +                java.util.function.Function.identity))); //Convert Def List to Map
>      }
>  
>      private static LexiconDoc createDuplicateMethodLexicon() {
> 
> ```
> 
> @@ -4031,9 +4031,6 @@ class SymbolNotFoundError extends ResolveError {
>  super(kind, debugName); 
>  } 
>  
>  // TODO (pretty-diags): tune this and the arguments for the Levenshtein distance better 
>  private final static int SUGGESTION_DISTANCE_THRESHOLD = 5; 
>  
>  @Override 
>  JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind, 
>  DiagnosticPosition pos, 
>  
>  
>  
>  
> @@ -4065,7 +4062,9 @@ JCDiagnostic getDiagnostic(JCDiagnostic.DiagnosticType dkind,
>  final var closestMember = getClosestMember(env, name, typeargtypes, argtypes); 
>  final var closestDistance = closestMember.distance(); 
>  
>  var suggestMember = (closestDistance &lt;= SUGGESTION_DISTANCE_THRESHOLD) ? closestMember.symbol() : null; 
>  // only suggest symbols that are no more than 1/3 of the symbol distance 
>  final var distanceThreshold = Math.max(name.length(), 3) / 3; 
>  var suggestMember = (closestDistance &lt;= distanceThreshold) ? closestMember.symbol() : null; 
>  
>  if (hasLocation) { 
>  var diag = diags.create(dkind, log.currentSource(), pos, 
>  
>  
>  
>  
> @@ -4114,6 +4113,39 @@ private JCDiagnostic getLocationDiag(Symbol location, Type site) {
>  } 
>  } 
>  
>  private ArrayList&lt;Symbol&gt; GetSymbolsInScope(final Env&lt;AttrContext&gt; env) { 
>  final var symbols = new ArrayList&lt;Symbol&gt;(); 
>  Env&lt;AttrContext&gt; env1 = env; 
>  final Predicate&lt;Symbol&gt; nonSynthetic = symbol -&gt; (symbol.flags_field &amp; SYNTHETIC) == 0; 
>  while (env1.outer != null) { 
>  for (final var sym : env1.info.scope.getSymbols(nonSynthetic)) { 
>  symbols.add(sym); 
>  } 
>  
>  // symbols for the enclosing class 
>  for (final var sym : env1.enclClass.sym.members().getSymbols(nonSynthetic)) { 
>  symbols.add(sym); 
>  } 
>  
>  env1 = env1.outer; 
>  } 
>  
>  for (final var sym : syms.predefClass.members().getSymbols(nonSynthetic)) { 
>  symbols.add(sym); 
>  } 
>  
>  for (final var scope : new Scope[] { env.toplevel.namedImportScope, env.toplevel.starImportScope }) { 
>  for (final var sym : scope.getSymbols(nonSynthetic)) { 
>  final var origin = scope.getOrigin(sym); 
>  if (origin != null &amp;&amp; isAccessible(env, origin.owner.type, sym)) { 
>  symbols.add(sym); 
>  } 
>  } 
>  } 
>  
>  return symbols; 
>  } 
>  
>  private SymbolDistance getClosestMember(final Env&lt;AttrContext&gt; env, 
>  final Name name, 
>  final List&lt;Type&gt; typeParameterTypes, 
>  
>  
> @@ -4122,17 +4154,9 @@ private SymbolDistance getClosestMember(final Env&lt;AttrContext&gt; env,
>  Symbol bestSymbol = null; 
>  var bestDistance = Integer.MAX_VALUE; 
>  
>  final var targetName = name.toString(); 
>  
>  // get symbols from the current scope or from the enclosing class 
>  final var checkSymbols = new ArrayList&lt;Symbol&gt;(); 
>  env.info.scope.getSymbols().forEach(checkSymbols::add); 
>  
>  final var enclClass = env.enclClass; 
>  if (enclClass != null) { 
>  enclClass.sym.members().getSymbols().forEach(checkSymbols::add); 
>  } 
>  final var checkSymbols = GetSymbolsInScope(env); 
>  
>  final var targetName = name.toString(); 
>  for (final var symbol : checkSymbols) { 
>  final var tryName = symbol.isConstructor() ? symbol.owner.name.toString() : symbol.name.toString(); 
>  final var dist = Levenshtein.distance(targetName.toLowerCase(), tryName.toLowerCase()); 
>  
>  
> @@ -4146,7 +4170,6 @@ private SymbolDistance getClosestMember(final Env&lt;AttrContext&gt; env,
>  final var symTypeParameters = symType.getTypeArguments(); 
>  final var symArgTypes = symType.getParameterTypes(); 
>  
>  // TODO (pretty-diags) use a distance function for comparison here too 
>  if (types.isSameTypes(symTypeParameters, typeParameterTypes) &amp;&amp; types.isSameTypes(symArgTypes, argTypes)) { 
>  bestSymbol = symbol; 
>  }
> 
> @@ -3635,7 +3635,7 @@ public void visitReference(final JCMemberReference that) {
>  
>  JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol()) 
>  .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT, 
>  that, exprType.tsym , exprType, that.name, argtypes, typeargtypes); 
>  that, localEnv , exprType, that.name, argtypes, typeargtypes); 
>  
>  JCDiagnostic diag = diags.create(log.currentSource(), that, 
>  targetError ? 
>  
>  
>  
>  
> @@ -4435,7 +4435,7 @@ public void visitSelect(JCFieldAccess tree) {
>  sym.name != names._super &amp;&amp; 
>  (sym.kind == VAR || sym.kind == MTH)) { 
>  rs.accessBase(rs.new StaticError(sym), 
>  tree.pos(), site, sym.name, true); 
>  tree.pos(), env, site, sym.name, true); 
>  } 
>  } 
>  } else if (sym.kind != ERR &amp;&amp; 
>  
>  
>  
>  
> @@ -4489,7 +4489,7 @@ private Symbol selectSym(JCFieldAccess tree,
>  case PACKAGE: 
>  return rs.accessBase( 
>  rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind), 
>  pos, location , site, name, true); 
>  pos, env , site, name, true); 
>  case ARRAY: 
>  case CLASS: 
>  if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) { 
>  
>  
> @@ -4504,7 +4504,7 @@ private Symbol selectSym(JCFieldAccess tree,
>  } else { 
>  // We are seeing a plain identifier as selector. 
>  Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind); 
>  sym = rs.accessBase(sym, pos, location , site, name, true); 
>  sym = rs.accessBase(sym, pos, env , site, name, true); 
>  return sym; 
>  } 
>  case WILDCARD: 
>  
>  
> @@ -4526,7 +4526,7 @@ private Symbol selectSym(JCFieldAccess tree,
>  Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ? 
>  rs.new AccessError(env, site, sym) : 
>  sym; 
>  rs.accessBase(sym2, pos, location , site, name, true); 
>  rs.accessBase(sym2, pos, env , site, name, true); 
>  return sym; 
>  } 
>  case ERROR: 
>  
>  
>  
>  
> @@ -4948,7 +4948,7 @@ protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
>  List&lt;Type&gt; argtypes2 = argtypes.map( 
>  rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase)); 
>  JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR, 
>  env.tree, sym , site, sym.name, argtypes2, typeargtypes); 
>  env.tree, env , site, sym.name, argtypes2, typeargtypes); 
>  log.report(errDiag); 
>  return types.createErrorType(site); 
>  }
> 
> Original file line number 
>  Diff line number 
>  Diff line change 
>  
>  
>  
>  
>  
>  
>  
>  
>  @@ -1326,7 +1326,54 @@ 
>  
>  
>  
>  
>  
>  block-4 ( common-db/get-block @@fixture/connection [ :block/uid block-4-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = 2 ( -&gt; parent-block :block/children count))) 
>  
>  
>  
>  
>  
>  ( t/is ( = 0 ( :block/order block-1))) 
>  
>  
>  
>  
>  
>  ( t/is ( = 1 ( :block/order block-4)))))))) 
>  
>  
>  
>  
>  
>  ( t/is ( = 1 ( :block/order block-4))))))) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( t/testing " Replace block refs " 
>  
>  
>  
>  
>  
>  ( let [block-1-uid " block-1-uid " 
>  
>  
>  
>  
>  
>  block-1-text " a " 
>  
>  
>  
>  
>  
>  block-2-uid " block-2-uid " 
>  
>  
>  
>  
>  
>  block-2-text " b " 
>  
>  
>  
>  
>  
>  block-3-uid " block-3-ui " 
>  
>  
>  
>  
>  
>  block-3-text ( str " (( " block-1-uid " )) " ) 
>  
>  
>  
>  
>  
>  block-4-uid " block-4-uid " 
>  
>  
>  
>  
>  
>  block-4-text ( str " (( " block-2-uid " )) " ) 
>  
>  
>  
>  
>  
>  block-5-uid " block-5-uid " 
>  
>  
>  
>  
>  
>  block-5-text ( str " (( " block-1-uid " )) " " test " " (( " block-2-uid " )) " ) 
>  
>  
>  
>  
>  
>  setup-txs [{ :node/title " test page " 
>  
>  
>  
>  
>  
>  :block/uid " page-uid " 
>  
>  
>  
>  
>  
>  :block/children [{ :block/uid block-1-uid 
>  
>  
>  
>  
>  
>  :block/string block-1-text 
>  
>  
>  
>  
>  
>  :block/order 0 
>  
>  
>  
>  
>  
>  :block/children { :block/uid block-2-uid 
>  
>  
>  
>  
>  
>  :block/string block-2-text 
>  
>  
>  
>  
>  
>  :block/order 0 
>  
>  
>  
>  
>  
>  :block/children []}} 
>  
>  
>  
>  
>  
>  { :block/uid block-3-uid 
>  
>  
>  
>  
>  
>  :block/string block-3-text 
>  
>  
>  
>  
>  
>  :block/order 1 
>  
>  
>  
>  
>  
>  :block/children []} 
>  
>  
>  
>  
>  
>  { :block/uid block-4-uid 
>  
>  
>  
>  
>  
>  :block/string block-4-text 
>  
>  
>  
>  
>  
>  :block/order 2 
>  
>  
>  
>  
>  
>  :block/children []} 
>  
>  
>  
>  
>  
>  { :block/uid block-5-uid 
>  
>  
>  
>  
>  
>  :block/string block-5-text 
>  
>  
>  
>  
>  
>  :block/order 3 
>  
>  
>  
>  
>  
>  :block/children []}]}]] 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection setup-txs) 
>  
>  
>  
>  
>  
>  ( let [uids [block-1-uid block-2-uid] 
>  
>  
>  
>  
>  
>  selected-delete-event ( common-events/build-selected-delete-event -1 
>  
>  
>  
>  
>  
>  uids) 
>  
>  
>  
>  
>  
>  selected-delete-txs ( resolver/resolve-event-to-tx @@fixture/connection selected-delete-event)] 
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection selected-delete-txs) 
>  
>  
>  
>  
>  
>  ( let [block-3 ( common-db/get-block @@fixture/connection [ :block/uid block-3-uid]) 
>  
>  
>  
>  
>  
>  block-4 ( common-db/get-block @@fixture/connection [ :block/uid block-4-uid]) 
>  
>  
>  
>  
>  
>  block-5 ( common-db/get-block @@fixture/connection [ :block/uid block-5-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = " a " ( :block/string block-3))) 
>  
>  
>  
>  
>  
>  ( t/is ( = " b " ( :block/string block-4))) 
>  
>  
>  
>  
>  
>  ( t/is ( = " a test b " ( :block/string block-5)))))))) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( t/deftest paste-event-test 
>  
>  
>  
>  
>  
>  
>  
>  
>  @@ -1378,36 +1425,69 @@ 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( t/deftest delete-merge-block 
>  
>  
>  
>  
>  
>  ( let [block-uid " block-uid-2 " 
>  
>  
>  
>  
>  
>  page-uid " page-uid " 
>  
>  
>  
>  
>  
>  value " next " 
>  
>  
>  
>  
>  
>  setup-tx [{ :db/id -1 
>  
>  
>  
>  
>  
>  :node/title " test page " 
>  
>  
>  
>  
>  
>  :block/order 0 
>  
>  
>  
>  
>  
>  :block/uid page-uid 
>  
>  
>  
>  
>  
>  :block/open true 
>  
>  
>  
>  
>  
>  :block/children [{ :db/id -2 
>  
>  
>  
>  
>  
>  :block/uid " block-uid-1 " 
>  
>  
>  
>  
>  
>  :block/string " previous " 
>  
>  
>  
>  
>  
>  :block/open true 
>  
>  
>  
>  
>  
>  :block/order 0 } 
>  
>  
>  
>  
>  
>  { :db/id -3 
>  
>  
>  
>  
>  
>  :block/uid block-uid 
>  
>  
>  
>  
>  
>  :block/string value 
>  
>  
>  
>  
>  
>  :block/order 1 }]}]] 
>  
>  
>  
>  
>  
>  ( t/testing " Deleting and merging blocks " 
>  
>  
>  
>  
>  
>  ( let [block-uid " block-uid-2 " 
>  
>  
>  
>  
>  
>  page-uid " page-uid " 
>  
>  
>  
>  
>  
>  value " next " 
>  
>  
>  
>  
>  
>  setup-tx [{ :db/id -1 
>  
>  
>  
>  
>  
>  :node/title " test page " 
>  
>  
>  
>  
>  
>  :block/order 0 
>  
>  
>  
>  
>  
>  :block/uid page-uid 
>  
>  
>  
>  
>  
>  :block/open true 
>  
>  
>  
>  
>  
>  :block/children [{ :db/id -2 
>  
>  
>  
>  
>  
>  :block/uid " block-uid-1 " 
>  
>  
>  
>  
>  
>  :block/string " previous " 
>  
>  
>  
>  
>  
>  :block/open true 
>  
>  
>  
>  
>  
>  :block/order 0 } 
>  
>  
>  
>  
>  
>  { :db/id -3 
>  
>  
>  
>  
>  
>  :block/uid block-uid 
>  
>  
>  
>  
>  
>  :block/string value 
>  
>  
>  
>  
>  
>  :block/order 1 }]}]] 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection setup-tx) 
>  
>  
>  
>  
>  
>  ( let [{uid :block/uid } ( common-db/get-block @@fixture/connection [ :block/uid page-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = page-uid uid) 
>  
>  
>  
>  
>  
>  " check if setup-tx is added " )) 
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection setup-tx) 
>  
>  
>  
>  
>  
>  ( let [{uid :block/uid } ( common-db/get-block @@fixture/connection [ :block/uid page-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = page-uid uid) 
>  
>  
>  
>  
>  
>  " check if setup-tx is added " )) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( let [delete-merge-block-event ( common-events/build-delete-merge-block-event -1 block-uid value) 
>  
>  
>  
>  
>  
>  delete-merge-block-tx ( resolver/resolve-event-to-tx @@fixture/connection delete-merge-block-event)] 
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection delete-merge-block-tx) 
>  
>  
>  
>  
>  
>  ( let [{children :block/children } ( d/pull @@fixture/connection '[{ :block/children [ :block/string ]}] [ :block/uid page-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = 1 ( count children)) 
>  
>  
>  
>  
>  
>  " check if the second child is deleted " ) 
>  
>  
>  
>  
>  
>  ( t/is ( = " previousnext " ( -&gt; children 
>  
>  
>  
>  
>  
>  first 
>  
>  
>  
>  
>  
>  :block/string )) 
>  
>  
>  
>  
>  
>  " check if the content of the two blocks are merged " ))))) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( t/testing " Replacing block refs " 
>  
>  
>  
>  
>  
>  ( let [page-uid " page-uid " 
>  
>  
>  
>  
>  
>  block-uid-1 " block-uid-1 " 
>  
>  
>  
>  
>  
>  block-str-1 " a " 
>  
>  
>  
>  
>  
>  block-uid-2 " block-uid-2 " 
>  
>  
>  
>  
>  
>  block-str-2 ( str " (( " block-uid-1 " )) " ) 
>  
>  
>  
>  
>  
>  setup-tx [{ :db/id -1 
>  
>  
>  
>  
>  
>  :node/title " test page " 
>  
>  
>  
>  
>  
>  :block/order 0 
>  
>  
>  
>  
>  
>  :block/uid page-uid 
>  
>  
>  
>  
>  
>  :block/children [{ :db/id -2 
>  
>  
>  
>  
>  
>  :block/uid block-uid-1 
>  
>  
>  
>  
>  
>  :block/string block-str-1 
>  
>  
>  
>  
>  
>  :block/order 0 } 
>  
>  
>  
>  
>  
>  { :db/id -3 
>  
>  
>  
>  
>  
>  :block/uid block-uid-2 
>  
>  
>  
>  
>  
>  :block/string block-str-2 
>  
>  
>  
>  
>  
>  :block/order 1 }]}]] 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection setup-tx) 
>  
>  
>  
>  
>  
>  ( let [{uid :block/uid } ( common-db/get-block @@fixture/connection [ :block/uid page-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = page-uid uid) 
>  
>  
>  
>  
>  
>  " check if setup-tx is added " )) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( let [delete-merge-block-event ( common-events/build-delete-merge-block-event -1 block-uid-1 block-str-1) 
>  
>  
>  
>  
>  
>  delete-merge-block-tx ( resolver/resolve-event-to-tx @@fixture/connection delete-merge-block-event)] 
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection delete-merge-block-tx) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( let [delete-merge-block-event ( common-events/build-delete-merge-block-event -1 block-uid value) 
>  
>  
>  
>  
>  
>  delete-merge-block-tx ( resolver/resolve-event-to-tx @@fixture/connection delete-merge-block-event)] 
>  
>  
>  
>  
>  
>  ( d/transact @fixture/connection delete-merge-block-tx) 
>  
>  
>  
>  
>  
>  ( let [{children :block/children } ( d/pull @@fixture/connection '[{ :block/children [ :block/string ]}] [ :block/uid page-uid])] 
>  
>  
>  
>  
>  
>  ( t/is ( = 1 ( count children)) 
>  
>  
>  
>  
>  
>  " check if the second child is deleted " ) 
>  
>  
>  
>  
>  
>  ( t/is ( = " previousnext " ( -&gt; children 
>  
>  
>  
>  
>  
>  first 
>  
>  
>  
>  
>  
>  :block/string )) 
>  
>  
>  
>  
>  
>  " check if the content of the two blocks are merged " ))))) 
>  
>  
>  
>  
>  
>  ( let [{string :block/string } ( common-db/get-block @@fixture/connection [ :block/uid block-uid-2])] 
>  
>  
>  
>  
>  
>  ( t/is ( = " a " string) 
>  
>  
>  
>  
>  
>  " check if the block refs is replaced with text content " ))))))
> 
> @@ -34,28 +34,28 @@ 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> (deftest get-individual-blocks-from-tree-test 
>  
>  
>  
>  
>  
> (let [db (d/empty-db common-db/schema)] 
>  
>  
>  
>  
>  
> (is (= [#:op{:type :page/new, :atomic? true, :args {:title "Welcome"}} 
>  
>  
>  
>  
>  
> #:op{:type :block/new, :atomic? true, :args {:block-uid "block-1", :position {:ref-title "Welcome", :relation :last}}} 
>  
>  
>  
>  
>  
> (is (= [#:op{:type :page/new, :atomic? true, :args {:name "Welcome"}} 
>  
>  
>  
>  
>  
> #:op{:type :block/new, :atomic? true, :args {:block-uid "block-1", :position {:ref-name "Welcome", :relation :last}}} 
>  
>  
>  
>  
>  
> #:op{:type :composite/consequence, 
>  
>  
>  
>  
>  
> :atomic? false, 
>  
>  
>  
>  
>  
> :trigger #:op{:type :block/save}, 
>  
>  
>  
>  
>  
> :consequences 
>  
>  
>  
>  
>  
> [#:op{:type :page/new, :atomic? true, :args {:title "Welcome"}} 
>  
>  
>  
>  
>  
> [#:op{:type :page/new, :atomic? true, :args {:name "Welcome"}} 
>  
>  
>  
>  
>  
> #:op{:type :block/save, :atomic? true, :args {:block-uid "block-1", :string "block with link to [[Welcome]]"}}]}] 
>  
>  
>  
>  
>  
> (bfs/internal-representation-&gt;atomic-ops db tree-with-pages nil))) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> (is (= [#:op{:type :block/new, :atomic? true, :args {:block-uid "eaa4c9435", :position {:ref-title "title", :relation :first}}} 
>  
>  
>  
>  
>  
> (is (= [#:op{:type :block/new, :atomic? true, :args {:block-uid "eaa4c9435", :position {:ref-name "title", :relation :first}}} 
>  
>  
>  
>  
>  
> #:op{:type :block/save, :atomic? true, :args {:block-uid "eaa4c9435", :string "block 1"}} 
>  
>  
>  
>  
>  
> #:op{:type :block/new, :atomic? true, :args {:block-uid "88c9ff662", :position {:ref-uid "eaa4c9435", :relation :last}}} 
>  
>  
>  
>  
>  
> #:op{:type :block/save, :atomic? true, :args {:block-uid "88c9ff662", :string "B1 C1"}} 
>  
>  
>  
>  
>  
> #:op{:type :block/new, :atomic? true, :args {:block-uid "7d11d532f", :position {:ref-uid "88c9ff662", :relation :after}}} 
>  
>  
>  
>  
>  
> #:op{:type :block/save, :atomic? true, :args {:block-uid "7d11d532f", :string "B1 C2"}} 
>  
>  
>  
>  
>  
> #:op{:type :block/new, :atomic? true, :args {:block-uid "db5fa9a43", :position {:ref-uid "7d11d532f", :relation :last}}} 
>  
>  
>  
>  
>  
> #:op{:type :block/save, :atomic? true, :args {:block-uid "db5fa9a43", :string "B1 C2 C1"}}] 
>  
>  
>  
>  
>  
> (bfs/internal-representation-&gt;atomic-ops db tree-without-page {:ref-title "title" :relation :first}))))) 
>  
>  
>  
>  
>  
> (bfs/internal-representation-&gt;atomic-ops db tree-without-page {:ref-name "title" :relation :first}))))) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> (comment 
>  
>  
>  
>  
>  
> (binding [t/*stack-trace-depth* 5] (t/run-tests)) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> (bfs/internal-representation-&gt;atomic-ops (d/empty-db common-db/schema) tree-without-page {:ref-title "title" :relation :first})) 
>  
>  
>  
>  
>  
> (bfs/internal-representation-&gt;atomic-ops (d/empty-db common-db/schema) tree-without-page {:ref-name "title" :relation :first})) 
>  
>  
>  ||||I|||| Skip to content
> Toggle navigation
> Sign up
> * Product
> + Actions
> Automate any workflow
> + Packages
> Host and manage packages
> + Security
> Find and fix vulnerabilities
> + Codespaces
> Instant dev environments
> + Copilot
> Write better code with AI
> + Code review
> Manage code changes
> + Issues
> Plan and track work
> + Discussions
> Collaborate outside of code
> + Explore
> + All features
> + Documentation
> + GitHub Skills
> + Blog
> * Solutions
> + For
> + Enterprise
> + Teams
> + Startups
> + Education
> + By Solution
> + CI/CD & Automation
> + DevOps
> + DevSecOps
> + Case Studies
> + Customer Stories
> + Resources
> * Open Source
> + GitHub Sponsors
> Fund open source developers
> + The ReadME Project
> GitHub community articles
> + Repositories
> + Topics
> + Trending
> + Collections
> * Pricing
> * In this repository All GitHub ↵
> Jump to ↵
> * No suggested jump to results
> * In this repository All GitHub ↵
> Jump to ↵
> * In this organization All GitHub ↵
> Jump to ↵
> * In this repository All GitHub ↵
> Jump to ↵
> Sign in
> Sign up
> {{ message }}
> athensresearch / athens Public
> *
> * Notifications
> * Fork 391
> * Star 6.3k
> * Code
> * Issues 300
> * Pull requests 22
> * Discussions
> * Actions
> * Projects 4
> * Security
> * Insights
> More
> * Code
> * Issues
> * Pull requests
> * Discussions
> * Actions
> * Projects
> * Security
> * Insights
> Permalink
> This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.
> Browse files
> rfct: use name instead of title to identify pages in protocol
> * Loading branch information
> filipesilva committed Nov 10, 2021
> 1 parent ab60f62 commit 9bc0e95a425fc027fa31bb59640ff5babdb8f3ed
> Show file tree
> Hide file tree
> Showing 8 changed files with 108 additions and 57 deletions.
> Split Unified
> * doc/adr
> + doc/adr/0015-adressing.md 0015-adressing.md
> * src/cljc/athens
> + src/cljc/athens/common_db.cljc common_db.cljc
> + common_events
> o src/cljc/athens/common_events/bfs.cljc bfs.cljc
> o graph
> - src/cljc/athens/common_events/graph/atomic.cljc atomic.cljc
> - src/cljc/athens/common_events/graph/ops.cljc ops.cljc
> - src/cljc/athens/common_events/graph/schema.cljc schema.cljc
> o resolver
> - src/cljc/athens/common_events/resolver/atomic.cljc atomic.cljc
> * test/athens
> + test/athens/bfs_test.cljc bfs_test.cljc
> There are no files selected for viewing
> 51 doc/adr/0015-adressing.md
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -0,0 +1,51 @@
> # 15. Addressability
> Date: 2021-11-10
> ## Status
> Accepted.
> ## Context
> We need to address both blocks and pages during protocol operations, both for individual entities and for positional relationships between entities.
> Blocks are uniquely identified by an immutable id, the block-uid.
> This ID will never change once created and is idependent from the block content.
> Pages are uniquely identified by their content, usually referred to as the title.
> Titles are unique but mutable.
> When a title changes, all references to a title also need to change.
> Positional relationships are defined by one of the unique identifiers listed above together with a first/last/before/after relationship.
> Since pages can be referred to by knowing their title content, they are content-addressable.
> This means you can address a page by knowing the page human readable title.
> This allows adding blocks to a page, and referring to a page within a block, by knowing the page name.
> It's not possible to do this with blocks, as you need to know the block uid to reference it.
> Although the identifier for a page is called a title, this does not completely reflect the role as an addressible identifier.
> While developing the protocol operations for pages we naturally hit a tension between the concept of title and how it is a name.
> Creation and deletion operations would reference the title, but rename and move operations would reference the name.
> ## Decision
> The title abstraction is suitable for a page but what really matters is that it is addressed uniquely by a known name.
> This points to a higher level concept where more things can have such names, and things can have more than one name.
> For a page, the title, content, and unique addressable name happen to be the same.
> If a page can be addressed by different names, then the title and content would no longer be the same as the name.
> Blocks cannot be named right now but it sounds like something we could do.
> We will use the more general name instead of just title in the Athens protocol.
> ## Consequences
> Protocol operations for position and page will refer to name instead of title.
> Actually resolutions and code for the frontend and backend can still refer to titles.
> We can expand the use of names via new protocol operations in the future.
> 30 src/cljc/athens/common_db.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -404,29 +404,29 @@
> ( defn compat-position
> " Build a position by coercing incompatible arguments into compatible ones.
> ref-uid to a page will instead use that page's title as ref- title .
> ref-uid to a page will instead use that page's title as ref- name .
> Integer relation will be converted to :first if 0, or :after (with matching ref-uid) if not.
> Warns when coercion was required. "
> [db { :keys [relation ref-uid ref- title ] :as pos}]
> [db { :keys [relation ref-uid ref- name ] :as pos}]
> ( let [[coerced-ref-uid
> coerced-relation] ( when ( integer? relation)
> ( if ( = relation 0 )
> [ nil :first ]
> ( let [parent-uid ( or ref-uid ( get-page-uid db ref- title ))
> ( let [parent-uid ( or ref-uid ( get-page-uid db ref- name ))
> prev-uid ( :block/uid ( nth-child db parent-uid ( dec relation)))]
> ( if prev-uid
> [prev-uid :after ]
> ; ; Can't find the previous block, just put it on last.
> [ nil :last ]))))
> coerced-ref- title ( when ( and ( not ref- title )
> ( not coerced-ref-uid)
> ref-uid)
> ( get-page-title db ref-uid))
> new-pos ( when ( or coerced-ref-uid coerced-relation coerced-ref- title )
> coerced-ref- name ( when ( and ( not ref- name )
> ( not coerced-ref-uid)
> ref-uid)
> ( get-page-title db ref-uid))
> new-pos ( when ( or coerced-ref-uid coerced-relation coerced-ref- name )
> ( merge
> { :relation ( or coerced-relation relation)}
> ( if-let [title' ( or coerced-ref- title ref- title )]
> { :ref- title title'}
> ( if-let [title' ( or coerced-ref- name ref- name )]
> { :ref- name title'}
> { :ref-uid ( or coerced-ref-uid ref-uid)})))]
> ( when new-pos
> @@ -435,17 +435,17 @@
> ( defn validate-position
> [db { :keys [ref-uid ref- title ] :as position}]
> ( let [ref- title ->uid ( get-page-uid db ref- title )
> [db { :keys [ref-uid ref- name ] :as position}]
> ( let [ref- name ->uid ( get-page-uid db ref- name )
> ref-uid->title ( get-page-title db ref-uid)]
> ; ; Fail on error conditions.
> ( when-some [fail-msg ( cond
> ( and ref-uid ref-uid->title)
> " Location ref-uid is a page, location must use ref- title instead. "
> " Location ref-uid is a page, location must use ref- name instead. "
> ; ; TODO: this could be idempotent instead and create the page.
> ( and ref- title ( not ref- title ->uid))
> ( str " Location ref- title does not exist: " ref- title )
> ( and ref- name ( not ref- name ->uid))
> ( str " Location ref- name does not exist: " ref- name )
> ( and ref-uid ( not ( e-by-av db :block/uid ref-uid)))
> ( str " Location ref-uid does not exist: " ref-uid))]
> 2 src/cljc/athens/common_events/bfs.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -63,7 +63,7 @@
> ; ; There's a block before this one that we can add this one after.
> previous-uid { :ref-uid previous-uid :relation :after }
> ; ; There's no previous block, but we can add it to the end of the parent.
> parent-title { :ref- title parent-title :relation :last }
> parent-title { :ref- name parent-title :relation :last }
> parent-uid { :ref-uid parent-uid :relation :last }
> ; ; There's a default place where we can drop blocks, use it.
> default-position default-position
> 20 src/cljc/athens/common_events/graph/atomic.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -14,7 +14,7 @@
> - `block-uid` - `:block/uid` of new block to be created
> - `position` - new blocks position
> - for siblings: `:before` or `:after` together with `ref-uid`
> - for children: `:first`, `:last` together with `ref-uid` or `ref- title ` "
> - for children: `:first`, `:last` together with `ref-uid` or `ref- name ` "
> [block-uid position]
> { :op/type :block/new
> :op/atomic? true
> @@ -58,7 +58,7 @@
> - `block-uid` - `:block/uid` of block to move
> - `position` - new blocks position
> - for siblings: `:before` or `:after` together with `ref-uid`
> - for children: `:first`, `:last` together with `ref-uid` or `ref- title ` "
> - for children: `:first`, `:last` together with `ref-uid` or `ref- name ` "
> [block-uid position]
> { :op/type :block/move
> :op/atomic? true
> @@ -70,11 +70,11 @@
> ( defn make-page-new-op
> " Creates `:page/new` atomic op.
> - ` title ` - Page title page to be created "
> [ title ]
> - ` name ` - Page name to be created "
> [ name ]
> { :op/type :page/new
> :op/atomic? true
> :op/args { : title title }})
> :op/args { : name name }})
> ( defn make-page-rename-op
> @@ -90,8 +90,8 @@
> ( defn make-page-merge-op
> " Creates `:page/merge` atomic op.
> - `from-name` - `:node/title` of page to be merged into `to-name`
> - `to-name` - `:node/title` merge to this page "
> - `from-name` - name of page to be merged into `to-name`
> - `to-name` - name merge to this page "
> [from-name to-name]
> { :op/type :page/merge
> :op/atomic? true
> @@ -101,11 +101,11 @@
> ( defn make-page-remove-op
> " Creates `:page/remove` atomic op.
> - ` page-title ` - `:node/title` of the page to be deleted "
> [ page-title ]
> - ` name ` - name of the page to be deleted "
> [ name ]
> { :op/type :page/remove
> :op/atomic? true
> :op/args { : title page-title }})
> :op/args { : name name }})
> ; ; Shortcut
> 2 src/cljc/athens/common_events/graph/ops.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -14,7 +14,7 @@
> ([_db page-title]
> ( atomic/make-page-new-op page-title))
> ([db page-title block-uid]
> ( let [location ( common-db/compat-position db { :ref- title page-title
> ( let [location ( common-db/compat-position db { :ref- name page-title
> :relation :first })]
> ( if ( common-db/e-by-av db :node/title page-title)
> ( atomic/make-block-new-op block-uid location)
> 6 src/cljc/athens/common_events/graph/schema.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -24,7 +24,7 @@
> ( def child-position
> [ :or
> [ :map
> [ :ref- title string?]
> [ :ref- name string?]
> [ :relation [ :enum
> :first
> :last ]]]
> @@ -98,7 +98,7 @@
> [ :map
> [ :op/args
> [ :map
> [ : title string?]]]])
> [ : name string?]]]])
> ( def op-page-rename
> @@ -121,7 +121,7 @@
> [ :map
> [ :op/args
> [ :map
> [ : title string?]]]])
> [ : name string?]]]])
> ( def atomic-op
> 42 src/cljc/athens/common_events/resolver/atomic.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -20,12 +20,12 @@
> ( let [{ :keys [block-uid
> position]} args
> { :keys [ref-uid
> ref- title
> ref- name
> relation]} position
> _valid-position ( common-db/validate-position db position)
> ref- title ->uid ( common-db/get-page-uid db ref- title )
> ref- name ->uid ( common-db/get-page-uid db ref- name )
> ; ; Pages must be referenced by title but internally we still use uids for them.
> ref-uid ( or ref-uid ref- title ->uid)
> ref-uid ( or ref-uid ref- name ->uid)
> ref-parent? (#{ :first :last } relation)
> ref-block-exists? ( int? ( common-db/e-by-av db :block/uid ref-uid))
> ref-block ( when ref-block-exists?
> @@ -98,13 +98,13 @@
> [db { :op/keys [args]}]
> ( log/debug " atomic-resolver :block/move args: " ( pr-str args))
> ( let [{ :keys [block-uid position]} args
> { :keys [ref-uid ref- title relation]} position
> { :keys [ref-uid ref- name relation]} position
> _valid-position ( common-db/validate-position db position)
> _valid-block-uid ( when ( common-db/get-page-title db block-uid)
> ( throw ( ex-info " Block to be moved is a page, cannot move pages. " args)))
> ref- title ->uid ( common-db/get-page-uid db ref- title )
> ref- name ->uid ( common-db/get-page-uid db ref- name )
> ; ; Pages must be referenced by title but internally we still use uids for them.
> ref-uid ( or ref-uid ref- title ->uid)
> ref-uid ( or ref-uid ref- name ->uid)
> {old-block-order :block/order
> :as moved-block} ( common-db/get-block db [ :block/uid block-uid])
> {old-parent-block-uid :block/uid } ( common-db/get-parent db [ :block/uid block-uid])
> @@ -305,19 +305,19 @@
> ( defmethod resolve-atomic-op-to-tx :page/new
> [db { :op/keys [args]}]
> ( let [{ :keys [ title ]} args
> page-exists? ( common-db/e-by-av db :node/title title )
> page-uid ( or ( -> title dates/title-to-date dates/date-to-day :uid )
> ( utils/gen-block-uid ))
> now ( utils/now-ts )
> page { :node/title title
> :block/uid page-uid
> :block/children []
> :create/time now
> :edit/time now}
> txs ( if page-exists?
> []
> [page])]
> ( let [{ :keys [ name ]} args
> page-exists? ( common-db/e-by-av db :node/title name )
> page-uid ( or ( -> name dates/title-to-date dates/date-to-day :uid )
> ( utils/gen-block-uid ))
> now ( utils/now-ts )
> page { :node/title name
> :block/uid page-uid
> :block/children []
> :create/time now
> :edit/time now}
> txs ( if page-exists?
> []
> [page])]
> txs))
> @@ -365,9 +365,9 @@
> ( defmethod resolve-atomic-op-to-tx :page/remove
> [db { :op/keys [args]}]
> ( let [{page- title :title } args
> ( let [{page- name :name } args
> _ ( log/debug " atomic-resolver: :page/remove: " ( pr-str args))
> page-uid ( common-db/get-page-uid db page- title )
> page-uid ( common-db/get-page-uid db page- name )
> retract-blocks ( common-db/retract-uid-recursively-tx db page-uid)
> delete-linked-refs ( ->> page-uid
> ( vector :block/uid )
> 12 test/athens/bfs_test.cljc
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -34,28 +34,28 @@
> ( deftest get-individual-blocks-from-tree-test
> ( let [db ( d/empty-db common-db/schema)]
> ( is ( = [#:op{ :type :page/new , :atomic? true , :args { : title " Welcome " }}
> #:op{ :type :block/new , :atomic? true , :args { :block-uid " block-1 " , :position { :ref- title " Welcome " , :relation :last }}}
> ( is ( = [#:op{ :type :page/new , :atomic? true , :args { : name " Welcome " }}
> #:op{ :type :block/new , :atomic? true , :args { :block-uid " block-1 " , :position { :ref- name " Welcome " , :relation :last }}}
> #:op{ :type :composite/consequence ,
> :atomic? false ,
> :trigger #:op{ :type :block/save },
> :consequences
> [#:op{ :type :page/new , :atomic? true , :args { : title " Welcome " }}
> [#:op{ :type :page/new , :atomic? true , :args { : name " Welcome " }}
> #:op{ :type :block/save , :atomic? true , :args { :block-uid " block-1 " , :string " block with link to [[Welcome]] " }}]}]
> ( bfs/internal-representation->atomic-ops db tree-with-pages nil )))
> ( is ( = [#:op{ :type :block/new , :atomic? true , :args { :block-uid " eaa4c9435 " , :position { :ref- title " title " , :relation :first }}}
> ( is ( = [#:op{ :type :block/new , :atomic? true , :args { :block-uid " eaa4c9435 " , :position { :ref- name " title " , :relation :first }}}
> #:op{ :type :block/save , :atomic? true , :args { :block-uid " eaa4c9435 " , :string " block 1 " }}
> #:op{ :type :block/new , :atomic? true , :args { :block-uid " 88c9ff662 " , :position { :ref-uid " eaa4c9435 " , :relation :last }}}
> #:op{ :type :block/save , :atomic? true , :args { :block-uid " 88c9ff662 " , :string " B1 C1 " }}
> #:op{ :type :block/new , :atomic? true , :args { :block-uid " 7d11d532f " , :position { :ref-uid " 88c9ff662 " , :relation :after }}}
> #:op{ :type :block/save , :atomic? true , :args { :block-uid " 7d11d532f " , :string " B1 C2 " }}
> #:op{ :type :block/new , :atomic? true , :args { :block-uid " db5fa9a43 " , :position { :ref-uid " 7d11d532f " , :relation :last }}}
> #:op{ :type :block/save , :atomic? true , :args { :block-uid " db5fa9a43 " , :string " B1 C2 C1 " }}]
> ( bfs/internal-representation->atomic-ops db tree-without-page { :ref- title " title " :relation :first })))))
> ( bfs/internal-representation->atomic-ops db tree-without-page { :ref- name " title " :relation :first })))))
> ( comment
> ( binding [t/*stack-trace-depth* 5 ] ( t/run-tests ))
> ( bfs/internal-representation->atomic-ops ( d/empty-db common-db/schema) tree-without-page { :ref- title " title " :relation :first }))
> ( bfs/internal-representation->atomic-ops ( d/empty-db common-db/schema) tree-without-page { :ref- name " title " :relation :first }))
> 0 comments on commit 9bc0e95
> Please sign in to comment.
> Footer
> © 2023 GitHub, Inc.
> Footer navigation
> * Terms
> * Privacy
> * Security
> * Status
> * Docs
> * Contact GitHub
> * Pricing
> * API
> * Training
> * Blog
> * About
> You can’t perform that action at this time.
> You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  Explore 
>  
>  
> All features
>  
>  
>  
> Documentation
>  
>  
>  
> GitHub Skills
>  
>  
>  
> Blog
>  
>  
>  
>  
>  
>  
>  
>  
>  For 
>  
>  
> Enterprise
>  
>  
>  
> Teams
>  
>  
>  
> Startups
>  
>  
>  
> Education
>  
>  
>  
>  
>  By Solution 
>  
>  
> CI/CD &amp; Automation
>  
>  
>  
> DevOps
>  
>  
>  
> DevSecOps
>  
>  
>  
>  
>  Resources 
>  
>  
> Learning Pathways
>  
>  
>  
> White papers, Ebooks, Webinars
>  
>  
>  
> Customer Stories
>  
>  
>  
> Partners
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  Repositories 
>  
>  
> Topics
>  
>  
>  
> Trending
>  
>  
>  
> Collections
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  Available add-ons 
>  
>  
>  
>  Advanced Security 
> Enterprise-grade security features
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Enterprise-grade AI features
>  
>  
>  
>  
>  
>  Premium Support 
> Enterprise-grade 24/7 support
>  
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
> Sign up
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> kythe
>  
>  / 
>  
>  kythe 
>  
>  Public 
>  
>  
>  
>  
>  Notifications
>  
>  
>  
>  Fork
>  243 
>  
>  
>  
>  
>  
> Star
>  1.9k 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Code 
>  
>  
>  
>  
>  Issues 
>  229 
>  
>  
>  
>  Pull requests 
>  7 
>  
>  
>  
>  Actions 
>  
>  
>  
>  
>  Security 
>  
>  
>  
>  Insights
> 
> dholms 
> changed the title
>  
>  
>  
>  dholms 
> marked this pull request as ready for review
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Choose a reason for hiding this comment 
>  
> The reason will be displayed to describe this comment to others. Learn more .
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Choose a reason for hiding this comment 
>  
> The reason will be displayed to describe this comment to others. Learn more .
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * refactor pds tests to use dev env
> * refactor bsky tests
> * fix pds test
> * tidy bsky tests 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * switch takedown ids back to ints, consistent with live pds
> * tidy/fix migration
> * update migration for sqlite 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  edavis 
> added a commit
> to edavis/pds
> that referenced
> this pull request
>  
>  
>  
>  
>  
>  
>  
>  
>  mloar 
> pushed a commit
> to mloar/atproto
> that referenced
> this pull request
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  * rm tables
> * rm event-stream &amp; proxied
> * Remove appview services, move label service to pds
> * only proxy appview stuff
> * delete more tables
> * Start removing message dispatched from pds
> * more syncing-up removal of message dispatcher in pds
> * merged
> * remove feedgens from pds, remove getPopular
> * remove unused image helper from pds
> * fixing compiler errors
> * clean up sharp
> * rm label service
> * first pass on cleaning up tests
> * fix up a bunch of tests
> * moderation view tests
> * last admin tests
> * got a lil overzealous in deletes
> * clean up unused cfg
> * clean up label table
> * simplify admin repo search query/logic
> * tidy pds entrypoint
> * in-progress pds config changes
> * cfg fiddling
> * finish cleaning up cfg/ctx
> * comments
> * building
> * pds prefix on env
> * test env
> * collapse pds migrations down into a single migration
> * fix up dev-env
> * tidy
> * cleanup
> * fix pds admin tests
> * fix handle test
> * fix pds proxy tests
> * fix subscribe repos test
> * fix sqlite config in pds tests
> * add sqlite clause in sequencer-leader
> * fix actor search w/ sqlite on pds
> * fixes
> * fix dev env build
> * update pds service entrypoint
> * simple env example
> * make takedown ids opaque identifiers in the pds
> * use pds routes for api tests
> * update pds dockerfile with volume and correct port env var
> * add a couple env vars to example
> * add comments to env example
> * @atproto/pds 0.2.0-beta.0
> * @atproto/aws 0.0.1-beta.0
> * appview did
> * @atproto/aws 0.0.1
> * enable logs by default
> * update env example
> * bugfixing sandbox issues
> * consistency in pds env var name for appview url
> * log on pds start and stop, configure version at runtime
> * @atproto/pds 0.2.0-beta.1
> * fix semver matching for pds beta version
> * v0.2.0-beta.2
> * default invites to being not required
> * fix flaky test
> * limit db connections in tests
> * publish 0.2.0-beta.d3
> * fix invite required parsing
> * @atproto/pds 0.2.0-beta.5
> * Proxy getPopularFeedGenerators on simplified pds ( bluesky-social#1222 )
> proxy getPopularFeedGenerators on pds
> Co-authored-by: dholms &lt;dtholmgren@gmail.com&gt;
> * tidy migrations
> * fix service entry
> * bump version
> * change auth order
> * bump version
> * bump version
> * add upgradeRepoVersion &amp; fallback url for cdn
> * bump version
> * merging
> * merge pds
> * building dev-env
> * merging tests
> * merge service entry
> * test fixing
> * tidy
> * fix admin search
> * tidy
> * tidy
> * add snap for getListFeed
> * add backup nameserver cfg
> * tidy + pr feedback
> * tidy
> * tidy env
> * bit more
> * re-add dotenv to root package.json
> * fix dep
> * build branch
> * fix tests
> * Refactor tests to make better use of dev-env ( bluesky-social#1690 )
> * refactor pds tests to use dev env
> * refactor bsky tests
> * fix pds test
> * tidy bsky tests
> * build pds correctly
> * fix entry point
> * default logging to false (for now)
> * format service entry
> * Switch takedown ids back to ints on pds distribution ( bluesky-social#1694 )
> * switch takedown ids back to ints, consistent with live pds
> * tidy/fix migration
> * update migration for sqlite
> * export moderation action reversal
> * takedown tests
> * dont build branch
> ---------
> Co-authored-by: Devin Ivy &lt;devinivy@gmail.com&gt;
> 
> Original file line number 
>  Diff line number 
>  Diff line change 
>  
>  
>  
>  
>  
>  
>  @@ -1,67 +1,68 @@ 
>  
>  
>  
>  
>  
>  import { PineconeStore } from "langchain/vectorstores " ; 
>  
>  
>  
>  
>  
>  import { OpenAIEmbeddings } from "langchain/embeddings" ; 
>  
>  
>  
>  
>  
>  import { PineconeStore } from "langchain/vectorstores /pinecone" 
>  
>  
>  
>  
>  
>  import { OpenAIEmbeddings } from "langchain/embeddings /openai " ; 
>  
>  
>  
>  
>  
>  import { PineconeClient } from "@pinecone-database/pinecone" ; 
>  
>  
>  
>  
>  
>  import { VectorDBQAChain } from "langchain/chains" ; 
>  
>  
>  
>  
>  
>  import { OpenAIChat } from "langchain/ llms " ; 
>  
>  
>  
>  
>  
>  import { ChatOpenAI } from "langchain/ chat_models/openai " ; 
>  
>  
>  
>  
>  
>  import { CallbackManager } from "langchain/callbacks" ; 
>  
>  
>  
>  
>  
>  import type { NextApiRequest , NextApiResponse } from "next" ; 
>  
>  
>  
>  
>  
>  import { NextRequest , NextResponse } from "next/server" ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  export const config = { 
>  
>  
>  
>  
>  
>  runtime : "edge" 
>  
>  
>  
>  
>  
>  } ; 
>  
>  
>  
>  
>  
>  export default async function handler ( req : NextRequest ) 
>  
>  
>  
>  
>  
>  { 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  export default async function handler ( 
>  
>  
>  
>  
>  
>  req : NextApiRequest , 
>  
>  
>  
>  
>  
>  res : NextApiResponse 
>  
>  
>  
>  
>  
>  ) { 
>  
>  
>  
>  
>  
>  // Inputs 
>  
>  
>  
>  
>  
>  const prompt = req . body . prompt ; 
>  
>  
>  
>  
>  
>  const { prompt } = ( await req . json ( ) ) as { prompt : string ; } ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  // Vector DB 
>  
>  
>  
>  
>  
>  const pinecone = new PineconeClient ( ) ; 
>  
>  
>  
>  
>  
>  await pinecone . init ( { 
>  
>  
>  
>  
>  
>  environment : "us-east1-gcp" , 
>  
>  
>  
>  
>  
>  apiKey : process . env . PINECONE_API_KEY ?? "" , 
>  
>  
>  
>  
>  
>  } ) ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  const index = pinecone . Index ( "lex-gpt" ) ; 
>  
>  
>  
>  
>  
>  const vectorStore = await PineconeStore . fromExistingIndex ( 
>  
>  
>  
>  
>  
>  new OpenAIEmbeddings ( ) , { pineconeIndex : index } , 
>  
>  
>  
>  
>  
>  ) ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  // Send data in SSE stream 
>  
>  
>  
>  
>  
>  res . writeHead ( 200 , { 
>  
>  
>  
>  
>  
>  "Content-Type" : "text/event-stream" , 
>  
>  
>  
>  
>  
>  "Cache-Control" : "no-cache, no-transform" , 
>  
>  
>  
>  
>  
>  Connection : "keep-alive" , 
>  
>  
>  
>  
>  
>  } ) ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  const sendData = ( data : string ) =&gt; { 
>  
>  
>  
>  
>  
>  if ( res . writableEnded ) { 
>  
>  
>  
>  
>  
>  console . log ( "Response has already ended, cannot write more data" ) ; 
>  
>  
>  
>  
>  
>  return ; 
>  
>  
>  
>  
>  
>  } 
>  
>  
>  
>  
>  
>  res . write ( `data: ${ data } \n\n` ) ; 
>  
>  
>  
>  
>  
>  } ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  // Call LLM and stream output 
>  
>  
>  
>  
>  
>  const model = new OpenAIChat ( { temperature : 0.0 , 
>  
>  
>  
>  
>  
>  streaming : true , 
>  
>  
>  
>  
>  
>  callbackManager : CallbackManager . fromHandlers ( { 
>  
>  
>  
>  
>  
>  async handleLLMNewToken ( token ) { 
>  
>  
>  
>  
>  
>  sendData ( JSON . stringify ( { data : token . replace ( / ["'\n\r] / g , '' ) } ) ) ; 
>  
>  
>  
>  
>  
>  } , 
>  
>  
>  
>  
>  
>  } ) , 
>  
>  
>  
>  
>  
>  } 
>  
>  
>  
>  
>  
>  ) ; 
>  
>  
>  
>  
>  
>  const encoder = new TextEncoder ( ) ; 
>  
>  
>  
>  
>  
>  const stream = new TransformStream ( ) ; 
>  
>  
>  
>  
>  
>  const writer = stream . writable . getWriter ( ) ; 
>  
>  
>  
>  
>  
>  const llm = new ChatOpenAI ( { 
>  
>  
>  
>  
>  
>  temperature : 0.0 , 
>  
>  
>  
>  
>  
>  streaming : true , 
>  
>  
>  
>  
>  
>  callbackManager : CallbackManager . fromHandlers ( { 
>  
>  
>  
>  
>  
>  handleLLMNewToken : async ( token ) =&gt; { 
>  
>  
>  
>  
>  
>  await writer . ready ; 
>  
>  
>  
>  
>  
>  await writer . write ( encoder . encode ( `data: ${ token . replace ( / ["'\n\r] / g , '' ) } \n\n` ) ) ; 
>  
>  
>  
>  
>  
>  } , 
>  
>  
>  
>  
>  
>  handleLLMEnd : async ( ) =&gt; { 
>  
>  
>  
>  
>  
>  await writer . ready ; 
>  
>  
>  
>  
>  
>  await writer . close ( ) ; 
>  
>  
>  
>  
>  
>  } , 
>  
>  
>  
>  
>  
>  handleLLMError : async ( e ) =&gt; { 
>  
>  
>  
>  
>  
>  await writer . ready ; 
>  
>  
>  
>  
>  
>  await writer . abort ( e ) ; 
>  
>  
>  
>  
>  
>  } , 
>  
>  
>  
>  
>  
>  } ) , 
>  
>  
>  
>  
>  
>  } ) ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  const chain = VectorDBQAChain . fromLLM ( model , vectorStore ) ; 
>  
>  
>  
>  
>  
>  const chain = VectorDBQAChain . fromLLM ( llm , vectorStore ) ; 
>  
>  
>  
>  
>  
>  chain . returnSourceDocuments = false ; 
>  
>  
>  
>  
>  
>  chain . k = 4 ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  try { 
>  
>  
>  
>  
>  
>  await chain . call ( { 
>  
>  
>  
>  
>  
>  query : prompt , 
>  
>  
>  
>  
>  
>  } ) ; 
>  
>  
>  
>  
>  
>  } catch ( err ) { 
>  
>  
>  
>  
>  
>  console . error ( err ) ; 
>  
>  
>  
>  
>  
>  } finally { 
>  
>  
>  
>  
>  
>  sendData ( JSON . stringify ( { data : "DONE" } ) ) ; 
>  
>  
>  
>  
>  
>  res . end ( ) ; 
>  
>  
>  
>  
>  
>  } 
>  
>  
>  
>  
>  
>  } 
>  
>  
>  
>  
>  
>  
>  
>  
>  chain . call ( { 
>  
>  
>  
>  
>  
>  query : prompt , 
>  
>  
>  
>  
>  
>  } ) . catch ( console . error ) ; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  return new NextResponse ( stream . readable , { 
>  
>  
>  
>  
>  
>  headers : { 
>  
>  
>  
>  
>  
>  "Content-Type" : "text/event-stream" , 
>  
>  
>  
>  
>  
>  "Cache-Control" : "no-cache" , 
>  
>  
>  
>  
>  
>  } , 
>  
>  
>  
>  
>  
>  } ) ; 
>  
>  
>  
>  
>  
>  }
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  Explore 
>  
>  
> All features
>  
>  
>  
> Documentation
>  
>  
>  
> GitHub Skills
>  
>  
>  
> Blog
>  
>  
>  
>  
>  
>  
>  
>  
>  For 
>  
>  
> Enterprise
>  
>  
>  
> Teams
>  
>  
>  
> Startups
>  
>  
>  
> Education
>  
>  
>  
>  
>  By Solution 
>  
>  
> CI/CD &amp; Automation
>  
>  
>  
> DevOps
>  
>  
>  
> DevSecOps
>  
>  
>  
>  
>  Resources 
>  
>  
> Learning Pathways
>  
>  
>  
> White papers, Ebooks, Webinars
>  
>  
>  
> Customer Stories
>  
>  
>  
> Partners
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  Repositories 
>  
>  
> Topics
>  
>  
>  
> Trending
>  
>  
>  
> Collections
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  Available add-ons 
>  
>  
>  
>  Advanced Security 
> Enterprise-grade security features
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Enterprise-grade AI features
>  
>  
>  
>  
>  
>  Premium Support 
> Enterprise-grade 24/7 support
>  
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
>  
> Sign in
>  
>  
>  
> Sign up
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> athensresearch
>  
>  / 
>  
>  athens 
>  
>  Public 
>  
>  
>  
>  
>  
>  
>  Notifications
>  
>  
>  
>  Fork
>  395 
>  
>  
>  
>  
>  
> Star
>  6.3k 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Code 
>  
>  
>  
>  
>  Issues 
>  295 
>  
>  
>  
>  Pull requests 
>  22 
>  
>  
>  
>  Discussions 
>  
>  
>  
>  
>  Actions 
>  
>  
>  
>  
>  Projects 
>  4 
>  
>  
>  
>  Security 
>  
>  
>  
>  Insights
> 
> @@ -389,7 +389,8 @@
>  [jepsen.generator.context :as context] 
>  [potemkin :refer [import-vars]] 
>  [slingshot.slingshot :refer [try+ throw+]]) 
>  ( :import ( io.lacuna.bifurcan Set))) 
>  ( :import ( io.lacuna.bifurcan Set) 
>  ( java.util ArrayList))) 
>  
>  ; ; These used to be a part of jepsen.generator directly, and it makes sense for 
>  ; ; users to interact with them here. For cleanliness, they actually live in 
>  
>  
>  
>  
> @@ -485,22 +486,54 @@
>  
>  ; ; Generators! 
>  
>  ( defn tracking-get! 
>  " Takes an ArrayList, a map, a key, and a not-found value. Reads key from 
>  map, returning it or not-found. Adds the key to the list if it was in the 
>  map. Yourkit led me down this path. " 
>  [^ArrayList read-keys m k not-found] 
>  ( let [v ( get m k ::not-found )] 
>  ( if ( identical? v ::not-found ) 
>  not-found 
>  ( do ( .add read-keys k) 
>  v)))) 
>  
>  ( defn fill-in-op 
>  " Takes an operation and fills in missing fields for :type, :process, and 
>  :time using context. Returns :pending if no process is free. Turns maps into 
>  history Ops. " 
>  " Takes an operation as a map and fills in missing fields for :type, :process, 
>  and :time using context. Returns :pending if no process is free. Turns maps 
>  into history Ops. " 
>  [op ctx] 
>  ; This will be both inefficient and wrong for Ops, but users shouldn't 
>  ; actually be passing those to us here. 
>  ( assert ( not ( instance? jepsen.history.Op op))) 
>  ( if-let [p ( some-free-process ctx)] 
>  ; Automatically assign type, time, and process from the context, if not 
>  ; provided. 
>  ( jepsen.history.Op. -1 ; Index 
>  ( :time op ( :time ctx)) 
>  ( :type op :invoke ) 
>  ( :process op p) 
>  ( :f op) 
>  ( :value op) 
>  nil 
>  ( dissoc op :index :time :type :process :f :value )) 
>  ( let [ ; We want to avoid using dissoc if we can POSSIBLY avoid it, so we 
>  ; keep track of the fields we've read from the op. 
>  read-keys ( ArrayList. 5 ) 
>  time ( tracking-get! read-keys op :time ( :time ctx)) 
>  type ( tracking-get! read-keys op :type :invoke ) 
>  process ( tracking-get! read-keys op :process p) 
>  f ( tracking-get! read-keys op :f nil ) 
>  value ( tracking-get! read-keys op :value nil ) 
>  read-count ( .size read-keys) 
>  ; Any other fields? 
>  ext ( if ( &lt; read-count ( count op)) 
>  ; There's fields in the map we didn't read. Pull out the 
>  ; keys we DID read 
>  ( loop [i 0 , ext op] 
>  ( if ( = read-count i) 
>  op 
>  ( recur ( inc i) ( dissoc op ( .get read-keys i))))) 
>  nil )] 
>  ( jepsen.history.Op. -1 ; Index 
>  time 
>  type 
>  process 
>  f 
>  value 
>  nil ; meta 
>  ext)) 
>  :pending )) 
>  
>  ( defrecord Fn 
>  
>  
>  
>  
> @@ -871,28 +904,30 @@
>  Why is this nondeterministic? Because we use this function to decide between 
>  several alternative generators, and always biasing towards an earlier or 
>  later generator could lead to starving some threads or generators. " 
>  [m1 m2] 
>  ( condp = nil 
>  m1 m2 
>  m2 m1 
>  ( let [op1 ( :op m1) 
>  op2 ( :op m2)] 
>  ( condp = :pending 
>  op1 m2 
>  op2 m1 
>  ( let [t1 ( :time op1) 
>  t2 ( :time op2)] 
>  ( if ( = t1 t2) 
>  ; We have a tie; decide based on weights. 
>  ( let [w1 ( :weight m1 1 ) 
>  w2 ( :weight m2 1 ) 
>  w ( + w1 w2)] 
>  ( assoc ( if ( &lt; ( rand-int w) w1) m1 m2) 
>  :weight w)) 
>  ; Not equal times; which comes sooner? 
>  ( if ( &lt; t1 t2) 
>  m1 
>  m2))))))) 
>  ([] nil ) 
>  ([m] m) 
>  ([m1 m2] 
>  ( condp identical? nil 
>  m1 m2 
>  m2 m1 
>  ( let [op1 ( :op m1) 
>  op2 ( :op m2)] 
>  ( condp identical? :pending 
>  op1 m2 
>  op2 m1 
>  ( let [t1 ( :time op1) 
>  t2 ( :time op2)] 
>  ( if ( = t1 t2) 
>  ; We have a tie; decide based on weights. 
>  ( let [w1 ( :weight m1 1 ) 
>  w2 ( :weight m2 1 ) 
>  w ( + w1 w2)] 
>  ( assoc ( if ( &lt; ( rand-int w) w1) m1 m2) 
>  :weight w)) 
>  ; Not equal times; which comes sooner? 
>  ( if ( &lt; t1 t2) 
>  m1 
>  m2)))))))) 
>  
>  ( defrecord Any [gens] 
>  Generator 
>  
>  
>  
>  
> @@ -992,30 +1027,32 @@
>  ; default generator. 
>  Generator 
>  ( op [_ test ctx] 
>  ( let [{ :keys [op gen' i] :as soonest} 
>  ( -&gt;&gt; ranges 
>  ( map-indexed 
>  ( fn [i threads] 
>  ( let [gen ( nth gens i) 
>  ; Restrict context to this range of threads 
>  ctx (( nth context-filters i) ctx)] 
>  ; Ask this range's generator for an op 
>  ( when-let [[op gen'] ( op gen test ctx)] 
>  ; Remember our index 
>  { :op op 
>  :gen' gen' 
>  :weight ( count threads) 
>  :i i})))) 
>  ; And for the default generator... 
>  ( cons ( let [ctx (( peek context-filters) ctx)] 
>  ; And construct a triple for the default generator 
>  ( when-let [[op gen'] ( op ( peek gens) test ctx)] 
>  ( assert ctx) 
>  { :op op 
>  :gen' gen' 
>  :weight ( context/all-thread-count ctx) 
>  :i ( count ranges)}))) 
>  ( reduce soonest-op-map nil ))] 
>  ( let [ ; A transducer to compute op/gen'/weight/i maps for each of `ranges` 
>  xf ( map-indexed 
>  ( fn per-range [i threads] 
>  ( let [gen ( nth gens i) 
>  ; Restrict context to this range of threads 
>  ctx (( nth context-filters i) ctx)] 
>  ; Ask this range's generator for an op 
>  ( when-let [[op gen'] ( op gen test ctx)] 
>  ; Remember our index 
>  { :op op 
>  :gen' gen' 
>  :weight ( count threads) 
>  :i i})))) 
>  ; And for the default generator... 
>  default-op-map 
>  ( let [ctx (( peek context-filters) ctx)] 
>  ; And construct a triple for the default generator 
>  ( when-let [[op gen'] ( op ( peek gens) test ctx)] 
>  ( assert ctx) 
>  { :op op 
>  :gen' gen' 
>  :weight ( context/all-thread-count ctx) 
>  :i ( count ranges)})) 
>  ; Find soonest generator 
>  { :keys [op gen' i] :as soonest} 
>  ( transduce xf soonest-op-map default-op-map ranges)] 
>  ( when soonest 
>  ; A range has an operation to do! 
>  [op ( Reserve. ranges all-ranges context-filters ( assoc gens i gen'))]))) 
>  
>  
>  
>  
> @@ -1113,7 +1150,7 @@
>  ; when emitting ops. 
>  Generator 
>  ( op [_ test ctx] 
>  ( when ( seq gens) 
>  ( when -not ( = 0 ( count gens ) ) 
>  ( if-let [[op gen'] ( op ( nth gens i) test ctx)] 
>  ; Good, we have an op 
>  [op ( Mix. ( rand-int ( count gens)) ( assoc gens i gen'))] 
>  
>  
> @@ -1138,7 +1175,8 @@
>  won't let other generators (which could help us get unstuck!) advance. We 
>  should probably cycle on :pending. " 
>  [gens] 
>  ( Mix. ( rand-int ( count gens)) ( vec gens))) 
>  ( when ( seq gens) 
>  ( Mix. ( rand-int ( count gens)) ( vec gens)))) 
>  
>  ( defrecord Limit [remaining gen] 
>  Generator 
>  
>  
>  
>  
> @@ -1167,11 +1205,11 @@
>  [msg] 
>  { :type :log , :value msg}) 
>  
>  ( defrecord Repeat [remaining gen] 
>  ( defrecord Repeat [ ^long remaining gen] 
>  ; Remaining is positive for a limit, or -1 for infinite repeats. 
>  Generator 
>  ( op [_ test ctx] 
>  ( when-not ( zero? remaining) 
>  ( when-not ( = 0 remaining) 
>  ( when-let [[op gen'] ( op gen test ctx)] 
>  [op ( Repeat. ( max -1 ( dec remaining)) gen)])))
> 
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters.
>  Learn more about bidirectional Unicode characters 
>  Show hidden characters
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  @@ -4,7 +4,7 @@ import { 
>  
>  
>  
>  
>  
> DVault, 
>  
>  
>  
>  
>  
> WorkspaceOpts, 
>  
>  
>  
>  
>  
> } from "@dendronhq/common-all"; 
>  
>  
>  
>  
>  
> import { tmpDir } from "@dendronhq/common-server"; 
>  
>  
>  
>  
>  
> import { tmpDir, vault2Path } from "@dendronhq/common-server"; 
>  
>  
>  
>  
>  
> import { 
>  
>  
>  
>  
>  
> ENGINE_HOOKS, 
>  
>  
>  
>  
>  
> RunEngineTestFunctionV4, 
>  
>  
>  
>  
>  
>  
>  @@ -18,6 +18,7 @@ import { 
>  
>  
>  
>  
>  
> WorkspaceService, 
>  
>  
>  
>  
>  
> } from "@dendronhq/engine-server"; 
>  
>  
>  
>  
>  
> import _ from "lodash"; 
>  
>  
>  
>  
>  
> import { GitTestUtils } from "./utils"; 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> export type AsyncCreateEngineFunction = ( 
>  
>  
>  
>  
>  
> opts: WorkspaceOpts 
>  
>  
>  
>  
>  
>  
>  
>  
>  @@ -86,28 +87,39 @@ export type RunEngineTestV5Opts = { 
>  
>  
>  
>  
>  
> expect: any; 
>  
>  
>  
>  
>  
> vaults?: DVault[]; 
>  
>  
>  
>  
>  
> setupOnly?: boolean; 
>  
>  
>  
>  
>  
> initGit?: boolean; 
>  
>  
>  
>  
>  
> }; 
>  
>  
>  
>  
>  
> export async function runEngineTestV5( 
>  
>  
>  
>  
>  
> func: RunEngineTestFunctionV4, 
>  
>  
>  
>  
>  
> opts: RunEngineTestV5Opts 
>  
>  
>  
>  
>  
> ): Promise&lt;any&gt; { 
>  
>  
>  
>  
>  
> const { preSetupHook, extra, vaults, createEngine } = _.defaults(opts, { 
>  
>  
>  
>  
>  
> preSetupHook: async ({}) =&gt; {}, 
>  
>  
>  
>  
>  
> postSetupHook: async ({}) =&gt; {}, 
>  
>  
>  
>  
>  
> createEngine: createEngineFromEngine, 
>  
>  
>  
>  
>  
> extra: {}, 
>  
>  
>  
>  
>  
> // third vault has diff name 
>  
>  
>  
>  
>  
> vaults: [ 
>  
>  
>  
>  
>  
> { fsPath: "vault1" }, 
>  
>  
>  
>  
>  
> { fsPath: "vault2" }, 
>  
>  
>  
>  
>  
> { fsPath: "vault3", name: "vaultThree" }, 
>  
>  
>  
>  
>  
> ], 
>  
>  
>  
>  
>  
> }); 
>  
>  
>  
>  
>  
> const { preSetupHook, extra, vaults, createEngine, initGit } = _.defaults( 
>  
>  
>  
>  
>  
> opts, 
>  
>  
>  
>  
>  
> { 
>  
>  
>  
>  
>  
> preSetupHook: async ({}) =&gt; {}, 
>  
>  
>  
>  
>  
> postSetupHook: async ({}) =&gt; {}, 
>  
>  
>  
>  
>  
> createEngine: createEngineFromEngine, 
>  
>  
>  
>  
>  
> extra: {}, 
>  
>  
>  
>  
>  
> // third vault has diff name 
>  
>  
>  
>  
>  
> vaults: [ 
>  
>  
>  
>  
>  
> { fsPath: "vault1" }, 
>  
>  
>  
>  
>  
> { fsPath: "vault2" }, 
>  
>  
>  
>  
>  
> { fsPath: "vault3", name: "vaultThree" }, 
>  
>  
>  
>  
>  
> ], 
>  
>  
>  
>  
>  
> } 
>  
>  
>  
>  
>  
> ); 
>  
>  
>  
>  
>  
> const { wsRoot } = await setupWS({ vaults }); 
>  
>  
>  
>  
>  
> await preSetupHook({ wsRoot, vaults }); 
>  
>  
>  
>  
>  
> const engine: DEngineClientV2 = await createEngine({ wsRoot, vaults }); 
>  
>  
>  
>  
>  
> const initResp = await engine.init(); 
>  
>  
>  
>  
>  
> const testOpts = { wsRoot, vaults, engine, initResp, extra, config: engine }; 
>  
>  
>  
>  
>  
> if (initGit) { 
>  
>  
>  
>  
>  
> await Promise.all( 
>  
>  
>  
>  
>  
> vaults.map((vault) =&gt; { 
>  
>  
>  
>  
>  
> return GitTestUtils.createRepoWithReadme(vault2Path({ vault, wsRoot })); 
>  
>  
>  
>  
>  
> }) 
>  
>  
>  
>  
>  
> ); 
>  
>  
>  
>  
>  
> } 
>  
>  
>  
>  
>  
> if (opts.setupOnly) { 
>  
>  
>  
>  
>  
> return testOpts; 
>  
>  
>  
>  
>  
> } 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ||||I|||| Skip to content
> Toggle navigation
> Sign up
> * Product
> + Actions
> Automate any workflow
> + Packages
> Host and manage packages
> + Security
> Find and fix vulnerabilities
> + Codespaces
> Instant dev environments
> + Copilot
> Write better code with AI
> + Code review
> Manage code changes
> + Issues
> Plan and track work
> + Discussions
> Collaborate outside of code
> + Explore
> + All features
> + Documentation
> + GitHub Skills
> + Blog
> * Solutions
> + For
> + Enterprise
> + Teams
> + Startups
> + Education
> + By Solution
> + CI/CD & Automation
> + DevOps
> + DevSecOps
> + Case Studies
> + Customer Stories
> + Resources
> * Open Source
> + GitHub Sponsors
> Fund open source developers
> + The ReadME Project
> GitHub community articles
> + Repositories
> + Topics
> + Trending
> + Collections
> * Pricing
> * In this repository All GitHub ↵
> Jump to ↵
> * No suggested jump to results
> * In this repository All GitHub ↵
> Jump to ↵
> * In this organization All GitHub ↵
> Jump to ↵
> * In this repository All GitHub ↵
> Jump to ↵
> Sign in
> Sign up
> {{ message }}
> dendronhq / dendron Public
> *
> * Notifications
> * Fork 194
> * Star 5.2k
> * Code
> * Issues 736
> * Pull requests 23
> * Discussions
> * Actions
> * Projects 0
> * Wiki
> * Security
> * Insights
> More
> * Code
> * Issues
> * Pull requests
> * Discussions
> * Actions
> * Projects
> * Wiki
> * Security
> * Insights
> Permalink
> This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.
> Browse files
> feat: and and commit cmd
> * Loading branch information
> kevinslin committed Mar 30, 2021
> 1 parent 4a531d3 commit 9b9d86ccf54fdb8b58f4c04bd57700d8c4c84cf7
> Show file tree
> Hide file tree
> Showing 11 changed files with 164 additions and 28 deletions.
> Split Unified
> * packages
> + engine-server/src
> o topics
> - packages/engine-server/src/topics/git.ts git.ts
> o packages/engine-server/src/workspace.ts workspace.ts
> + engine-test-utils/src
> o __tests__/engine-server
> - __snapshots__
> * packages/engine-test-utils/src/__tests__/engine-server/__snapshots__/workspace.spec.ts.snap workspace.spec.ts.snap
> - topics
> * packages/engine-test-utils/src/__tests__/engine-server/topics/git.spec.ts git.spec.ts
> - packages/engine-test-utils/src/__tests__/engine-server/workspace.spec.ts workspace.spec.ts
> o packages/engine-test-utils/src/engine.ts engine.ts
> + plugin-core
> o packages/plugin-core/package.json package.json
> o src
> - commands
> * packages/plugin-core/src/commands/AddAndCommit.ts AddAndCommit.ts
> * packages/plugin-core/src/commands/index.ts index.ts
> - packages/plugin-core/src/constants.ts constants.ts
> + pods-core/src/builtin
> o packages/pods-core/src/builtin/GitPod.ts GitPod.ts
> There are no files selected for viewing
> 5 packages/engine-server/src/topics/git.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -89,4 +89,9 @@ export class Git {
> . filter ( ( ent ) => ! _ . isEmpty ( ent ) )
> . map ( ( ent ) => _ . trim ( ent ) ) ;
> }
> async hasChanges ( ) {
> const { stdout } = await this . _execute ( "git status --short" ) ;
> return ! _ . isEmpty ( stdout ) ;
> }
> }
> 30 packages/engine-server/src/workspace.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -22,6 +22,7 @@ import fs from "fs-extra";
> import _ from "lodash" ;
> import path from "path" ;
> import { DConfig } from "./config" ;
> import { Git } from "./topics/git" ;
> import { getPortFilePath , getWSMetaFilePath , writeWSMetaFile } from "./utils" ;
> const logger = createLogger ( ) ;
> @@ -122,6 +123,22 @@ export class WorkspaceService {
> return ;
> }
> async commidAndAddAll ( ) {
> const allRepos = await this . getAllRepos ( ) ;
> const out = await Promise . all (
> allRepos . map ( async ( root ) => {
> const git = new Git ( { localUrl : root } ) ;
> if ( await git . hasChanges ( ) ) {
> await git . addAll ( ) ;
> await git . commit ( { msg : "update" } ) ;
> return root ;
> }
> return undefined ;
> } )
> ) ;
> return _ . filter ( out , ( ent ) => ! _ . isUndefined ( ent ) ) ;
> }
> /**
> * Return if vaults have been cloned
> * @param opts
> @@ -249,6 +266,19 @@ export class WorkspaceService {
> return repoPath ;
> }
> async getAllRepos ( ) {
> const vaults = this . config . vaults ;
> const wsRoot = this . wsRoot ;
> return _ . uniq (
> await Promise . all (
> vaults . map ( async ( vault ) => {
> const vpath = vault2Path ( { vault , wsRoot } ) ;
> return GitUtils . getGitRoot ( vpath ) ;
> } )
> )
> ) ;
> }
> /**
> * Check if a path belongs to a workspace
> */
> 8 packages/engine-test-utils/src/__tests__/engine-server/__snapshots__/workspace.spec.ts.snap
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -0,0 +1,8 @@
> // Jest Snapshot v1, https://goo.gl/fbAQLP
> exports [ ` WorkspaceService commitAll 1 ` ] = `
> Array [
> " /tmp-5830-wQXk10hv7yY4/vault2",
> " /tmp-5830-wQXk10hv7yY4/vault1",
> ]
> `;
> 19 packages/engine-test-utils/src/__tests__/engine-server/topics/git.spec.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -1,6 +1,8 @@
> import { tmpDir } from "@dendronhq/common-server" ;
> import { Git } from "@dendronhq/engine-server" ;
> import { GitTestUtils } from "../../../utils" ;
> import fs from "fs-extra" ;
> import path from "path" ;
> describe ( "isRepo" , async ( ) => {
> test ( "no repo" , async ( ) => {
> @@ -17,4 +19,21 @@ describe("isRepo", async () => {
> expect ( repo ) . toMatchSnapshot ( ) ;
> expect ( repo ) . toBeTruthy ( ) ;
> } ) ;
> test ( "has no changes" , async ( ) => {
> const root = tmpDir ( ) . name ;
> await GitTestUtils . createRepoWithReadme ( root ) ;
> const git = new Git ( { localUrl : root } ) ;
> const changes = await git . hasChanges ( ) ;
> expect ( changes ) . toBeFalsy ( ) ;
> } ) ;
> test ( "has changes" , async ( ) => {
> const root = tmpDir ( ) . name ;
> await GitTestUtils . createRepoWithReadme ( root ) ;
> const git = new Git ( { localUrl : root } ) ;
> fs . writeFileSync ( path . join ( root , "gamma.md" ) , "hello" ) ;
> const changes = await git . hasChanges ( ) ;
> expect ( changes ) . toBeTruthy ( ) ;
> } ) ;
> } ) ;
> 28 packages/engine-test-utils/src/__tests__/engine-server/workspace.spec.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -1,9 +1,11 @@
> import { NoteProps } from "@dendronhq/common-all" ;
> import { tmpDir } from "@dendronhq/common-server" ;
> import { NoteTestUtilsV4 } from "@dendronhq/common-test-utils" ;
> import { DConfig , WorkspaceService } from "@dendronhq/engine-server" ;
> import { testWithEngine } from "../../engine" ;
> import { GitTestUtils } from "../../utils" ;
> import fs from "fs-extra" ;
> import path from "path" ;
> import { testWithEngine } from "../../engine" ;
> import { GitTestUtils } from "../../utils" ;
> describe ( "WorkspaceService" , ( ) => {
> testWithEngine (
> @@ -32,6 +34,7 @@ describe("WorkspaceService", () => {
> ) . toBeTruthy ( ) ;
> }
> ) ;
> testWithEngine (
> "init remoteVaults present, no init" ,
> async ( { wsRoot , engine } ) => {
> @@ -58,4 +61,25 @@ describe("WorkspaceService", () => {
> ) . toBeFalsy ( ) ;
> }
> ) ;
> testWithEngine (
> "commitAll" ,
> async ( { wsRoot , vaults } ) => {
> await NoteTestUtilsV4 . modifyNoteByPath (
> { wsRoot , vault : vaults [ 0 ] , fname : "foo" } ,
> ( note : NoteProps ) => {
> note . body = note . body + "\n Foo" ;
> return note ;
> }
> ) ;
> await NoteTestUtilsV4 . createNote ( {
> fname : "bar" ,
> vault : vaults [ 1 ] ,
> wsRoot ,
> } ) ;
> const resp = await new WorkspaceService ( { wsRoot } ) . commidAndAddAll ( ) ;
> expect ( resp ) . toMatchSnapshot ( ) ;
> } ,
> { initGit : true }
> ) ;
> } ) ;
> 38 packages/engine-test-utils/src/engine.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -4,7 +4,7 @@ import {
> DVault ,
> WorkspaceOpts ,
> } from "@dendronhq/common-all" ;
> import { tmpDir } from "@dendronhq/common-server" ;
> import { tmpDir , vault2Path } from "@dendronhq/common-server" ;
> import {
> ENGINE_HOOKS ,
> RunEngineTestFunctionV4 ,
> @@ -18,6 +18,7 @@ import {
> WorkspaceService ,
> } from "@dendronhq/engine-server" ;
> import _ from "lodash" ;
> import { GitTestUtils } from "./utils" ;
> export type AsyncCreateEngineFunction = (
> opts : WorkspaceOpts
> @@ -86,28 +87,39 @@ export type RunEngineTestV5Opts = {
> expect : any ;
> vaults ?: DVault [ ] ;
> setupOnly ?: boolean ;
> initGit ?: boolean ;
> } ;
> export async function runEngineTestV5 (
> func : RunEngineTestFunctionV4 ,
> opts : RunEngineTestV5Opts
> ) : Promise {
> const { preSetupHook , extra , vaults , createEngine } = _ . defaults ( opts , {
> preSetupHook : async ( { } ) => { } ,
> postSetupHook : async ( { } ) => { } ,
> createEngine : createEngineFromEngine ,
> extra : { } ,
> // third vault has diff name
> vaults : [
> { fsPath : "vault1" } ,
> { fsPath : "vault2" } ,
> { fsPath : "vault3" , name : "vaultThree" } ,
> ] ,
> } ) ;
> const { preSetupHook , extra , vaults , createEngine , initGit } = _ . defaults (
> opts ,
> {
> preSetupHook : async ( { } ) => { } ,
> postSetupHook : async ( { } ) => { } ,
> createEngine : createEngineFromEngine ,
> extra : { } ,
> // third vault has diff name
> vaults : [
> { fsPath : "vault1" } ,
> { fsPath : "vault2" } ,
> { fsPath : "vault3" , name : "vaultThree" } ,
> ] ,
> }
> ) ;
> const { wsRoot } = await setupWS ( { vaults } ) ;
> await preSetupHook ( { wsRoot , vaults } ) ;
> const engine : DEngineClientV2 = await createEngine ( { wsRoot , vaults } ) ;
> const initResp = await engine . init ( ) ;
> const testOpts = { wsRoot , vaults , engine , initResp , extra , config : engine } ;
> if ( initGit ) {
> await Promise . all (
> vaults . map ( ( vault ) => {
> return GitTestUtils . createRepoWithReadme ( vault2Path ( { vault , wsRoot } ) ) ;
> } )
> ) ;
> }
> if ( opts . setupOnly ) {
> return testOpts ;
> }
> 5 packages/plugin-core/package.json
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -315,6 +315,11 @@
> "docLink" : " dendron.topic.commands.md " ,
> "docPreview" : " ![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/hierarchy.go-down.gif) "
> },
> {
> "command" : " dendron.addAndCommit " ,
> "title" : " Dendron: Workspace: Add and Commit " ,
> "desc" : " add and commit all files "
> },
> {
> "command" : " dendron.vaultAdd " ,
> "title" : " Dendron: Vault Add " ,
> 33 packages/plugin-core/src/commands/AddAndCommit.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -0,0 +1,33 @@
> import _ from "lodash" ;
> import path from "path" ;
> import { window } from "vscode" ;
> import { DENDRON_COMMANDS } from "../constants" ;
> import { Logger } from "../logger" ;
> import { getWS } from "../workspace" ;
> import { BasicCommand } from "./base" ;
> const L = Logger ;
> type CommandOpts = { } ;
> export class AddAndCommit extends BasicCommand {
> static key = DENDRON_COMMANDS . ADD_AND_COMMIT . key ;
> async execute ( opts ?: CommandOpts ) {
> const ctx = "execute" ;
> L . info ( { ctx , opts } ) ;
> const resp = await getWS ( ) . workspaceService ! . commidAndAddAll ( ) ;
> if ( _ . isEmpty ( resp ) ) {
> window . showInformationMessage ( `no files to add or commit` ) ;
> return ;
> }
> const respString = _ . map ( resp , ( ent : string ) => {
> return path . basename ( ent ) ;
> } )
> . filter ( ( ent ) => ! _ . isUndefined ( ent ) )
> . join ( ", " ) ;
> window . showInformationMessage (
> `add and commit files in the following vaults: ${ respString } `
> ) ;
> return ;
> }
> }
> 2 packages/plugin-core/src/commands/index.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -1,3 +1,4 @@
> import { AddAndCommit } from "./AddAndCommit" ;
> import { ArchiveHierarchyCommand } from "./ArchiveHierarchy" ;
> import { BrowseNoteCommand } from "./BrowseNoteCommand" ;
> import { CodeCommandConstructor } from "./base" ;
> @@ -40,6 +41,7 @@ import { VaultAddCommand } from "./VaultAddCommand";
> import { VaultRemoveCommand } from "./VaultRemoveCommand" ;
> const ALL_COMMANDS = [
> AddAndCommit ,
> ArchiveHierarchyCommand ,
> BrowseNoteCommand ,
> ChangeWorkspaceCommand ,
> 6 packages/plugin-core/src/constants.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -362,6 +362,12 @@ export const DENDRON_COMMANDS: { [key: string]: CommandEntry } = {
> "![](https://foundation-prod-assetspublic53c57cce-8cpvgjldwysl.s3-us-west-2.amazonaws.com/assets/images/hierarchy.go-down.gif)" ,
> } ,
> // --- Workspace
> ADD_AND_COMMIT : {
> key : "dendron.addAndCommit" ,
> title : ` ${ CMD_PREFIX } Workspace: Add and Commit` ,
> group : "workspace" ,
> desc : "add and commit all files" ,
> } ,
> VAULT_ADD : {
> key : "dendron.vaultAdd" ,
> title : ` ${ CMD_PREFIX } Vault Add` ,
> 18 packages/pods-core/src/builtin/GitPod.ts
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -1,11 +1,10 @@
> import { Git } from "@dendronhq/engine-server" ;
> import { Time } from "@dendronhq/common-all" ;
> import { Git , WorkspaceService } from "@dendronhq/engine-server" ;
> import { createObjectCsvWriter } from "csv-writer" ;
> import fs from "fs-extra" ;
> import _ from "lodash" ;
> import path from "path" ;
> import { ExportPod , ExportPodPlantOpts } from "../basev3" ;
> import { Time } from "@dendronhq/common-all" ;
> import { createObjectCsvWriter } from "csv-writer" ;
> import { GitUtils , vault2Path } from "@dendronhq/common-server" ;
> const writeCSV = ( opts : { dest : string ; data : any [ ] ; header : any [ ] } ) => {
> const { dest , data , header } = opts ;
> @@ -48,20 +47,13 @@ export class GitPunchCardExportPod extends ExportPod {
> }
> async plant ( opts : ExportPodPlantOpts ) {
> const { dest , notes , wsRoot , vaults } = opts ;
> const { dest , notes , wsRoot } = opts ;
> // verify dest exist
> const podDstPath = dest . fsPath ;
> fs . ensureDirSync ( podDstPath ) ;
> const repoPaths = _ . uniq (
> await Promise . all (
> vaults . map ( async ( vault ) => {
> const vpath = vault2Path ( { vault , wsRoot } ) ;
> return GitUtils . getGitRoot ( vpath ) ;
> } )
> )
> ) ;
> const repoPaths = await new WorkspaceService ( { wsRoot } ) . getAllRepos ( ) ;
> const getAllCommits = async ( root : string ) => {
> const git = new Git ( { localUrl : root } ) ;
> 0 comments on commit 9b9d86c
> Please sign in to comment.
> Footer
> © 2023 GitHub, Inc.
> Footer navigation
> * Terms
> * Privacy
> * Security
> * Status
> * Docs
> * Contact GitHub
> * Pricing
> * API
> * Training
> * Blog
> * About
> You can’t perform that action at this time.
> You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.
> 
> @@ -55,25 +55,26 @@ func runProtoc( 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
> func TestCompare(t *testing.T) { 
>  
>  
>  
>  
>  
> for _, test := range []struct { 
>  
>  
>  
>  
>  
> rule string 
>  
>  
>  
>  
>  
> isErrNil bool 
>  
>  
>  
>  
>  
> skipRules []string 
>  
>  
>  
>  
>  
> errContains []string 
>  
>  
>  
>  
>  
> rule string 
>  
>  
>  
>  
>  
> isErrNil bool 
>  
>  
>  
>  
>  
> skipRules []string 
>  
>  
>  
>  
>  
> errContains []string 
>  
>  
>  
>  
>  
> errNotContains []string 
>  
>  
>  
>  
>  
> }{ 
>  
>  
>  
>  
>  
> {"FILE_NO_BREAKING_CHANGE", false, []string{}, []string{"all file options have been removed in options/3.proto current version", "java package for options/4.proto changed from com.stenciltest to com.stenciltest.change", 
>  
>  
>  
>  
>  
> "java outer classname for options/4.proto changed from Teststencil to Teststencil.change", "go package for options/4.proto changed from com.stenciltest to com.stenciltest.change", 
>  
>  
>  
>  
>  
> "package for package.proto changed from filebreakingchange to filebreaking", "syntax for syntax.proto changed from proto2 to proto3", "\"b/notfound.proto\" file has been deleted in current version"}}, 
>  
>  
>  
>  
>  
> "package for package.proto changed from filebreakingchange to filebreaking", "syntax for syntax.proto changed from proto2 to proto3", "\"b/notfound.proto\" file has been deleted in current version"}, []string{"com.stenciltest.valid"}}, 
>  
>  
>  
>  
>  
> {"ENUM_NO_BREAKING_CHANGE", false, []string{}, []string{"a.Two enum has been removed from current version", "enumValue a.Three.SEVEN_SPECIFIED deleted from current version", "a.Three.Eight enum has been removed from current version", 
>  
>  
>  
>  
>  
> "enumValue a.Three.ONE number changed from 0 to 1", "enumValue a.Three.TWO number changed from 1 to 0", "a.Three.Four.Five enum has been removed from current version", "enumValue a.TEN_1 deleted from current version", 
>  
>  
>  
>  
>  
> "enumValue a.TEN_2 deleted from current version"}}, 
>  
>  
>  
>  
>  
> {"MESSAGE_NO_DELETE", false, []string{}, []string{"a.Two has been removed in current version", "a.Three.Four.Five has been removed in current version", "a.Three.Seven has been removed in current version"}}, 
>  
>  
>  
>  
>  
> "enumValue a.TEN_2 deleted from current version"}, []string{}}, 
>  
>  
>  
>  
>  
> {"MESSAGE_NO_DELETE", false, []string{}, []string{"a.Two has been removed in current version", "a.Three.Four.Five has been removed in current version", "a.Three.Seven has been removed in current version"}, []string{}}, 
>  
>  
>  
>  
>  
> {"FIELD_NO_BREAKING_CHANGE", false, []string{}, []string{"a.One has been removed in current version", "a.Nine has been removed in current version", "field a.One.one is removed in current version", "field a.Two.three is removed in current version", 
>  
>  
>  
>  
>  
> "number changed for a.Two.four from 4 to 5", "type has changed for a.Two.five from int32 to string", "label changed for a.Two.six from repeated to optional", "json name changed for a.Two.eigth from foo to baz", "field a.Two.nine is removed in current version", 
>  
>  
>  
>  
>  
> "field a.Three.three is removed in current version", "number changed for a.Three.four from 4 to 5", "type has changed for a.Three.five from int32 to string", "label changed for a.Three.six from repeated to optional", "json name changed for a.Three.eigth from foo to baz", 
>  
>  
>  
>  
>  
> "field a.Three.Four.Five.three is removed in current version", "field a.Three.Four.Six.three is removed in current version", "number changed for a.Three.Four.Six.four from 4 to 5", "type has changed for a.Three.Four.Six.five from int32 to string", "label changed for a.Three.Four.Six.six from repeated to optional", 
>  
>  
>  
>  
>  
> "json name changed for a.Three.Four.Six.eigth from foo to baz", "field a.Three.Seven.three is removed in current version", "field a.Three.Eight.two is removed in current version", "field a.Nine.one is removed in current version", "field a.Nine.two is removed in current version", "field a.Nine.three is removed in current version", "field a.One2.three is removed in current version"}}, 
>  
>  
>  
>  
>  
> {"MESSAGE_NO_DELETE", true, []string{"MESSAGE_NO_DELETE", "FIELD_NO_BREAKING_CHANGE", "ENUM_NO_BREAKING_CHANGE", "FILE_NO_BREAKING_CHANGE"}, []string{}}, 
>  
>  
>  
>  
>  
> {"valid", true, []string{}, []string{}}, 
>  
>  
>  
>  
>  
> "json name changed for a.Three.Four.Six.eigth from foo to baz", "field a.Three.Seven.three is removed in current version", "field a.Three.Eight.two is removed in current version", "field a.Nine.one is removed in current version", "field a.Nine.two is removed in current version", "field a.Nine.three is removed in current version", "field a.One2.three is removed in current version"}, []string{}}, 
>  
>  
>  
>  
>  
> {"MESSAGE_NO_DELETE", true, []string{"MESSAGE_NO_DELETE", "FIELD_NO_BREAKING_CHANGE", "ENUM_NO_BREAKING_CHANGE", "FILE_NO_BREAKING_CHANGE"}, []string{}, []string{}}, 
>  
>  
>  
>  
>  
> {"valid", true, []string{}, []string{}, []string{}}, 
>  
>  
>  
>  
>  
> } { 
>  
>  
>  
>  
>  
> t.Run(test.rule, func(t *testing.T) { 
>  
>  
>  
>  
>  
> rule := strings.ToLower(test.rule) 
>  
>  
>  
>  
>  
>  
>  @@ -94,6 +95,9 @@ func TestCompare(t *testing.T) { 
>  
>  
>  
>  
>  
> for _, str := range test.errContains { 
>  
>  
>  
>  
>  
> assert.Contains(t, err.Error(), str) 
>  
>  
>  
>  
>  
> } 
>  
>  
>  
>  
>  
> for _, str := range test.errNotContains { 
>  
>  
>  
>  
>  
> assert.NotContains(t, err.Error(), str) 
>  
>  
>  
>  
>  
> } 
>  
>  
>  
>  
>  
> }) 
>  
>  
>  
>  
>  
> } 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ||||I|||| Skip to content
> Toggle navigation
> Sign up
> * Product
> + Actions
> Automate any workflow
> + Packages
> Host and manage packages
> + Security
> Find and fix vulnerabilities
> + Codespaces
> Instant dev environments
> + Copilot
> Write better code with AI
> + Code review
> Manage code changes
> + Issues
> Plan and track work
> + Discussions
> Collaborate outside of code
> + Explore
> + All features
> + Documentation
> + GitHub Skills
> + Blog
> * Solutions
> + For
> + Enterprise
> + Teams
> + Startups
> + Education
> + By Solution
> + CI/CD & Automation
> + DevOps
> + DevSecOps
> + Case Studies
> + Customer Stories
> + Resources
> * Open Source
> + GitHub Sponsors
> Fund open source developers
> + The ReadME Project
> GitHub community articles
> + Repositories
> + Topics
> + Trending
> + Collections
> * Pricing
> * In this repository All GitHub ↵
> Jump to ↵
> * No suggested jump to results
> * In this repository All GitHub ↵
> Jump to ↵
> * In this organization All GitHub ↵
> Jump to ↵
> * In this repository All GitHub ↵
> Jump to ↵
> Sign in
> Sign up
> {{ message }}
> odpf / stencil Public
> * Notifications
> * Fork 34
> * Star 183
> * Code
> * Issues 17
> * Pull requests 2
> * Actions
> * Projects 2
> * Security
> * Insights
> More
> * Code
> * Issues
> * Pull requests
> * Actions
> * Projects
> * Security
> * Insights
> Permalink
> This commit does not belong to any branch on this repository, and may belong to a fork outside of the repository.
> Browse files
> fix(server): comparison of proto file options
> * Loading branch information
> harikrishnakanchi committed May 22, 2021
> 1 parent ec1d4b4 commit 7f6ea6dde78f4bcfb4f1a8cdd536d261e83b8b25
> Show file tree
> Hide file tree
> Showing 10 changed files with 50 additions and 16 deletions.
> Split Unified
> * server/proto
> + server/proto/rules.go rules.go
> + server/proto/runner_test.go runner_test.go
> + testdata
> o enum_no_breaking_change
> - current
> * server/proto/testdata/enum_no_breaking_change/current/2.proto 2.proto
> - previous
> * server/proto/testdata/enum_no_breaking_change/previous/2.proto 2.proto
> o field_no_breaking_change
> - current
> * server/proto/testdata/field_no_breaking_change/current/2.proto 2.proto
> - previous
> * server/proto/testdata/field_no_breaking_change/previous/2.proto 2.proto
> o file_no_breaking_change
> - current/options
> * server/proto/testdata/file_no_breaking_change/current/options/5.proto 5.proto
> - previous/options
> * server/proto/testdata/file_no_breaking_change/previous/options/5.proto 5.proto
> o message_no_delete
> - current
> * server/proto/testdata/message_no_delete/current/1.proto 1.proto
> - previous
> * server/proto/testdata/message_no_delete/previous/1.proto 1.proto
> There are no files selected for viewing
> 12 server/proto/rules.go
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -109,14 +109,14 @@ func checkFileNoBreakingChange(current, prev *protoregistry.Files) error {
> err = multierr . Combine ( err , fmt . Errorf ( "all file options have been removed in %s current version" , path ))
> return true
> }
> if prevFileOptions . JavaPackage != currentFileOptions . JavaPackage {
> err = multierr . Combine ( err , fmt . Errorf ( "java package for %s changed from %s to %s" , path , * prevFileOptions . JavaPackage , * currentFileOptions . JavaPackage ))
> if prevFileOptions . GetJavaPackage () != currentFileOptions . GetJavaPackage () {
> err = multierr . Combine ( err , fmt . Errorf ( "java package for %s changed from %s to %s" , path , prevFileOptions . GetJavaPackage (), currentFileOptions . GetJavaPackage () ))
> }
> if * prevFileOptions . JavaOuterClassname != * currentFileOptions . JavaOuterClassname {
> err = multierr . Combine ( err , fmt . Errorf ( "java outer classname for %s changed from %s to %s" , path , * prevFileOptions . JavaOuterClassname , * currentFileOptions . JavaOuterClassname ))
> if prevFileOptions . GetJavaOuterClassname () != currentFileOptions . GetJavaOuterClassname () {
> err = multierr . Combine ( err , fmt . Errorf ( "java outer classname for %s changed from %s to %s" , path , prevFileOptions . GetJavaOuterClassname (), currentFileOptions . GetJavaOuterClassname () ))
> }
> if * prevFileOptions . GoPackage != * currentFileOptions . GoPackage {
> err = multierr . Combine ( err , fmt . Errorf ( "go package for %s changed from %s to %s" , path , * prevFileOptions . GoPackage , * currentFileOptions . GoPackage ))
> if prevFileOptions . GetGoPackage () != currentFileOptions . GetGoPackage () {
> err = multierr . Combine ( err , fmt . Errorf ( "go package for %s changed from %s to %s" , path , prevFileOptions . GetGoPackage (), currentFileOptions . GetGoPackage () ))
> }
> return true
> })
> 24 server/proto/runner_test.go
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -55,25 +55,26 @@ func runProtoc(
> func TestCompare ( t * testing. T ) {
> for _ , test := range [] struct {
> rule string
> isErrNil bool
> skipRules [] string
> errContains [] string
> rule string
> isErrNil bool
> skipRules [] string
> errContains [] string
> errNotContains [] string
> }{
> { "FILE_NO_BREAKING_CHANGE" , false , [] string {}, [] string { "all file options have been removed in options/3.proto current version" , "java package for options/4.proto changed from com.stenciltest to com.stenciltest.change" ,
> "java outer classname for options/4.proto changed from Teststencil to Teststencil.change" , "go package for options/4.proto changed from com.stenciltest to com.stenciltest.change" ,
> "package for package.proto changed from filebreakingchange to filebreaking" , "syntax for syntax.proto changed from proto2 to proto3" , " \" b/notfound.proto \" file has been deleted in current version" }},
> "package for package.proto changed from filebreakingchange to filebreaking" , "syntax for syntax.proto changed from proto2 to proto3" , " \" b/notfound.proto \" file has been deleted in current version" } , [] string { "com.stenciltest.valid" } },
> { "ENUM_NO_BREAKING_CHANGE" , false , [] string {}, [] string { "a.Two enum has been removed from current version" , "enumValue a.Three.SEVEN_SPECIFIED deleted from current version" , "a.Three.Eight enum has been removed from current version" ,
> "enumValue a.Three.ONE number changed from 0 to 1" , "enumValue a.Three.TWO number changed from 1 to 0" , "a.Three.Four.Five enum has been removed from current version" , "enumValue a.TEN_1 deleted from current version" ,
> "enumValue a.TEN_2 deleted from current version" }},
> { "MESSAGE_NO_DELETE" , false , [] string {}, [] string { "a.Two has been removed in current version" , "a.Three.Four.Five has been removed in current version" , "a.Three.Seven has been removed in current version" }},
> "enumValue a.TEN_2 deleted from current version" } , [] string {} },
> { "MESSAGE_NO_DELETE" , false , [] string {}, [] string { "a.Two has been removed in current version" , "a.Three.Four.Five has been removed in current version" , "a.Three.Seven has been removed in current version" } , [] string {} },
> { "FIELD_NO_BREAKING_CHANGE" , false , [] string {}, [] string { "a.One has been removed in current version" , "a.Nine has been removed in current version" , "field a.One.one is removed in current version" , "field a.Two.three is removed in current version" ,
> "number changed for a.Two.four from 4 to 5" , "type has changed for a.Two.five from int32 to string" , "label changed for a.Two.six from repeated to optional" , "json name changed for a.Two.eigth from foo to baz" , "field a.Two.nine is removed in current version" ,
> "field a.Three.three is removed in current version" , "number changed for a.Three.four from 4 to 5" , "type has changed for a.Three.five from int32 to string" , "label changed for a.Three.six from repeated to optional" , "json name changed for a.Three.eigth from foo to baz" ,
> "field a.Three.Four.Five.three is removed in current version" , "field a.Three.Four.Six.three is removed in current version" , "number changed for a.Three.Four.Six.four from 4 to 5" , "type has changed for a.Three.Four.Six.five from int32 to string" , "label changed for a.Three.Four.Six.six from repeated to optional" ,
> "json name changed for a.Three.Four.Six.eigth from foo to baz" , "field a.Three.Seven.three is removed in current version" , "field a.Three.Eight.two is removed in current version" , "field a.Nine.one is removed in current version" , "field a.Nine.two is removed in current version" , "field a.Nine.three is removed in current version" , "field a.One2.three is removed in current version" }},
> { "MESSAGE_NO_DELETE" , true , [] string { "MESSAGE_NO_DELETE" , "FIELD_NO_BREAKING_CHANGE" , "ENUM_NO_BREAKING_CHANGE" , "FILE_NO_BREAKING_CHANGE" }, [] string {}},
> { "valid" , true , [] string {}, [] string {}},
> "json name changed for a.Three.Four.Six.eigth from foo to baz" , "field a.Three.Seven.three is removed in current version" , "field a.Three.Eight.two is removed in current version" , "field a.Nine.one is removed in current version" , "field a.Nine.two is removed in current version" , "field a.Nine.three is removed in current version" , "field a.One2.three is removed in current version" } , [] string {} },
> { "MESSAGE_NO_DELETE" , true , [] string { "MESSAGE_NO_DELETE" , "FIELD_NO_BREAKING_CHANGE" , "ENUM_NO_BREAKING_CHANGE" , "FILE_NO_BREAKING_CHANGE" }, [] string {} , [] string {} },
> { "valid" , true , [] string {}, [] string {} , [] string {} },
> } {
> t . Run ( test . rule , func ( t * testing. T ) {
> rule := strings . ToLower ( test . rule )
> @@ -94,6 +95,9 @@ func TestCompare(t *testing.T) {
> for _ , str := range test . errContains {
> assert . Contains ( t , err . Error (), str )
> }
> for _ , str := range test . errNotContains {
> assert . NotContains ( t , err . Error (), str )
> }
> })
> }
> 3 server/proto/testdata/enum_no_breaking_change/current/2.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -8,4 +8,7 @@ enum Move {
> enum Move2 {
> TEN_1 = 0 ;
> TEN_3 = 1 ;
> }
> message MoveType {}
> 4 server/proto/testdata/enum_no_breaking_change/previous/2.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -9,3 +9,7 @@ enum Move {
> enum Move2 {
> TEN_2 = 0 ;
> }
> enum MoveType {
> TEN_3 = 0 ;
> }
> 1 server/proto/testdata/field_no_breaking_change/current/2.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -7,4 +7,5 @@ import "1.proto";
> message One2 {
> repeated Two one = 1 ;
> optional Three two = 2 ;
> message Two2 {}
> }
> 1 server/proto/testdata/field_no_breaking_change/previous/2.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -8,4 +8,5 @@ message One2 {
> repeated Two one = 1 ;
> optional Three two = 2 ;
> optional Three three = 3 ;
> optional int32 Two2 = 4 ;
> }
> 7 server/proto/testdata/file_no_breaking_change/current/options/5.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -0,0 +1,7 @@
> syntax = "proto3" ;
> package filebreaking.options ;
> option go_package = "com.stenciltest.valid2" ;
> option java_package = "com.stenciltest.valid" ;
> message One {}
> 8 server/proto/testdata/file_no_breaking_change/previous/options/5.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -0,0 +1,8 @@
> syntax = "proto3" ;
> package filebreaking.options ;
> option java_outer_classname = "Teststencil.valid" ;
> option go_package = "com.stenciltest.valid2" ;
> option java_package = "com.stenciltest.valid" ;
> message One {}
> 4 server/proto/testdata/message_no_delete/current/1.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -10,3 +10,7 @@ message Three {
> }
> message Eight {}
> }
> enum CheckSameFullName {
> Nine = 0 ;
> }
> 2 server/proto/testdata/message_no_delete/previous/1.proto
> Show comments
> View file Edit file Delete file
> This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters
> Show hidden characters
> Original file line number Diff line number Diff line change
> @@ -14,3 +14,5 @@ message Three {
> message Seven {}
> message Eight {}
> }
> message Nine {}
> 0 comments on commit 7f6ea6d
> Please sign in to comment.
> Footer
> © 2023 GitHub, Inc.
> Footer navigation
> * Terms
> * Privacy
> * Security
> * Status
> * Docs
> * Contact GitHub
> * Pricing
> * API
> * Training
> * Blog
> * About
> You can’t perform that action at this time.
> You signed in with another tab or window. Reload to refresh your session. You signed out in another tab or window. Reload to refresh your session.
> 
> Original file line number 
>  Diff line number 
>  Diff line change 
>  
>  
>  
>  
>  
>  
>  
>  
>  @@ -496,6 +496,28 @@ 
>  
>  
>  
>  
>  
>  ( nil? ( :type op)) ( assoc! :type :invoke ))) 
>  
>  
>  
>  
>  
>  :pending )) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( defrecord Fn 
>  
>  
>  
>  
>  
>  [ ; We memoize the function's arity so we don't have to reflect 
>  
>  
>  
>  
>  
>  ^long arity 
>  
>  
>  
>  
>  
>  ; The function itself 
>  
>  
>  
>  
>  
>  f] 
>  
>  
>  
>  
>  
>  Generator 
>  
>  
>  
>  
>  
>  ( update [this test ctx event] this) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ; When asked for an op, we invoke f to produce a generator, then exhaust that 
>  
>  
>  
>  
>  
>  ; before coming back to ourselves. 
>  
>  
>  
>  
>  
>  ( op [this test ctx] 
>  
>  
>  
>  
>  
>  ( when-let [gen ( if ( = arity 2 ) 
>  
>  
>  
>  
>  
>  ( f test ctx) 
>  
>  
>  
>  
>  
>  ( f ))] 
>  
>  
>  
>  
>  
>  ( op [gen this] test ctx)))) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( defn fn-wrapper 
>  
>  
>  
>  
>  
>  " Wraps a function into a wrapper which makes it more efficient to invoke. We 
>  
>  
>  
>  
>  
>  memoize the function's arity, in particular, to reduce reflection. " 
>  
>  
>  
>  
>  
>  [f] 
>  
>  
>  
>  
>  
>  ( Fn. ( first ( util/arities ( class f))) f)) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( extend-protocol Generator 
>  
>  
>  
>  
>  
>  nil 
>  
>  
>  
>  
>  
>  ( update [gen test ctx event] nil ) 
>  
>  
>  
>  
>  
>  
>  @@ -508,13 +530,11 @@ 
>  
>  
>  
>  
>  
>  [op ( if ( = :pending op) this nil )])) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  clojure.lang.AFunction 
>  
>  
>  
>  
>  
>  ( update [f test ctx event] f) 
>  
>  
>  
>  
>  
>  ( update [f test ctx event] 
>  
>  
>  
>  
>  
>  ( update ( fn-wrapper f) test ctx event)) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  ( op [f test ctx] 
>  
>  
>  
>  
>  
>  ( when-let [x ( if ( = 2 ( first ( util/arities ( class f)))) 
>  
>  
>  
>  
>  
>  ( f test ctx) 
>  
>  
>  
>  
>  
>  ( f ))] 
>  
>  
>  
>  
>  
>  ( op [x f] test ctx))) 
>  
>  
>  
>  
>  
>  ( op ( fn-wrapper f) test ctx)) 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  clojure.lang.Delay 
>  
>  
>  
>  
>  
>  ( update [d test ctx event] d)
> 
> 1 1 Bukkit 2 2 ====== 3 - A plugin API for [Minecraft] (https://minecraft.net/) servers, currently maintained by [SpigotMC] ( http ://www.spigotmc.org/) . 3 + A plugin API for [Minecraft] (https://minecraft.net/) servers, currently maintained by [SpigotMC] ( https ://www.spigotmc.org/) . 4 4 ​ 5 5 #### Index 6 6 * [Bug Reporting] (#bug-reporting) 7 7 * [Compilation] (#compilation) 8 8 * [Contributing] (#contributing) 9 9 * [Bukkit's Goals] (#bukkits-goals) 10 10 * [Code Requirements] (#code-requirements) 11 11 ​ 12 12 Bug Reporting 13 13 ------------- 14 - The development team is very open to both bug and feature requests / suggestions. You can submit these on the [JIRA Issue Tracker] ( http ://hub.spigotmc.org/jira/) . 14 + &lt; a name = "bug-reporting" &gt;&lt;/ a &gt; 15 + The development team is very open to both bug and feature requests / suggestions. You can submit these on the [JIRA Issue Tracker] ( https ://hub.spigotmc.org/jira/) . 15 16 ​ 16 17 Compilation 17 18 ----------- 18 - Bukkit is a Java program which uses [Maven 3] ( http ://maven.apache.org/) for compilation. To compile fresh from Git, simply perform the following steps: 19 + &lt; a name = "compilation" &gt;&lt;/ a &gt; 20 + Bukkit is a Java program which uses [Maven 3] ( https ://maven.apache.org/) for compilation. To compile fresh from Git, simply perform the following steps: 19 21 ​ 20 22 * Install Maven and Git using your preferred installation methods. 21 23 * `git clone https://hub.spigotmc.org/stash/scm/spigot/bukkit.git` . 22 24 * `mvn -P development clean install` . 23 25 24 26 Some IDEs such as [NetBeans] (https://netbeans.org/) can perform these steps for you. Any Maven capable Java IDE can be used to develop with Bukkit, however the current team's personal preference is to use NetBeans. 25 27 ​ 26 28 Contributing 27 29 ------------ 30 + &lt; a name = "contributing" &gt;&lt;/ a &gt; 28 31 Contributions of all sorts are welcome. To manage community contributions, we use the pull request functionality of Stash. In to gain access to Stash and create a pull request, you will first need to perform the following steps: 29 32 ​ 30 - * Create an account on [JIRA] ( http ://hub.spigotmc.org/jira/) . 31 - * Fill in the [SpigotMC CLA] ( http ://www.spigotmc.org/go/cla) and wait up to 24 hours for your Stash account to be activated. Please ensure that your username and email addresses match. 33 + * Create an account on [JIRA] ( https ://hub.spigotmc.org/jira/) . 34 + * Fill in the [SpigotMC CLA] ( https ://www.spigotmc.org/go/cla) and wait up to 24 hours for your Stash account to be activated. Please ensure that your username and email addresses match. 32 35 * Log into Stash using your JIRA credentials. 33 36 ​ 34 37 Once you have performed these steps you can create a fork, push your code changes, and then submit it for review. 35 38 ​ 36 39 If you submit a PR involving both Bukkit and CraftBukkit, each PR should link the other. 37 40 ​ 38 41 Although the minimum requirement for compilation &amp; usage is Java 8, we prefer all contributions to be written in Java 7 style code unless there is a compelling reason otherwise. 39 42 ​ 40 43 Bukkit's Goals 41 44 -------------- 45 + &lt; a name = "bukkits-goals" &gt;&lt;/ a &gt; 42 46 As a rough guideline, ask yourself the following questions to determine if the proposed change fits the Bukkit project's goals. Please remember that this is only a rough guideline 43 47 and it may or may not reflect the definitive answer to this question. 44 - Discussions about proposed changes are held in the [Spigot IRC ] (https://www.spigotmc.org/ wiki / irc-guide/ ) . 48 + Discussions about proposed changes are held in the [Spigot Discord ] (https://www.spigotmc.org/ go / discord ) . 45 49 ​ 46 50 * Does it expose an implementation detail of the server software, or the protocol or file formats? 47 51 ​ 48 52 1. If your change revolves around an implementation detail then it is not proper API design. Examples of bad API design would be along the lines of 49 53 a packet API or an NBT storage API. 50 54 * Does it result in unexpected behaviour as defined by the Vanilla specification? 51 55 1. One of the goals of the Bukkit project is to be an extended Minecraft Server. Meaning if you choose to run the Bukkit server without any plugin, it should function 52 56 exactly as the Minecraft Server would with some rare exceptions. If your change alters the behaviour of the server in such a way that you would not have the same experience as you 53 57 would in Vanilla, your change does not fit with the Bukkit project's goals. 54 58 * Does it expose an issue or vulnerability when operating within the Vanilla environment? 55 59 1. One of the goals of the Bukkit project is to be able to operate within the limitations of the Vanilla environment. If your change results in, or exposes, the ability to, for example, 56 60 crash the client invalid data is set, it does not fit the Bukkit project's needs. 57 61 ​ 58 62 If you answered yes to any of these questions, chances are high your change does not fit within the Bukkit project's goals and will likely not be accepted. 59 63 Regardless, there are a few other important questions that need to be asked before you start working on a change: 60 64 * Is this change reasonably supportable and maintainable? 61 65 1. *Are there tests for this change? Does this change rely on magic numbers?* 62 66 * Is this change reasonably future proof? 63 67 ​ 64 68 Code Requirements 65 69 ----------------- 66 - * For the most part, CraftBukkit and Bukkit use the [Sun/Oracle coding standards] ( http ://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) . 70 + &lt; a name = "code-requirements" &gt;&lt;/ a &gt; 71 + * For the most part, CraftBukkit and Bukkit use the [Sun/Oracle coding standards] ( https ://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) . 67 72 * No tabs; use 4 spaces instead. 68 73 * Empty lines should contain no spaces. 69 74 * No trailing whitespaces. 70 75 * No 80 character column limit, or 'weird' mid-statement newlines unless absolutely necessary. 71 76 * The 80 character column limit still applies to documentation. 72 77 * No one-line methods. 73 78 * All major additions should have documentation. 74 79 * Try to follow test driven development where available. 75 80 * All code should be free of magic values. If this is not possible, it should be marked with a TODO comment indicating it should be addressed in the future. 76 81 * If magic values are absolutely necessary for your change, what those values represent should be documented in the code as well as an explanation in the Pull Request description on why those values are necessary. 77 82 * No unnecessary code changes. Look through all your changes before you submit it. 78 83 * Do not attempt to fix multiple problems with a single patch or pull request. 79 84 * Avoid moving or renaming classes. 80 85 * All non-private methods and constructors must have specified nullability through [annotations] (https://github.com/JetBrains/java-annotations) 81 86 ​ 82 - Bukkit/CraftBukkit employs [JUnit 4] ( http ://www.vogella.com/ articles / JUnit /article.html) for testing. Pull Requests(PR) should attempt to integrate within that framework as appropriate. 87 + Bukkit/CraftBukkit employs [JUnit 4] ( https ://www.vogella.com/ tutorials / JUnit4 /article.html) for testing. Pull Requests(PR) should attempt to integrate within that framework as appropriate. 83 88 Bukkit is a large project and what seems simple to a PR author at the time of writing may easily be overlooked by other authors and updates. Including unit tests with your PR 84 89 will help to ensure the PR can be easily maintained over time and encourage the Spigot team to pull the PR. 85 90 ​ 86 91 * There needs to be a new line at the end of every file. 87 92 * Imports should be organised in a logical manner. 88 93 * Do not group packages 89 94 * __Absolutely no wildcard imports outside of tests.__ 90 95 ​ 91 - Any questions about these requirements can be asked in # spigot - dev in IRC . 96 + Any questions about these requirements can be asked in # help - development in Discord .
> 
> 1 1 CraftBukkit 2 2 ====== 3 - An implementation of the [Bukkit] (https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit) plugin API for [Minecraft] (https://minecraft.net/) servers, currently maintained by [SpigotMC] ( http ://www.spigotmc.org/) . 3 + An implementation of the [Bukkit] (https://hub.spigotmc.org/stash/projects/SPIGOT/repos/bukkit) plugin API for [Minecraft] (https://minecraft.net/) servers, currently maintained by [SpigotMC] ( https ://www.spigotmc.org/) . 4 4 ​ 5 5 #### Index 6 6 ​ 7 7 * [Bug Reporting] (#bug-reporting) 8 8 * [Compilation] (#compilation) 9 9 * [Contributing] (#contributing) 10 10 * [Code Requirements] (#code-requirements) 11 11 * [Applying Patches] (#applying-patches) 12 12 * [Making Changes to Minecraft] (#making-changes-to-minecraft) 13 13 * [Minimal Diff Policy] (#minimal-diff-policy) 14 14 * [CraftBukkit Comments] (#craftbukkit-comments) 15 15 * [Creating Pull Requests] (#creating-pull-requests) 16 16 * [Useful Resources] (#useful-resources) 17 17 ​ 18 18 Bug Reporting 19 19 ------------- 20 - The development team is very open to both bug and feature requests / suggestions. You can submit these on the [JIRA Issue Tracker] ( http ://hub.spigotmc.org/jira/) . 20 + &lt; a name = "bug-reporting" &gt;&lt;/ a &gt; 21 + The development team is very open to both bug and feature requests / suggestions. You can submit these on the [JIRA Issue Tracker] ( https ://hub.spigotmc.org/jira/) . 21 22 ​ 22 23 Compilation 23 24 ----------- 24 - CraftBukkit is a Java program which uses [Maven 3] ( http ://maven.apache.org/) for compilation. To compile fresh from Git, simply perform the following steps: 25 + &lt; a name = "compilation" &gt;&lt;/ a &gt; 26 + CraftBukkit is a Java program which uses [Maven 3] ( https ://maven.apache.org/) for compilation. To compile fresh from Git, simply perform the following steps: 25 27 ​ 26 28 * Install Git using your preferred installation methods. 27 29 * Download and run [BuildTools] (https://www.spigotmc.org/wiki/buildtools/) 28 30 ​ 29 31 Some IDEs such as [NetBeans] (https://netbeans.org/) can perform these steps for you. Any Maven capable Java IDE can be used to develop with CraftBukkit, however the current team's personal preference is to use NetBeans. 30 32 ​ 31 33 Contributing 32 34 ------------ 35 + &lt; a name = "contributing" &gt;&lt;/ a &gt; 33 36 Contributions of all sorts are welcome. To manage community contributions, we use the pull request functionality of Stash. In order to gain access to Stash and create a pull request, you will first need to perform the following steps: 34 37 ​ 35 - * Create an account on [JIRA] ( http ://hub.spigotmc.org/jira/) . 36 - * Fill in the [SpigotMC CLA] ( http ://www.spigotmc.org/go/cla) and wait up to 24 hours for your Stash account to be activated. Please ensure that your username and email addresses match. 38 + * Create an account on [JIRA] ( https ://hub.spigotmc.org/jira/) . 39 + * Fill in the [SpigotMC CLA] ( https ://www.spigotmc.org/go/cla) and wait up to 24 hours for your Stash account to be activated. Please ensure that your username and email addresses match. 37 40 * Log into Stash using your JIRA credentials. 38 41 ​ 39 42 Once you have performed these steps you can create a fork, push your code changes, and then submit it for review. 40 43 ​ 41 44 If you submit a PR involving both Bukkit and CraftBukkit, each PR should link the other. 42 45 ​ 43 - Although the minimum requirement for compilation &amp; usage is Java 8, we prefer all contributions to be written in Java 7 style code unless there is a compelling reason otherwise . 46 + The minimum requirement for style, compilation &amp; usage is Java 16 unless there is a compelling reason. 44 47 ​ 45 48 Code Requirements 46 49 ----------------- 47 - * For the most part, CraftBukkit and Bukkit use the [Sun/Oracle coding standards] ( http ://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) . 50 + &lt; a name = "code-requirements" &gt;&lt;/ a &gt; 51 + * For the most part, CraftBukkit and Bukkit use the [Sun/Oracle coding standards] ( https ://www.oracle.com/technetwork/java/javase/documentation/codeconvtoc-136057.html) . 48 52 * No tabs; use 4 spaces instead. 49 53 * Empty lines should contain no spaces. 50 54 * No trailing whitespaces. 51 55 * No 80 character column limit, or 'weird' mid-statement newlines unless absolutely necessary. 52 56 * The 80 character column limit still applies to documentation. 53 57 * No one-line methods. 54 58 * All major additions should have documentation. 55 59 * Try to follow test driven development where available. 56 60 * All code should be free of magic values. If this is not possible, it should be marked with a TODO comment indicating it should be addressed in the future. 57 61 * If magic values are absolutely necessary for your change, what those values represent should be documented in the code as well as an explanation in the Pull Request description on why those values are necessary. 58 62 * No unnecessary code changes. Look through all your changes before you submit it. 59 63 * Do not attempt to fix multiple problems with a single patch or pull request. 60 64 * Do not submit your personal changes to configuration files. 61 65 * Avoid moving or renaming classes. 62 66 ​ 63 - Bukkit/CraftBukkit employs [JUnit 4] ( http ://www.vogella.com/ articles / JUnit /article.html) for testing. Pull Requests(PR) should attempt to integrate within that framework as appropriate. 67 + Bukkit/CraftBukkit employs [JUnit 4] ( https ://www.vogella.com/ tutorials / JUnit4 /article.html) for testing. Pull Requests(PR) should attempt to integrate within that framework as appropriate. 64 68 Bukkit is a large project and what seems simple to a PR author at the time of writing may easily be overlooked by other authors and updates. Including unit tests with your PR 65 69 will help to ensure the PR can be easily maintained over time and encourage the Spigot team to pull the PR. 66 70 ​ 67 71 * There needs to be a new line at the end of every file. 68 72 * Imports should be organised in a logical manner. 69 73 * Do not group packages 70 74 * All new imports should be within existing CraftBukkit comments if any are present. If not, make them. 71 75 * __Absolutely no wildcard imports outside of tests.__ 72 76 * If you only use an import once, don't import it. Use the fully qualified name. 73 77 ​ 74 - Any questions about these requirements can be asked in # spigot - dev in IRC . 78 + Any questions about these requirements can be asked in # help - development in Discord . 75 79 ​ 76 80 Applying Patches 77 81 ---------------- 82 + &lt; a name = "applying-patches" &gt;&lt;/ a &gt; 78 83 Any time new patches are created and/or updated in CraftBukkit, you need to apply them to your development environment. 79 84 ​ 80 85 1. Pull changes from CraftBukkit repo. 81 86 2. Run the `applyPatches.sh` script in the CraftBukkit directory. 82 87 - This script requires a decompile directory from BuildTools. (e.g. &lt; BuildTools Directory &gt; /work/decompile-XXXXXX) 83 88 3. Your development environment is now up to date with the latest CraftBukkit patches! 84 89 ​ 85 90 Making Changes to Minecraft 86 91 --------------------------- 92 + &lt; a name = "making-changes-to-minecraft" &gt;&lt;/ a &gt; 87 93 Importing new NMS classes to CraftBukkit is actually very simple. 88 94 ​ 89 95 1. Find the `work/decompile-XXXXXX` folder in your BuildTools folder. 90 96 2. Find the class you want to add in the `net/minecraft/server` folder and copy it. 91 97 3. Copy the selected file to the `src/main/java/net/minecraft/server` folder in CraftBukkit. 92 98 4. Implement changes. 93 99 5. Run `makePatches.sh` to create a new patch for the new class. 94 100 * _Be sure that Git recognizes the new file. This might require manually adding the file._ 95 101 6. Commit new patch. 96 102 ​ 97 103 Done! You have added a new patch for CraftBukkit! 98 104 ​ 99 105 **Making Changes to NMS Classes** 100 106 ​ 101 107 Bukkit/CB employs a Minimal Diff policy to help guide when changes should be changed to Minecraft and what those changes should be. 102 108 This is to ensure that any changes have the smallest impact possible on the update process whenever a new Minecraft version is released. 103 109 As well as the Minimal Diff Policy, *every* change made to a Minecraft class must be marked with the appropriate CraftBukkit comment. 104 110 At no point should you rename an existing/obfuscated field or method. All references to existing/obfusacted fields/methods should be marked with the `// PAIL rename` comment. 105 - Mapping of new fields/methods are done when there are enough changes to warrant the work. (Any questions can be asked in #spigot-dev in [ IRC ](https://www.spigotmc.org/ wiki / irc-guide/ )) 111 + Mapping of new fields/methods are done when there are enough changes to warrant the work. (Any questions can be asked in our [ Discord ](https://www.spigotmc.org/ go / discord )) 106 112 ​ 107 113 __*Key Points*__: 108 114 * All additions to patches must be accompanied by an appropriate comment. 109 115 * To avoid large patches, avoid adding methods where possible. We prefer making fields public over adding methods in patches. 110 116 * If you *have* to add a method to a patch, please explain why in the Pull Request description. 111 117 * __Never__ rename an existing field or method. If you want something renamed, include a ```e
> // PAIL rename``` comment 112 118 * Converting a method/class from one access level to another (i.e. private to public) is fine as long as that method is not overridden in subclasses. 113 119 * If a method is overridden in its' subclasses, create a new method that calls that method instead (along with appropriate CraftBukkit comments). 114 120 * If you can use a field to accomplish something, use that over creating a new method. 115 121 ​ 116 122 Minimal Diff Policy 117 123 ------------------- 124 + &lt; a name = "minimal-diff-policy" &gt;&lt;/ a &gt; 118 125 ​ 119 126 The Minimal Diff Policy is key to any changes made within Minecraft classes. When people think of the phrase "minimal diffs", they often take it 120 127 to the extreme - they go completely out of their way to abstract the changes they are trying to make away from editing Minecraft's classes as much as possible. 121 128 However, this is not what is meant by "minimal diffs". Instead, when trying to understand this policy, it helps to keep in mind its goal: to reduce the impact of changes we make 122 129 to Minecraft's internals have on our update process. 123 130 ​ 124 131 To put it simply, the Minimal Diffs Policy simply means to make the smallest change in a Minecraft class possible without duplicating logic. 125 132 ​ 126 133 Here are a few tips you should keep in mind, or common areas you should focus on: 127 134 ​ 195 202 this.b(world, i, j, k, itemstack); 196 203 } 197 204 // CraftBukkit end */ 198 205 ​ 199 206 super.remove(world, i, j, k, l, i1); 200 207 } 201 208 } 202 209 ``` 203 210 ​ 204 211 #### CraftBukkit Comments 212 + &lt; a name = "craftbukkit-comments" &gt;&lt;/ a &gt; 205 213 ​ 206 214 Changes to a Minecraft class should be clearly marked using CraftBukkit comments. 207 215 ​ 208 216 * All CraftBukkit comments should be capitalised appropriately. (i.e. CraftBukkit, not CB/craftBukkit, etc.) 209 217 * If the change only affects one line of code, use an end of line CraftBukkit comment 210 218 ​ 211 219 __Examples:__ 212 220 ​ 213 221 If the change is obvious, then you need a simple end of line comment. 214 222 ```java 267 275 } 268 276 // CraftBukkit end 269 277 ``` 270 278 * All CraftBukkit comments should be on the same indentation level the code block it is in. 271 279 ​ 272 280 __Imports in Minecraft Classes__ 273 281 * Do not remove unused imports if they are not marked by CraftBukkit comments. 274 282 ​ 275 283 Creating Pull Requests 276 284 ---------------------- 285 + &lt; a name = "creating-pull-requests" &gt;&lt;/ a &gt; 277 286 To learn what Spigot expects of a Pull Request please view the [Contributing guidelines](CONTRIBUTING.md) 278 287 ​ 279 288 Useful Resources 280 289 ---------------- 290 + &lt; a name = "useful-resources" &gt;&lt;/ a &gt; 281 291 ​ 282 292 * [An example pull request demonstrating the things we look out for](https://hub.spigotmc.org/stash/projects/SPIGOT/repos/craftbukkit/pull-requests/365/overview) 283 - * [JIRA, our bug tracker]( http ://hub.spigotmc.org/jira/) 284 - * [Join us on IRC - # spigot - dev @ irc.spi.gt ](https://www.spigotmc.org/ wiki / irc-guide/ ) 293 + * [JIRA, our bug tracker]( https ://hub.spigotmc.org/jira/) 294 + * [Join us on Discord - # help - development ](https://www.spigotmc.org/ go / discord )
> 
> Java Evolution: From Java 8 to Java 17, Compared with Kotlin and Clojure 
>  This README provides a brief overview and code examples of some notable Java language features introduced in recent versions of Java. Each section corresponds to a specific feature. 
>  Table of Contents 
>  
>  Local-Variable Syntax for Lambda Parameters 
>  Pattern Matching 
>  Records 
>  Sealed Classes 
>  Text Blocks 
>  Switch Expressions 
>  
>  Local-Variable Syntax for Lambda Parameters 
>  In Java, starting from version 11, you can use the var keyword for lambda parameters, simplifying lambda expressions by allowing type inference. Here's an example: 
>  // Java 11 Lambda Expression with var 
> ( var a , var b ) -&gt; a + b ; 
>  Pattern Matching 
>  Java introduced pattern matching in later versions, enhancing the way you work with instanceof checks and type casting. It provides more concise and readable code. Here's a simplified example: 
>  // Pattern Matching in Java 
>  public static boolean available ( Book book ) {
>  return switch ( book ) {
>  case FictionBook fictionBook -&gt; fictionBook . available ();
>  case ProgrammingBook programmingBook -&gt; programmingBook . exists ();
>  case PsychologicalBook psychologicalBook -&gt; psychologicalBook . imAAvailable ();
>  case null , default -&gt; false ;
> };
> } 
>  Records 
>  Records, introduced in Java 16, provide a compact way to declare classes that are simple data carriers. They automatically generate methods like equals() , hashCode() , and toString() . Example: 
>  // Java Record 
>  public record BookResponse ( String json , Double version ) {
> }
>  BookResponse bookResponse = new BookResponse ( "{}" , 2d );
>  System . out . println ( bookResponse ); // Automatically calls toString() 
>  Sealed Classes 
>  Java introduced sealed classes to restrict which other classes or interfaces may extend or implement them. It helps in defining a finite set of subclasses. Example: 
>  // Sealed Class in Java 
>  public sealed class Book permits FictionBook , ProgrammingBook , PsychologicalBook 
>  Text Blocks 
>  Text Blocks, available from Java 13 onwards, simplify working with multi-line strings. They allow you to write formatted text with minimal escape sequences: 
>  // Java Text Block 
>  json += """ 
>  {"title":"%s", 
>  "author":"%s", 
>  "pages":%s, 
>  "karma":%s, 
>  "eBook":%s, 
>  "rate":%s, 
>  "category":"%s"} 
>  """ 
>  Switch Expressions 
>  Java introduced switch expressions in Java 12. They allow you to use a switch statement as an expression, making code more concise and readable: 
>  // Java Switch Expression 
>  var book = switch ( category ) {
>  case fiction -&gt; {
>  karma = 25 ;
> yield new FictionBook ( title , author );
> }
>  case programming -&gt; {
>  karma = 40 ;
> yield new ProgrammingBook ( title , author );
> }
>  case psychological -&gt; {
>  karma = 30 ;
> yield new PsychologicalBook ( title , author );
> }
> }; 
>  These features have been introduced to make Java code more expressive and readable while reducing boilerplate code. You can choose the appropriate feature based on your project's requirements and Java version. 
>  Conclusion 
>  While I believe that Java 17 and its new releases are undeniably impressive, I can't help but acknowledge that Kotlin offers a multitude of features that enhance the developer experience and make coding more enjoyable. Clojure, on the other hand, has been a revelation for me, highlighting that you don't necessarily need classes and object-oriented programming to elegantly solve complex business logic challenges. It's a reminder that diverse programming languages can offer unique perspectives and solutions.
> 
> likely to yield significantly better space and time performance.
> 
> java.lang.Double(double)
> 9
> 
> It is rarely appropriate to use this constructor. The static factory
>  Double.valueOf(double) is generally a better choice, as it is
>  likely to yield significantly better space and time performance.
> 
> java.lang.Double(String)
> 9
> 
> It is rarely appropriate to use this constructor.
>  Use Double.parseDouble(String) to convert a string to a
>  double primitive, or use Double.valueOf(String)
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> transitive
> java.management
> 
> Defines the Java Management Extensions (JMX) API.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> java.io.ObjectStreamException(String, Throwable)
> 19
> 
> Create an ObjectStreamException with the specified message and
>  cause.
> 
> java.io.ObjectStreamException(Throwable)
> 19
> 
> Create an ObjectStreamException with the specified cause.
> 
> java.lang.IndexOutOfBoundsException(long)
> 16
> 
> Constructs a new IndexOutOfBoundsException class with an
>  argument indicating the illegal index.
> 
> java.net.ServerSocket(SocketImpl)
> 12
> 
> Creates a server socket with a user-specified SocketImpl.
> 
> Requires
> 
> 
> 
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> java.util.SequencedCollection
> 21
> 
> A collection that has a well-defined encounter order, that supports operations at both ends,
>  and that is reversible.
> 
> java.util.SequencedMap
> 21
> 
> A Map that has a well-defined encounter order, that supports operations at both ends, and
>  that is reversible.
> 
> java.util.SequencedSet
> 21
> 
> A collection that is both a SequencedCollection and a Set.
> 
> java.util.stream.DoubleStream.DoubleMapMultiConsumer
> 16
> 
> Represents an operation that accepts a double-valued argument
> 
> Produce reverseBytes(a)
> 
> jdk.incubator.vector.VectorOperators.TRAILING_ZEROS_COUNT
> 19
> 
> Produce numberOfTrailingZeros(a)
> 
> jdk.net.ExtendedSocketOptions.SO_INCOMING_NAPI_ID
> 15
> 
> Identifies the receive queue that the last incoming packet for the socket
>  was received on.
> 
> jdk.net.ExtendedSocketOptions.SO_PEERCRED
> 16
> 
> Unix Domain peer credentials.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Methods
> 
> 
> 
> 
> 
> 
> 
> 
> New Constructors
> 
> 
> 
> 
> 
> 
> com.sun.net.httpserver.Headers(Map<String, List<String>>)
> 18
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.security.interfaces.RSAMultiPrimePrivateCrtKey.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.security.interfaces.RSAPrivateCrtKey.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.security.interfaces.RSAPrivateKey.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
> 
> Interfaces
> Classes
> Enum Classes
> Exception Classes
> Fields
> Methods
> Enum Constants
> 
> 
> 
> 
> Interfaces
> 
> 
> 
> 
> 
> 
> 
> 
> Classes
> 
> 
> 
> 
> 
> 
> java.lang.runtime.TemplateRuntimePREVIEW
> String Templates
> 
> Manages string template bootstrap methods.
> 
> java.lang.ScopedValuePREVIEW
> Scoped Values
> 
> A value that may be safely and efficiently shared to methods without using method
>  parameters.
> 
> java.lang.ScopedValue.CarrierPREVIEW
> Scoped Values
> 
> A mapping of scoped values, as keys, to values.
> 
> java.io.Serial
> 14
> 
> Indicates that an annotated field or method is part of the serialization mechanism defined by the
>  
>  Java Object Serialization Specification.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Fields
> 
> 
> 
> 
> 
> 
> java.lang.Character.UnicodeBlock.ARABIC_EXTENDED_B
> 19
> 
> Constant for the "Arabic Extended-B" Unicode
>  character block.
> 
> java.lang.Character.UnicodeBlock.ARABIC_EXTENDED_C
> 20
> 
> Constant for the "Arabic Extended-C" Unicode
>  character block.
> 
> java.lang.Character.UnicodeBlock.CHESS_SYMBOLS
> 12
> 
> Thrown when a structure violation is detected.
> 
> javax.crypto.DecapsulateException
> 21
> 
> An exception that is thrown by the
>  KEM.Decapsulator.decapsulate(byte[]) method to denote an
>  error during decapsulation.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Record Classes
> 
> 
> 
> 
> 
> 
> jdk.jshell.SourceCodeAnalysis.Highlight
> 19
> 
> Assigns attributes usable for coloring to spans inside a snippet.
> 
> jdk.net.UnixDomainPrincipal
> 16
> 
> Represents the credentials of a peer connected to a
>  
>  Unix domain socket.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Annotation Interfaces
> 
> and a detail message of (cause==null ? null : cause.toString())
>  (which typically contains the class and detail message of cause).
> 
> java.text.CompactNumberFormat(String, DecimalFormatSymbols, String[], String)
> 14
> 
> Creates a CompactNumberFormat using the given decimal pattern,
>  decimal format symbols, compact patterns, and plural rules.
> 
> java.util.concurrent.ForkJoinWorkerThread(ThreadGroup, ForkJoinPool, boolean)
> 19
> 
> Creates a ForkJoinWorkerThread operating in the given thread group and
> 
> Maximum number of argument slots in String Concat call.
> 
> java.lang.Math.TAU
> 19
> 
> The double value that is closer than any other to
>  tau (τ), the ratio of the circumference of a circle
>  to its radius.
> 
> java.lang.StrictMath.TAU
> 19
> 
> The double value that is closer than any other to
>  tau (τ), the ratio of the circumference of a circle
>  to its radius.
> 
> java.math.BigDecimal.TWO
> 19
> 
> The value 2, with a scale of 0.
> 
> java.security.spec.MGF1ParameterSpec.SHA3_224
> 16
> 
> Creates a mutable Headers from the given headers with
>  the same header names and values.
> 
> java.io.InvalidClassException(String, String, Throwable)
> 19
> 
> Report an InvalidClassException for the reason and cause specified.
> 
> java.io.InvalidClassException(String, Throwable)
> 19
> 
> Report an InvalidClassException for the reason and cause specified.
> 
> java.io.InvalidObjectException(String, Throwable)
> 19
> 
> Constructs an InvalidObjectException with the given
>  reason and cause.
> 
> component of a record class.
> 
> java.lang.runtime.ObjectMethods
> 16
> 
> Bootstrap methods for state-driven implementations of core methods,
>  including Object.equals(Object), Object.hashCode(), and
>  Object.toString().
> 
> java.lang.runtime.SwitchBootstraps
> 21
> 
> Bootstrap methods for linking invokedynamic call sites that implement
>  the selection functionality of the switch statement.
> 
> java.lang.runtime.TemplateRuntimePREVIEW
> 21
> 
> Manages string template bootstrap methods.
> 
> java.lang.ScopedValuePREVIEW
> 21
> 
> Use RoundingMode.UNNECESSARY instead.
> 
> java.math.BigDecimal.ROUND_UP
> 9
> 
> Use RoundingMode.UP instead.
> 
> java.net.HttpURLConnection.HTTP_SERVER_ERROR
> 
> 
> it is misplaced and shouldn't have existed.
> 
> java.rmi.server.RemoteRef.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> java.rmi.server.ServerRef.serialVersionUID
> 
> 
> A serialVersionUID field in an interface is
>  ineffectual. Do not use; no replacement.
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> ```java
> // src/main/test/java/com/atproto/codegen/TestUtils.java
> // src/test/java/com/atproto/codegen/TestUtils.java
> 
> package com.atproto.codegen;
> 
> 
> 
> import com.atproto.lexicon.models.*;
> 
> 
> 
> import javax.tools.*;
> 
> import java.io.ByteArrayInputStream;
> 
> import java.io.IOException;
> 
> import java.io.InputStream;
> 
> import java.io.OutputStream;
> 
> import java.net.URI;
> 
> import java.net.URISyntaxException;
> 
> import java.nio.CharBuffer;
> 
> import java.nio.charset.StandardCharsets;
> 
> import java.util.*;
> 
> import java.util.stream.Stream;
> 
> 
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> 
> 
> public class TestUtils {
> 
> 
> 
>     public static LexiconDoc createSimpleQueryLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.simpleQuery", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createSimpleQueryLexiconWithDescription() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>()); // Added description
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.simpleQueryWithDescription", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createQueryWithParamsLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> params = new HashMap<>();
> 
>         params.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty()));
> 
>         params.put("p_int", new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
> 
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.paramsQuery", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createProcedureLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         Map<String, LexPrimitive> properties = new HashMap<>();
> 
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
> 
> 
>         LexXrpcBody input = new LexXrpcBody("application/json", Optional.of(new LexObject(
> 
>                 Optional.empty(), Optional.empty(), properties,
> 
>                 new ArrayList<>())), Optional.empty());
> 
> 
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(),
> 
>                 Optional.empty());
> 
> 
> 
>         LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(input), Optional.empty(), Optional.of(output),
> 
>                 new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "procedure", procedure));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.procedure", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createSubscriptionLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         Map<String, LexPrimitive> properties = new HashMap<>(); // Properties, for message
> 
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty())); // Add string property
> 
> 
> 
>         LexXrpcSubscription subscription = new LexXrpcSubscription(Optional.empty(), Optional.empty()); // Declare
> 
>                                                                                                         // subscription
> 
> 
> 
>         defs.add(new LexDefinition("main", "subscription", subscription)); // Add to Definitions.
> 
> 
> 
>         return new LexiconDoc(1, "com.example.subscription", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createMultiMethodLexicon() {  // Multiple Method Lexicon.
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Query
> 
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
> 
>             Optional.empty());   //Create Output
> 
> 
> 
>         LexXrpcQuery query =
> 
>             new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(outputQuery), new ArrayList<>());  //Create Query
> 
>         defs.add(new LexDefinition("queryMethod", "query", query)); //Add Definition
> 
> 
> 
>         // Procedure
> 
>         LexXrpcBody inputProcedure =
> 
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create input
> 
>         LexXrpcBody outputProcedure =
> 
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create output
> 
> 
> 
>         LexXrpcProcedure procedure =
> 
>             new LexXrpcProcedure(Optional.of(inputProcedure), Optional.empty(),
> 
>                 Optional.of(outputProcedure), new ArrayList<>());  //Create Procedure
> 
> 
> 
>         defs.add(new LexDefinition("procedureMethod", "procedure", procedure));   //Add Definition
> 
> 
> 
>         return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
> 
>             defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                 java.util.function.Function.identity))); //Convert Def List to Map
> 
>     }
> 
> 
> 
>     private static LexiconDoc createDuplicateMethodLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
> 
>                 Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(outputQuery), new ArrayList<>());
> 
>         defs.add(new LexDefinition("queryMethod", "query", query));
> 
>         defs.add(new LexDefinition("queryMethod", "query", query)); // Duplicate
> 
> 
> 
>         return new LexiconDoc(1, "com.example.duplicateMethod", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createNestedObjectLexicon() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Define the nested object type
> 
>         Map<String, LexPrimitive> nestedProperties = new HashMap<>();
> 
>         nestedProperties.put("innerString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexObject nestedObject = new LexObject(Optional.empty(), Optional.empty(), nestedProperties, new ArrayList<>());
> 
> 
> 
>         // Main query with an object containing the nested object
> 
>         Map<String, LexType> properties = new HashMap<>();
> 
>         properties.put("outerObject", nestedObject);
> 
> 
> 
>         LexXrpcBody output = new LexXrpcBody("application/json",
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), properties, new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(), Optional.of(output),
> 
>                 new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
> 
> 
>         return new LexiconDoc(1, "com.example.nestedObject", Optional.of(0), Optional.empty(),
> 
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> 
>                         java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithParams(String id, Map<String, ? extends LexType> params) {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
> 
>                 new ArrayList<>());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(output), new ArrayList<>());
> 
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, id, Optional.of(0), Optional.empty(), defs.stream().collect(
> 
>                 java.util.stream.Collectors.toMap(LexDefinition::getId, java.util.function.Function.identity())));
> 
>     }
> 
> 
> 
>     public static LexiconDoc createLexiconWithRefUnionParams() {
> 
>         List<LexDefinition> defs = new ArrayList<>();
> 
> 
> 
>         // Define the referenced types
> 
>         Map<String, LexPrimitive> recordDef1Props = new HashMap<>();
> 
>         recordDef1Props.put("name1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
> 
>                 Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef1 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef1Props, new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         Map<String, LexPrimitive> recordDef2Props = new HashMap<>();
> 
>         recordDef2Props.put("name2",
> 
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         LexRecord recordDef2 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
> 
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef2Props,
> 
>                         new ArrayList<>())),
> 
>                 Optional.empty());
> 
> 
> 
>         defs.add(new LexDefinition("recordDef1", "record", recordDef1));
> 
>         defs.add(new LexDefinition("recordDef2", "record", recordDef2));
> 
> 
> 
>         // Main query with a ref-union parameter
> 
>         Map<String, LexType> params = new HashMap<>();
> 
>         List<String> refs = List.of("#recordDef1", "#recordDef2
> ```
> 
> ```java
> // src/main/java/com/atproto/codegen/InMemoryCompiler.java
> package com.atproto.codegen;
> 
> 
> 
> import javax.tools.*;
> 
> import java.net.URI;
> 
> import java.util.*;
> 
> 
> 
> import javax.tools.*;
> 
> import java.io.ByteArrayOutputStream;
> 
> import java.io.IOException;
> 
> import java.io.OutputStream;
> 
> import java.net.URI;
> 
> import java.net.URISyntaxException;
> 
> import java.nio.CharBuffer;
> 
> import java.util.HashMap;
> 
> import java.util.List;
> 
> import java.util.Map;
> 
> 
> 
> public class InMemoryCompiler {
> 
> 
> 
>     private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
> 
> 
> 
>     public static Class<?> compile(String className, String sourceCode)
> 
>             throws URISyntaxException, ClassNotFoundException {
> 
>         JavaFileManager fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));
> 
> 
> 
>         List<JavaFileObject> compilationUnits = List.of(
> 
>                 new SourceFileObject(className, sourceCode));
> 
> 
> 
>         // Create a compilation task
> 
>         JavaCompiler.CompilationTask task = compiler.getTask(
> 
>                 null, // No writer, write to memory.
> 
>                 fileManager,
> 
>                 null, // No diagnostics listener
> 
>                 null, // No options
> 
>                 null, // No classes to be processed (for annotation processing)
> 
>                 compilationUnits);
> 
> 
> 
>         // Perform the compilation
> 
>         boolean success = task.call();
> 
> 
> 
>         if (!success) {
> 
>             throw new RuntimeException("Compilation failed");
> 
>         }
> 
> 
> 
>         // Load the compiled class
> 
>         return fileManager.getClassLoader(null).loadClass(className);
> 
>     }
> 
> 
> 
>     private static class SourceFileObject extends SimpleJavaFileObject {
> 
>         private final String sourceCode;
> 
> 
> 
>         SourceFileObject(String name, String sourceCode) throws URISyntaxException {
> 
>             super(new URI("string:///" + name.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
> 
>             this.sourceCode = sourceCode;
> 
>         }
> 
> 
> 
>         @Override
> 
>         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
> 
>             return CharBuffer.wrap(sourceCode);
> 
>         }
> 
>     }
> 
> 
> 
>     private static class ClassFileObject extends SimpleJavaFileObject {
> 
>         private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
> 
> 
> 
>         ClassFileObject(String name, Kind kind) throws URISyntaxException {
> 
>             super(new URI("byte:///" + name.replace('.', '/') + kind.extension), kind);
> 
>         }
> 
> 
> 
>         byte[] getBytes() {
> 
>             return outputStream.toByteArray();
> 
>         }
> 
> 
> 
>         @Override
> 
>         public OutputStream openOutputStream() {
> 
>             return outputStream;
> 
>         }
> 
>     }
> 
> 
> 
>     private static class ClassFileManager extends ForwardingJavaFileManager<JavaFileManager> {
> 
>         private final Map<String, ClassFileObject> compiledClasses = new HashMap<>();
> 
> 
> 
>         ClassFileManager(JavaFileManager fileManager) {
> 
>             super(fileManager);
> 
>         }
> 
> 
> 
>         @Override
> 
>         public ClassLoader getClassLoader(Location location) {
> 
>             return new ClassLoader() {
> 
>                 @Override
> 
>                 protected Class<?> findClass(String name) throws ClassNotFoundException {
> 
>                     ClassFileObject classFile = compiledClasses.get(name);
> 
>                     if (classFile == null) {
> 
>                         throw new ClassNotFoundException(name);
> 
>                     }
> 
>                     byte[] bytes = classFile.getBytes();
> 
>                     return defineClass(name, bytes, 0, bytes.length);
> 
>                 }
> 
>             };
> 
>         }
> 
> 
> 
>         @Override
> 
>         public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,
> 
>                 FileObject sibling) throws IOException {
> 
>             try {
> 
>                 ClassFileObject fileObject = new ClassFileObject(className, kind);
> 
>                 compiledClasses.put(className, fileObject); // Store the compiled class
> 
> 
> 
>                 return fileObject;
> 
>             } catch (URISyntaxException ex) {
> 
>                 throw new RuntimeException(ex);
> 
>             }
> 
>         }
> 
>     }
> 
> }
> 
> 
> ```
> 
> 
> 
> ```java
> // java src/main/test/java/com/atproto/codegen/TestUtils.java (203-208)
>         defs.add(new LexDefinition("recordDef1", "record", recordDef1));
> 
>         defs.add(new LexDefinition("recordDef2", "record", recordDef2));
> 
> 
> 
>         // Main query with a ref-union parameter
> 
>         Map<String, LexType> params = new HashMap<>();
> 
>         List<String> refs = List.of("#recordDef1", "#recordDef2
> ```
> 
> 
> ```java
> // java src/main/test/java/com/atproto/codegen/TestUtils.java (208-208)
>         List<String> refs = List.of("#recordDef1", "#recordDef2
> ```
> Git Diff  Java 21 LTS TestUtils.java InMemoryCompiler.java Continue your response exactly where you left off:

#### _Assistant_

> ```java
> UPPER_CASE() + " = \"" + constValue + "\";"));
>         }
> 
>         // Regex pattern (using annotation value)
>         if (pattern != null) {
>             Annotation patternAnnotation = paramField.getAnnotation(Pattern.class);
>             assertNotNull(patternAnnotation, "Pattern annotation not found.");
>             assertEquals(pattern, ((Pattern) patternAnnotation).regexp(), "Pattern regexp() value mismatch.");
>         }
> 
>         // Test constraint violations by *attempting* to set bad values.
>         Object paramInstance = paramClass.getDeclaredConstructor().newInstance();
> 
>         // Test maxLength violation
>         if (maxLength != null) {
>             String longString = "a".repeat(maxLength + 1);
>             assertThrows(ConstraintViolationException.class, () -> {
>                 paramField.setAccessible(true);  // Make it accessible.
>                 paramField.set(paramInstance, longString); //Set the parameter, throw if invalid.
>             });
> 
>         }
> 
>         // Test minLength violation
>         if (minLength != null) {
>             String shortString = "a".repeat(minLength - 1);
>             assertThrows(ConstraintViolationException.class, () -> {
>                 paramField.setAccessible(true);  // Make it accessible.
>                 paramField.set(paramInstance, shortString);  //Set the parameter, throw if invalid.
>             });
>         }
> 
>         // Test const violation (we set to the valid, and then an invalid value)
> 
>         if(constValue != null){
>             String validValue = constValue;
>             paramField.setAccessible(true); //Make field accessible.
>             paramField.set(paramInstance, validValue);  //Set GOOD.
>             String invalidValue = validValue + "_INVALID";
> 
>             assertThrows(ConstraintViolationException.class, () -> {
>                  paramField.setAccessible(true);  // Make it accessible.
>                  paramField.set(paramInstance, invalidValue);    //Try set invalid value.
>             });
>         }
> 
>         // Test pattern violation
>         if(pattern != null){
>             //Try setting invalid input.
>             assertThrows(ConstraintViolationException.class, () -> {
>                 paramField.setAccessible(true);  // Make it accessible.
>                 paramField.set(paramInstance, "123");    //Try set invalid numerical value.
>             });
>         }
> 
>     }
> 
>     // Data Providers (Continued)
> 
>     // Parameterized Test for Ref Union Params: Now provides Lexicons, Method Name, and expected Parameter Type.
>     private static Stream<Arguments> provideLexiconsForRefUnionParams() {
>         return Stream.of(
>                 Arguments.of(TestUtils.createLexiconWithRefUnionParams(), "refUnionParams", "java.lang.Object") //Object for now, may be refined
>         );
>     }
> 
> 
> 
>       // Added Invalid Lex Version Test
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForInvalidLexVersions")
>     public void testInvalidLexiconVersion(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
>         ClientGenerator generator = new ClientGenerator();
>         assertThrows(expectedException, () -> generator.generateClient(lexiconDoc)); // Expect an exception
>     }
> 
>     private static Stream<Arguments> provideLexiconsForInvalidLexVersions() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
>                 Optional.of(output), new ArrayList<>()); // Added description
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return Stream.of(
>                  // lex value of 0 is invalid 
>                 Arguments.of(new LexiconDoc(0, "com.example.invalidVersion", Optional.of(0), Optional.empty(),
>                         defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                                 java.util.function.Function.identity()))), IllegalArgumentException.class) // Invalid Version
> 
>         );
>     }
> 
> 
>     // Added Valid Lex Version test
>     @ParameterizedTest
>     @MethodSource("provideLexiconsForValidLexVersions")
>     public void testValidLexiconVersion(LexiconDoc lexiconDoc) throws Exception {
>         //Valid Lex Version
>         ClientGenerator generator = new ClientGenerator();
>         String generatedCode = generator.generateClient(lexiconDoc);
> 
>         // --- Compilation and Reflection ---
>         String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
>         Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className,
>                 generatedCode);
>         Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> 
>          // Inject mockXrpcClient
>         java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
>         xrpcClientField.setAccessible(true);
>         xrpcClientField.set(clientInstance, mockXrpcClient);
> 
>         when(mockXrpcClient.sendQuery(anyString(), any(), any(), any())).thenReturn(new AtpResponse<>(null, Optional.empty()));
> 
>     }
> 
>     private static Stream<Arguments> provideLexiconsForValidLexVersions() {
>           List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
>                 Optional.of(output), new ArrayList<>()); // Added description
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return Stream.of(
>                 // lex value of 1
>                 Arguments.of(new LexiconDoc(1, "com.example.validversion", Optional.of(0), Optional.empty(),
>                         defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                                 java.util.function.Function.identity()))))
> 
>         );
>     }
> 
> 
> }
> ```
> 
> ```java
> // src/test/java/com/atproto/codegen/TestUtils.java
> package com.atproto.codegen;
> 
> import com.atproto.lexicon.models.*;
> 
> import javax.tools.*;
> import java.io.ByteArrayInputStream;
> import java.io.IOException;
> import java.io.InputStream;
> import java.io.OutputStream;
> import java.net.URI;
> import java.net.URISyntaxException;
> import java.nio.CharBuffer;
> import java.nio.charset.StandardCharsets;
> import java.util.*;
> import java.util.stream.Stream;
> 
> import org.junit.jupiter.params.provider.Arguments;
> 
> public class TestUtils {
> 
>     public static LexiconDoc createSimpleQueryLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
>         return new LexiconDoc(1, "com.example.simpleQuery", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createSimpleQueryLexiconWithDescription() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
>                 Optional.of(output), new ArrayList<>()); // Added description
>         defs.add(new LexDefinition("main", "query", query));
>         return new LexiconDoc(1, "com.example.simpleQueryWithDescription", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createQueryWithParamsLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
>         Map<String, LexPrimitive> params = new HashMap<>();
>         params.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty()));
>         params.put("p_int", new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                 new ArrayList<>());
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                 Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.paramsQuery", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createProcedureLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> properties = new HashMap<>();
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
> 
>         LexXrpcBody input = new LexXrpcBody("application/json", Optional.of(new LexObject(
>                 Optional.empty(), Optional.empty(), properties,
>                 new ArrayList<>())), Optional.empty());
> 
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(),
>                 Optional.empty());
> 
>         LexXrpcProcedure procedure = new LexXrpcProcedure(Optional.of(input), Optional.empty(), Optional.of(output),
>                 new ArrayList<>());
>         defs.add(new LexDefinition("main", "procedure", procedure));
> 
>         return new LexiconDoc(1, "com.example.procedure", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createSubscriptionLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         Map<String, LexPrimitive> properties = new HashMap<>(); // Properties, for message
>         properties.put("p_string", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty())); // Add string property
> 
>         LexXrpcSubscription subscription = new LexXrpcSubscription(Optional.empty(), Optional.empty()); // Declare
>                                                                                                         // subscription
> 
>         defs.add(new LexDefinition("main", "subscription", subscription)); // Add to Definitions.
> 
>         return new LexiconDoc(1, "com.example.subscription", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createMultiMethodLexicon() {  // Multiple Method Lexicon.
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         // Query
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
>             Optional.empty());   //Create Output
> 
>         LexXrpcQuery query =
>             new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.of(outputQuery), new ArrayList<>());  //Create Query
>         defs.add(new LexDefinition("queryMethod", "query", query)); //Add Definition
> 
>         // Procedure
>         LexXrpcBody inputProcedure =
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create input
>         LexXrpcBody outputProcedure =
>             new LexXrpcBody("application/json", Optional.empty(), Optional.empty());    //Create output
> 
>         LexXrpcProcedure procedure =
>             new LexXrpcProcedure(Optional.of(inputProcedure), Optional.empty(),
>                 Optional.of(outputProcedure), new ArrayList<>());  //Create Procedure
> 
>         defs.add(new LexDefinition("procedureMethod", "procedure", procedure));   //Add Definition
> 
>         return new LexiconDoc(1, "com.example.multiMethod", Optional.of(0), Optional.empty(),
>             defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                 java.util.function.Function.identity))); //Convert Def List to Map
>     }
> 
>     private static LexiconDoc createDuplicateMethodLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcBody outputQuery = new LexXrpcBody("application/json", Optional.empty(),
>                 Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.of(outputQuery), new ArrayList<>());
>         defs.add(new LexDefinition("queryMethod", "query", query));
>         defs.add(new LexDefinition("queryMethod", "query", query)); // Duplicate
> 
>         return new LexiconDoc(1, "com.example.duplicateMethod", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createNestedObjectLexicon() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         // Define the nested object type
>         Map<String, LexPrimitive> nestedProperties = new HashMap<>();
>         nestedProperties.put("innerString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
>         LexObject nestedObject = new LexObject(Optional.empty(), Optional.empty(), nestedProperties, new ArrayList<>());
> 
>         // Main query with an object containing the nested object
>         Map<String, LexType> properties = new HashMap<>();
>         properties.put("outerObject", nestedObject);
> 
>         LexXrpcBody output = new LexXrpcBody("application/json",
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), properties, new ArrayList<>())),
>                 Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(), Optional.of(output),
>                 new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.nestedObject", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createLexiconWithParams(String id, Map<String, ? extends LexType> params) {
>         List<LexDefinition> defs = new ArrayList<>();
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                 new ArrayList<>());
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                 Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
>         return new LexiconDoc(1, id, Optional.of(0), Optional.empty(), defs.stream().collect(
>                 java.util.stream.Collectors.toMap(LexDefinition::getId, java.util.function.Function.identity())));
>     }
> 
>     public static LexiconDoc createLexiconWithRefUnionParams() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         // Define the referenced types
>         Map<String, LexPrimitive> recordDef1Props = new HashMap<>();
>         recordDef1Props.put("name1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
>         LexRecord recordDef1 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef1Props, new ArrayList<>())),
>                 Optional.empty());
> 
>         Map<String, LexPrimitive> recordDef2Props = new HashMap<>();
>         recordDef2Props.put("name2",
>                 new LexInteger(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>         LexRecord recordDef2 = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordDef2Props,
>                         new ArrayList<>())),
>                 Optional.empty());
> 
>         defs.add(new LexDefinition("recordDef1", "record", recordDef1));
>         defs.add(new LexDefinition("recordDef2", "record", recordDef2));
> 
>         // Main query with a ref-union parameter
>         Map<String, LexType> params = new HashMap<>();
>         List<String> refs = List.of("#recordDef1", "#recordDef2

#### _User_

> 
> 
> ```java
> // java src/main/test/java/com/atproto/codegen/TestUtils.java (209-209)
>         List<String> refs = List.of("#recordDef1", "#recordDef2
> ```
> Continue your response exactly where you left off:

#### _Assistant_

> ```java
> ");
>         params.put("refUnionParam", new LexRefUnion(refs, Optional.empty()));
> 
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                 new ArrayList<>());
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                 Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query));
> 
>         return new LexiconDoc(1, "com.example.refUnionParams", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
>     public static LexiconDoc createLexiconWithMultipleDefs() {
>         List<LexDefinition> defs = new ArrayList<>();
> 
>         LexXrpcBody output1 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query1 = new LexXrpcQuery(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.of(output1), new ArrayList<>());
>         defs.add(new LexDefinition("query1", "query", query1));
> 
>         Map<String, LexPrimitive> params2 = new HashMap<>();
>         params2.put("param1", new LexString(Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty()));
>         LexXrpcParameters xrpcParams2 = new LexObject(Optional.of("params"), Optional.empty(), params2,
>                 new ArrayList<>());
> 
>         LexXrpcBody output2 = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>         LexXrpcQuery query2 = new LexXrpcQuery(Optional.of(xrpcParams2), Optional.empty(), Optional.empty(),
>                 Optional.of(output2), new ArrayList<>());
>         defs.add(new LexDefinition("query2", "query", query2));
> 
>         Map<String, LexPrimitive> recordProperties = new HashMap<>();
>         recordProperties.put("name", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                 Optional.empty(), Optional.empty()));
>         LexRecord recordDef = new LexRecord(Optional.of("object"), Optional.empty(), Optional.empty(),
>                 Optional.of(new LexObject(Optional.empty(), Optional.empty(), recordProperties, new ArrayList<>())),
>                 Optional.empty());
>         defs.add(new LexDefinition("record1", "record", recordDef));
> 
>         return new LexiconDoc(1, "com.example.multipleDefs", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
> 
>     public static LexiconDoc createLexiconWithoutDefs() {
>         //Create a LexiconDoc without 'defs'.  This is invalid.
>         return new LexiconDoc(1, "com.example.invalid", Optional.of(0),Optional.empty(), Map.of());
> 
> 
>     }
> 
>     public static LexiconDoc createLexiconWithInvalidType() {
>         // Create a LexiconDoc with an invalid parameter type within a query.
>         List<LexDefinition> defs = new ArrayList<>();
>         Map<String, LexPrimitive> params = new HashMap<>();
>         //Add an invalid type.
>         params.put("invalidParam", new LexString (Optional.of("invalidtype"), Optional.empty(), Optional.empty(), Optional.empty(), Optional.empty()));
>         LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                 new ArrayList<>());
>         LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> 
>         LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                 Optional.of(output), new ArrayList<>());
>         defs.add(new LexDefinition("main", "query", query)); //
> 
>         return new LexiconDoc(1, "com.example.invalidType", Optional.of(0), Optional.empty(),
>                 defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                         java.util.function.Function.identity())));
>     }
> 
>     public static InputStream stringToInputStream(String str) {
>         return new ByteArrayInputStream(str.getBytes(StandardCharsets.UTF_8));
>     }
>     public static class InMemoryCompiler {
>       private static final JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
> 
>       public static Class&lt;?&gt; compile(String className, String sourceCode)
>           throws URISyntaxException, ClassNotFoundException {
>         JavaFileManager fileManager = new ClassFileManager(compiler.getStandardFileManager(null, null, null));
> 
>         List&lt;JavaFileObject&gt; compilationUnits = List.of(
>             new SourceFileObject(className, sourceCode));
> 
>         // Create a compilation task
>         JavaCompiler.CompilationTask task = compiler.getTask(
>             null,    //No writer, write to memory.
>             fileManager,
>             null,    // No diagnostics listener
>             null,    // No options
>             null,    // No classes to be processed (for annotation processing)
>             compilationUnits);
> 
>         // Perform the compilation
>         boolean success = task.call();
> 
>           if (!success) {
>               //For proper error reporting, we need to collect the diagnostics.
>               DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;&gt;();
>               JavaFileManager fileManager2 = new ClassFileManager(compiler.getStandardFileManager(diagnostics, null, null));
>                compiler.getTask(
>                       null,    //No writer, write to memory.
>                       fileManager2,
>                       diagnostics,
>                       null,    // No options
>                       null,    // No classes to be processed
>                       compilationUnits).call();  //Don't check success; we want to see the diagnostics in either case.
> 
>               StringBuilder errorMsg = new StringBuilder();
>               errorMsg.append("Compilation failed:\n");
>               for (Diagnostic&lt;? extends JavaFileObject&gt; diagnostic : diagnostics.getDiagnostics()) {
>                   errorMsg.append(diagnostic.toString()).append("\n");
> 
>               }
>               throw new RuntimeException(errorMsg.toString());
>           }
> 
>         // Load the compiled class
>         return fileManager.getClassLoader(null).loadClass(className);
>       }
> 
>       private static class SourceFileObject extends SimpleJavaFileObject {
>         private final String sourceCode;
> 
>         SourceFileObject(String name, String sourceCode) throws URISyntaxException {
>           super(new URI("string:///" + name.replace('.', '/') + Kind.SOURCE.extension), Kind.SOURCE);
>           this.sourceCode = sourceCode;
>         }
> 
>         @Override
>         public CharSequence getCharContent(boolean ignoreEncodingErrors) {
>           return CharBuffer.wrap(sourceCode);
>         }
>       }
> 
>       private static class ClassFileObject extends SimpleJavaFileObject {
>         private final ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
> 
>         ClassFileObject(String name, Kind kind) throws URISyntaxException {
>           super(new URI("byte:///" + name.replace('.', '/') + kind.extension), kind);
>         }
> 
>         byte[] getBytes() {
>           return outputStream.toByteArray();
>         }
> 
>         @Override
>         public OutputStream openOutputStream() {
>           return outputStream;
>         }
>       }
> 
>       private static class ClassFileManager extends ForwardingJavaFileManager&lt;JavaFileManager&gt; {
>         private final Map&lt;String, ClassFileObject&gt; compiledClasses = new HashMap&lt;&gt;();
> 
>         ClassFileManager(JavaFileManager fileManager) {
>           super(fileManager);
>         }
> 
>         @Override
>         public ClassLoader getClassLoader(Location location) {
>           return new ClassLoader() {
>             @Override
>             protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException {
>               ClassFileObject classFile = compiledClasses.get(name);
>               if (classFile == null) {
>                 throw new ClassNotFoundException(name);
>               }
>               byte[] bytes = classFile.getBytes();
>               return defineClass(name, bytes, 0, bytes.length);
>             }
>           };
>         }
> 
>         @Override
>         public JavaFileObject getJavaFileForOutput(Location location, String className, JavaFileObject.Kind kind,
>             FileObject sibling) throws IOException {
>           try {
>             ClassFileObject fileObject = new ClassFileObject(className, kind);
>             compiledClasses.put(className, fileObject); // Store the compiled class
> 
>             return fileObject;
>           } catch (URISyntaxException ex) {
>             throw new RuntimeException(ex);
>           }
>         }
>       }
>         public static  LexiconDoc createLexiconWithStringConstraints() {
>             List<LexDefinition> defs = new ArrayList<>();
>             Map<String, LexPrimitive> params = new HashMap<>();
> 
>             // String with maxLength
>             params.put("maxLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.of(10),
>                     Optional.empty(), Optional.empty()));
> 
>             // String with minLength
>             params.put("minLengthString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                     Optional.of(5), Optional.empty()));
> 
>             // String with const
>             params.put("constString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                     Optional.empty(), Optional.of(List.of("constantValue"))));
> 
>             //String with pattern
>             params.put("patternString", new LexString(Optional.empty(),Optional.of("[a-zA-Z]+"), Optional.empty(),
>                     Optional.empty(), Optional.empty()));
>             //String with enum
> 
>             List<String> enumValues = Arrays.asList("value1", "value2", "value3");
>             params.put("enumString", new LexString(Optional.empty(), Optional.empty(), Optional.empty(),
>                     Optional.empty(), Optional.of(enumValues)));
> 
> 
> 
>             LexXrpcParameters xrpcParams = new LexObject(Optional.of("params"), Optional.empty(), params,
>                     new ArrayList<>());
>             LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
>             LexXrpcQuery query = new LexXrpcQuery(Optional.of(xrpcParams), Optional.empty(), Optional.empty(),
>                    Optional.of(output), new ArrayList<>());
>             defs.add(new LexDefinition("main", "query", query));
> 
>             return new LexiconDoc(1, "com.example.stringConstraints", Optional.of(0), Optional.empty(),
>                     defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
>                             java.util.function.Function.identity())));
>         }
> 
>         public static Stream<Arguments> provideLexiconsForStringConstraints() {
>             return Stream.of(
>                     Arguments.of(createLexiconWithStringConstraints(), "maxLengthString", "String", 10, null, null, null),   //maxLength
>                     Arguments.of(createLexiconWithStringConstraints(), "minLengthString", "String", null, 5, null, null),    //minLength
>                     Arguments.of(createLexiconWithStringConstraints(), "constString", "String", null, null, "constantValue", null), //const value
>                     Arguments.of(createLexiconWithStringConstraints(), "patternString", "String", null, null, null, "[a-zA-Z]+")   //Regex pattern
>                    //Arguments.of(createLexiconWithStringConstraints(), "enumString", "String", null, null, null,enumValues)
>             );
>         }
> 
>     }
> 
> }
> ```
> 
> ```diff
> --- a/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> +++ b/src/main/test/java/com/atproto/codegen/ClientGeneratorTest.java
> @@ -124,6 +124,34 @@ public class ClientGeneratorTest {
>      }
>  
>  
> +
> +    // Added Invalid Lex Version Test
> +   @ParameterizedTest
> +   @MethodSource("provideLexiconsForInvalidLexVersions")
> +   public void testInvalidLexiconVersion(LexiconDoc lexiconDoc, Class<? extends Exception> expectedException) {
> +       ClientGenerator generator = new ClientGenerator();
> +       assertThrows(expectedException, () -> generator.generateClient(lexiconDoc)); //Expect an exception
> +   }
> +
> +
> +   private static Stream<Arguments> provideLexiconsForInvalidLexVersions() {
> +        List<LexDefinition> defs = new ArrayList<>();
> +       LexXrpcBody output = new LexXrpcBody("application/json", Optional.empty(), Optional.empty());
> +       LexXrpcQuery query = new LexXrpcQuery(Optional.empty(), Optional.of("This is a test query."), Optional.empty(),
> +               Optional.of(output), new ArrayList<>()); // Added description
> +       defs.add(new LexDefinition("main", "query", query));
> +
> +       return Stream.of(
> +                // lex value of 0 is invalid
> +               Arguments.of(new LexiconDoc(0, "com.example.invalidVersion", Optional.of(0), Optional.empty(),
> +                       defs.stream().collect(java.util.stream.Collectors.toMap(LexDefinition::getId,
> +                               java.util.function.Function.identity()))), IllegalArgumentException.class) //Invalid Version
> +
> +       );
> +   }
> +
> +
> +
>      //Test that AtpResponse gets imported.
>      @Test
>      public void testAtpResponseType() throws IOException {
> @@ -645,6 +673,25 @@ private static Stream<Arguments> provideLexiconsForStringConstraints() {
>      }
>  
>  
> +      //Added Valid Lex Version test
> +   @ParameterizedTest
> +   @MethodSource("provideLexiconsForValidLexVersions")
> +   public void  testValidLexiconVersion(LexiconDoc lexiconDoc) throws Exception{
> +            //Valid Lex Version
> +       ClientGenerator generator = new ClientGenerator();
> +       String generatedCode = generator.generateClient(lexiconDoc);
> +
> +           // --- Compilation and Reflection ---
> +           String className = lexiconDoc.getId().substring(lexiconDoc.getId().lastIndexOf('.') + 1) + "Client";
> +           Class<?> generatedClientClass = TestUtils.InMemoryCompiler.compile("com.example." + className, generatedCode);
> +           Object clientInstance = generatedClientClass.getDeclaredConstructor().newInstance();
> +
> +            // Inject mockXrpcClient
> +           java.lang.reflect.Field xrpcClientField = generatedClientClass.getDeclaredField("xrpcClient");
> +           xrpcClientField.setAccessible(true);
> +           xrpcClientField.set(clientInstance, mockXrpcClient);
> +
> +           when(mockXrpcClient.sendQuery

#### _User_

> /share 

-------

Exported this chat early due to massive hallucinating.