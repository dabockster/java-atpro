### [Continue](https://continue.dev) session transcript
 Exported: 3/23/2025, 8:32:05 PM

#### _Assistant_

> Always include the language and file name in the info string when you write code blocks, for example '```python file.py'.

#### _User_

> AT Protocol Reference Implementation (TypeScript) 
>  Welcome friends! 
>  This repository contains Bluesky's reference implementation of AT Protocol, and of the app.bsky microblogging application service backend. 
>  What is in here? 
>  TypeScript Packages: 
>  
>  
>  
>  Package 
>  Docs 
>  NPM 
>  
>  
>  
>  
>  @atproto/api : client library 
>  README 
>  
>  
>  
>  @atproto/common-web : shared code and helpers which can run in web browsers 
>  README 
>  
>  
>  
>  @atproto/common : shared code and helpers which doesn't work in web browsers 
>  README 
>  
>  
>  
>  @atproto/crypto : cryptographic signing and key serialization 
>  README 
>  
>  
>  
>  @atproto/identity : DID and handle resolution 
>  README 
>  
>  
>  
>  @atproto/lexicon : schema definition language 
>  README 
>  
>  
>  
>  @atproto/repo : data storage structure, including MST 
>  README 
>  
>  
>  
>  @atproto/syntax : string parsers for identifiers 
>  README 
>  
>  
>  
>  @atproto/xrpc : client-side HTTP API helpers 
>  README 
>  
>  
>  
>  @atproto/xrpc-server : server-side HTTP API helpers 
>  README 
>  
>  
>  
>  
>  TypeScript Services: 
>  
>  pds : "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in packages/pds , with runtime wrapper in services/pds . See bluesky-social/pds for directions on self-hosting in the federation sandbox network . 
>  bsky : AppView implementation of the app.bsky.* API endpoints. Running on main network at api.bsky.app . Most implementation code in packages/bsky , with runtime wrapper in services/bsky . 
>  
>  Lexicons: for both the com.atproto.* and app.bsky.* are canonically versioned in this repo, for now, under ./lexicons/ . These are JSON files in the Lexicon schema definition language , similar to JSON Schema or OpenAPI. 
>  Interoperability Test Data: the language-neutral test files in ./interop-test-files/ may be useful for other protocol implementations to ensure that they follow the specification correctly 
>  The source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Go programming language source code is in bluesky-social/indigo , including the BGS implementation. 
>  Developer Quickstart 
>  We recommend nvm for managing Node.js installs. This project requires Node.js version 18. pnpm is used to manage the workspace of multiple packages. You can install it with npm install --global pnpm . 
>  There is a Makefile which can help with basic development tasks: 
>  # use existing nvm to install node 18 and pnpm 
> make nvm-setup
>  # pull dependencies and build all local packages 
> make deps
> make build
>  # run the tests, using Docker services as needed 
> make test 
>  # run a local PDS and AppView with fake test accounts and data 
>  # (this requires a global installation of `jq` and `docker`) 
> make run-dev-env
>  # show all other commands 
> make help 
>  About AT Protocol 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  If submitting a PR that includes a lexicon change, please get sign off on the lexicon change before doing the implementation. 
>  Issues are for bugs &amp; feature requests related to the TypeScript implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or frameworks used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team, and we'll respond promptly. See SECURITY.md for more info. 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT.txt or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE.txt or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> AT Protocol Reference Implementation (TypeScript) 
>  Welcome friends! 
>  This repository contains Bluesky's reference implementation of AT Protocol, and of the app.bsky microblogging application service backend. 
>  What is in here? 
>  TypeScript Packages: 
>  TypeScript Services: 
>  
>  pds : "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in packages/pds , with runtime wrapper in services/pds . See bluesky-social/pds for directions on self-hosting. 
>  bsky : AppView implementation of the app.bsky.* API endpoints. Running on main network at api.bsky.app . Most implementation code in packages/bsky , with runtime wrapper in services/bsky . 
>  
>  Lexicons: for both the com.atproto.* and app.bsky.* are canonically versioned in this repo, for now, under ./lexicons/ . These are JSON files in the Lexicon schema definition language , similar to JSON Schema or OpenAPI. 
>  Interoperability Test Data: the language-neutral test files in ./interop-test-files/ may be useful for other protocol implementations to ensure that they follow the specification correctly 
>  The source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Go programming language source code is in bluesky-social/indigo , including the BGS implementation. 
>  Developer Quickstart 
>  We recommend nvm for managing Node.js installs. This project requires Node.js version 18. pnpm is used to manage the workspace of multiple packages. You can install it with npm install --global pnpm . 
>  There is a Makefile which can help with basic development tasks: 
>  # use existing nvm to install node 18 and pnpm 
> make nvm-setup
>  # pull dependencies and build all local packages 
> make deps
> make build
>  # run the tests, using Docker services as needed 
> make test 
>  # run a local PDS and AppView with fake test accounts and data 
>  # (this requires a global installation of `jq` and `docker`) 
> make run-dev-env
>  # show all other commands 
> make help 
>  About AT Protocol 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  If submitting a PR that includes a lexicon change, please get sign off on the lexicon change before doing the implementation. 
>  Issues are for bugs &amp; feature requests related to the TypeScript implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or frameworks used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team, and we'll respond promptly. See SECURITY.md for more info. 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT.txt or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE.txt or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> atproto-website 
>  This repository contains the documentation for the AT Protocol, available to read at atproto.com . 
>  To read documentation for the Bluesky API, go to docs.bsky.app or this repo . 
>  Making edits to atproto.com 
>  
>  clone this repo 
>  run npm install 
>  run the development server with npm run dev or yarn dev 
>  open http://localhost:3000 with your browser. 
>  
>  
>  pages/index.js generates http://localhost:3000 -- start there if you'd like to make changes. 
>  The page auto-updates as you edit the file. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  Documentation text and the atproto specifications are under Creative Commons Attribution (CC-BY). 
>  Inline code examples, example data, and regular expressions are under Creative Commons Zero (CC-0, aka Public Domain) and copy/pasted without attribution. 
>  Please see LICENSE.txt with reminders about derivative works, and LICENSE-CC-BY.txt for a copy of license legal text.
> 
> @atproto/repo: Repository and MST 
>  TypeScript library for atproto repositories, and in particular the Merkle Search Tree (MST) data structure. 
>  
>  
>  Repositories in atproto are signed key/value stores containing CBOR-encoded data records. The structure and implementation details are described in the specification . This includes MST node format, serialization, structural constraints, and more. 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT.txt or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE.txt or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> indigo: atproto libraries and services in golang 
>  Some Bluesky software is developed in Typescript, and lives in the bluesky-social/atproto repository. Some is developed in Go, and lives here. 
>  What is in here? 
>  Go Services: 
>  
>  bigsky ( README ): "Big Graph Service" (BGS) reference implementation, running at bsky.network 
>  palomar ( README ): fulltext search service for https://bsky.app 
>  
>  Go Packages: 
>  
>  All the packages in this repository are under active development. Features and software interfaces have not stabilized and may break or be removed. 
>  
>  
>  
>  
>  Package 
>  Docs 
>  
>  
>  
>  
>  api/atproto : generated types for com.atproto.* Lexicons 
>  
>  
>  
>  api/bsky : generated types for app.bsky.* Lexicons 
>  
>  
>  
>  atproto/crypto : crytographic signing and key serialization 
>  
>  
>  
>  atproto/identity : DID and handle resolution 
>  
>  
>  
>  atproto/syntax : string types and parsers for identifiers 
>  
>  
>  
>  mst : Merkle Search Tree implementation 
>  
>  
>  
>  repo : account data storage 
>  
>  
>  
>  xrpc : HTTP API client 
>  
>  
>  
>  
>  The TypeScript reference implementation, including PDS and bsky AppView services, is at bluesky-social/atproto . Source code for the Bluesky Social client app (for web and mobile) can be found at bluesky-social/social-app . 
>  Development Quickstart 
>  First, you will need the Go toolchain installed. We develop using the latest stable version of the language. 
>  The Makefile provides wrapper commands for basic development: 
>  make build
> make test
> make fmt
> make lint
>  
>  Individual commands can be run like: 
>  The HACKING file has a list of commands and packages in this repository and some other development tips. 
>  What is atproto? 
>  not to be confused with the AT command set or Adenosine triphosphate 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBC . Learn more at: 
>  
>  Overview and Guides 👈 Best starting point 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We do not provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one, please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  Issues are for bugs &amp; feature requests related to the golang implementation of atproto and related services.
>  
>  For high-level discussions, please use the Discussion Forum . 
>  For client issues, please use the relevant social-app repo. 
>  
>  
>  Stay away from PRs that:
>  
>  Refactor large parts of the codebase 
>  Add entirely new features without prior discussion 
>  Change the tooling or libraries used without prior discussion 
>  Introduce new unnecessary dependencies 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> indigo: golang code for Bluesky's atproto services 
>  Some Bluesky software is developed in Typescript, and lives in the bluesky-social/atproto repository. Some is developed in Go, and lives here. 
>  
>  Everything in this repository is an work in progress. Features and "Lexicons" may be removed or updated, software interfaces broken, etc. 
>  We are developing in the open, but not ready to accept or review significant contributions. Keep checking back! 
>  
>  What is atproto? 
>  not to be confused with the AT command set or Adenosine triphosphate 
>  The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by Bluesky PBLLC . Learn more at: 
>  
>  Protocol Documentation 
>  Overview Guide 👈 Good place to start 
>  Blogpost on self-authenticating data structures 
>  
>  Development 
>  First, you will need the Go toolchain installed. We develop using the latest stable version of the language. 
>  The Makefile provides wrapper commands for basic development: 
>  make build
> make test
> make fmt
> make lint
>  
>  Individual commands can be run like:
> 
> AT Protocol OpenAPI Types 
>  This repository contains OpenAPI types for the AT Protocol. They are generated
> according to the AT Protocol Specification 
> by converting/translating the lexicon specs into OpenAPI types. 
>  My hope is for this repository to serve as a live representation of the current
> state of the AT Protocol viewed through the lens of OpenAPI. This could enable
> the generation of client and server code for the AT Protocol in a variety of
> languages. 
>  How to use 
>  I want to see what it looks like 
>  A Swagger UI instance prepopulated with the current version of the OpenAPI types is available to preview .
> You can create a session (use an app password!), input your authentication token
> and experiment with authenticated queries. 
>  I want the types 
>  All you need is the spec/api.json file! You can reference it directly at this
> URL: 
>  https://raw.githubusercontent.com/rdmurphy/atproto-openapi-types/main/spec/api.json 
>  
>  Note: The path to this file is subject to change, at least for a little
> while. I'll try my best to not move it but cannot pretend it won't happen
> while this project is still young! 
>  
>  This file is regenerated every two hours
>  via a GitHub Action to keep it up to date with
> the latest changes to the AT Protocol. It sources the
>  bluesky-social/atproto repository
> directly. 
>  I want to generate code 
>  You'll need to use the OpenAPI generator of your choice. I've had luck with
>  openapi-typescript ! 
>  I want to generate the types locally 
>  You'll need to checkout this repository and
>  make sure Deno is installed .
> You'll also need to checkout a copy of the
>  bluesky-social/atproto repository
>  into this repo's directory. (Maybe one day I'll get fancy and set up
> submodules... but not today.) 
>  Then, run the following command: 
>  If you'd like to tweak the generator and see your changes live you can run the
> following command. It will watch for changes and re-run the script any time a
> file is updated: 
>  Known limitations 
>  It's currently not possible to represent the subscription type in OpenAPI. It
> appears the maintainers of the specification
>  have passed on the inclusion of any interfaces that are not strictly scoped to the HTTP protocol .
> (WebSockets are opened via a HTTP request, but I digress.)
>  AsyncAPI may be a better fit for this use case. 
>  Existing implementations 
>  
>  Bluesky-OpenAPI : Another AT
> Protocol to OpenAPI conversion by @trozzelle .
> It takes a slightly different approach to naming the schemas you may prefer! 
>  
>  License 
>  MIT
> 
> Bluesky Social App 
>  Welcome friends! This is the codebase for the Bluesky Social app. 
>  Get the app itself: 
>  
>  Web: bsky.app 
>  iOS: App Store 
>  Android: Play Store 
>  
>  Development Resources 
>  This is a React Native application, written in the TypeScript programming language. It builds on the atproto TypeScript packages (like @atproto/api ), code for which is also on open source, but in a different git repository . 
>  There is a small amount of Go language source code (in ./bskyweb/ ), for a web service that returns the React Native Web application. 
>  The Build Instructions are a good place to get started with the app itself. 
>  The Authenticated Transfer Protocol ("AT Protocol" or "atproto") is a decentralized social media protocol. You don't need to understand AT Protocol to work with this application, but it can help. Learn more at: 
>  
>  Overview and Guides 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We're not going to provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  Stay away from PRs like...
>  
>  Changing "Post" to "Skeet." 
>  Refactoring the codebase, eg to replace mobx with redux or something. 
>  Adding entirely new features without prior discussion. 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day to day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. That's what forking is for! 
>  Forking guidelines 
>  You have our blessing 🪄✨ to fork this application! However, it's very important to be clear to users when you're giving them a fork. 
>  Please be sure to: 
>  
>  Change all branding in the repository and UI to clearly differentiate from Bluesky. 
>  Change any support links (feedback, email, terms of service, etc) to your own systems. 
>  Replace any analytics or error-collection systems with your own so we don't get super confused. 
>  
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team and we'll respond promptly. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License (MIT) 
>  See ./LICENSE for the full license. 
>  P.S. 
>  We ❤️ you and all of the ways you support us. Thank you for making Bluesky a great place!
> 
> AT Protocol implementation in Python 
>  This is just starting, as I begin to grok Bluesky and the AT Protocol.
> I'm releasing it super early for educational purposes only. 
>  Set environment variables BLUESKY_IDENTIFIER and BLUESKY_PASSWORD to run demo.py .
> The password should be an App Password , not your main password. 
>  
>  
>  atproto.py basic client library for accessing the Bluesky PDS. 
>  
>  
>  utils.py basic util functions 
>  
>  
>  lexicon.py work-in-progress module for dealing with lexicon files 
>  
>  
>  demo.py runnable script trying things out 
>  
>  
>  cli.py command-line interface 
>  
>  
>  followers.py quick script to list your followers (display name and handle) 
>  
>  
>  post.py quick script to post 
>  
>  
>  repos.py quick script to list repos 
>  
>  
>  What I've Tried 
>  com.atproto.admin 
>  Nothing yet. 
>  com.atproto.identity 
>  
>  resolveHandle 
>  
>  com.atproto.label 
>  Nothing yet. 
>  com.atproto.moderation 
>  Nothing yet. 
>  com.atproto.repo 
>  
>  describeRepo 
>  listRecords 
>  getRecord 
>  createRecord 
>  
>  com.atproto.server 
>  
>  describeServer 
>  createSession 
>  getAccountInviteCodes 
>  getSession 
>  
>  com.atproto.sync 
>  
>  listRepos 
>  
>  app.bsky.actor 
>  
>  getProfile 
>  
>  app.bsky.embed 
>  Nothing yet. 
>  app.bsky.feed 
>  
>  getPosts 
>  
>  Collections: 
>  
>  post 
>  
>  app.bsky.graph 
>  
>  getFollows 
>  getFollowers 
>  
>  Collections: 
>  
>  follow 
>  
>  app.bsky.notification 
>  Nothing yet. 
>  app.bsky.richtext 
>  Nothing yet. 
>  Changes to API since I first started 
>  
>  
>  new method app.bsky.feed.getPosts 
>  
>  
>  app.bsky.embed.record now included labels 
>  
>  
>  viewerState in app.bsky.actor.defs now has extra properties blockedBy (boolean) and blocking (at-uri) 
>  
>  
>  app.bsky.embed.record allows for embedded records to reference posts as blocked 
>  
>  
>  app.bsky.feed.getAuthorFeed can return a BlockedActor or BlockedByActor error 
>  
>  
>  app.bsky.feed.getPostThread allows for a reference to a blocked post and (via change to app.bsky.feed.defs ) parent and replies can also reference blocked posts 
>  
>  
>  there is a new record app.bsky.graph.block for blocks with subject (did) and createdAt (datetime) properties 
>  
>  
>  new method app.bsky.graph.getBlocks that returns who you are blocking (as an array of profileView s)
> 
> Bluesky Social App 
>  Welcome friends! This is the codebase for the Bluesky Social app. 
>  Get the app itself: 
>  
>  Web: bsky.app 
>  iOS: App Store 
>  Android: Play Store 
>  
>  Development Resources 
>  This is a React Native application, written in the TypeScript programming language. It builds on the atproto TypeScript packages (like @atproto/api ), code for which is also on open source, but in a different git repository . 
>  There is a small amount of Go language source code (in ./bskyweb/ ), for a web service that returns the React Native Web application. 
>  The Build Instructions are a good place to get started with the app itself. 
>  The Authenticated Transfer Protocol ("AT Protocol" or "atproto") is a decentralized social media protocol. You don't need to understand AT Protocol to work with this application, but it can help. Learn more at: 
>  
>  Overview and Guides 
>  Github Discussions 👈 Great place to ask questions 
>  Protocol Specifications 
>  Blogpost on self-authenticating data structures 
>  
>  The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is app.bsky.* . 
>  Contributions 
>  
>  While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review. 
>  
>  Rules: 
>  
>  We may not respond to your issue or PR. 
>  We may close an issue or PR without much feedback. 
>  We may lock discussions or contributions if our attention is getting DDOSed. 
>  We're not going to provide support for build issues. 
>  
>  Guidelines: 
>  
>  Check for existing issues before filing a new one please. 
>  Open an issue and give some time for discussion before submitting a PR. 
>  Stay away from PRs like...
>  
>  Changing "Post" to "Skeet." 
>  Refactoring the codebase, eg to replace mobx with redux or something. 
>  Adding entirely new features without prior discussion. 
>  
>  
>  
>  Remember, we serve a wide community of users. Our day to day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth. That's what forking is for! 
>  Forking guidelines 
>  You have our blessing 🪄✨ to fork this application! However, it's very important to be clear to users when you're giving them a fork. 
>  Please be sure to: 
>  
>  Change all branding in the repository and UI to clearly differentiate from Bluesky. 
>  Change any support links (feedback, email, terms of service, etc) to your own systems. 
>  Replace any analytics or error-collection systems with your own so we don't get super confused. 
>  
>  Security disclosures 
>  If you discover any security issues, please send an email to security@bsky.app . The email is automatically CCed to the entire team and we'll respond promptly. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  License (MIT) 
>  See ./LICENSE for the full license. 
>  P.S. 
>  We ❤️ you and all of the ways you support us. Thank you for making Bluesky a great place!
> 
> bsky-docs 
>  This repository contains developer documentation for the Bluesky API ( api.bsky.app ), which is available to read at docs.bsky.app . 
>  The atproto.com website, including the AT Protocol specifications, is versioned separately at https://github.com/bluesky-social/atproto-website . 
>  Docs Development 
>  This website is built using Docusaurus , a modern static website generator. 
>  For live-reloading development: 
>  
>  Clone this repo 
>  Run npm install 
>  Run the development server with npm start 
>  Open http://localhost:3000 with your browser. 
>  
>  To output a build: 
>  
>  run npm run build 
>  
>  This command generates static content into the build directory and can be served using any static contents hosting service. 
>  Generate OpenAPI to Docusaurus MDX 
>  We use a forked version of atproto-openapi-types to generate an OpenAPI schema from atproto lexicons. We use the docusaurus-openapi-docs plugin. 
>  To generate OpenAPI types from atproto lexicons: 
>  
>  Run deno task run to generate a fresh OpenAPI spec to atproto-openapi-types/spec/api.json . 
>  Run npx docusaurus-mdx-checker to see MDX compatibility. 
>  Run npm run docusaurus gen-api-docs &lt;id&gt; to generate MDX docs from an OpenAPI spec. In this case, npm run docusaurus gen-api-docs bskyApi . 
>  
>  If you want to regenerate MDX docs from an updated api.json file, run npm run clear-and-gen-api-docs . This command clears the existing docs and replaces them with freshly generated docs. 
>  The OpenAPI docs auto-update with the latest lexicon changes once a day. 
>  Are you a developer interested in building on atproto? 
>  Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more. 
>  If you're a developer interested in building on atproto, we'd love to email you a Bluesky invite code. Simply share your GitHub (or similar) profile with us via this form . 
>  License 
>  Documentation text is under Creative Commons Attribution (CC-BY). 
>  Inline code examples, example data, and regular expressions are under Creative Commons Zero (CC-0, aka Public Domain) and copy/pasted without attribution. 
>  Please see LICENSE.txt with reminders about derivative works, and LICENSE-CC-BY.txt for a copy of license legal text.
> 
> AT Protocol Ecosystem [Deprecated] 
>  This repository is no longer actively maintained. Visit our Community Projects page to view a list of projects and implementations in the AT Protocol ecosystem. 
>  You can open pull requests to submit/remove your project from the Community Projects page here . 
>  Disclaimer 
>  This list of third-party developer clients is provided for informational purposes only. These clients are not affiliated with the Bluesky PBLLC company, unless otherwise indicated, and we do not endorse or guarantee their performance or security. Users should be aware that logging in to their accounts through these third-party clients carries inherent risks, including the possibility of account compromise or data loss. It is important to only use third-party clients that are trusted and reputable. We strongly advise users to exercise caution and use these third-party clients at their own risk. Only log in to your account through a third-party client if you trust the developer and are confident in their ability to safeguard your account information. 
>  We are not responsible for any damage, loss, or unauthorized access to your account that may result from using these third-party clients. By using any of these clients, you acknowledge and accept these risks and limitations. 
>  Protocol Documentation 
>  
>  atproto.com 
>  
>  Protocol Implementations (Libraries) 
>  
>  atproto (Typescript): this is the leading protocol implementation, developed by Bluesky PBLLC 
>  indigo (Go): not stable 
>  adenosine (Rust): not stable 
>  atrium (Rust): new, not stable 
>  lexrpc (Python): not stable 
>  atprototools (Python): new, not stable 
>  atproto and bluesky (Dart) 
>  bskyrb (Ruby): new, not stable 
>  blue-pyinthe-sky (Python) new, not stable. Packaging it up into an installable module is a work in progress. 
>  bsky4j (Java): new, not stable 
>  blueRsky (R): R package. Not on CRAN yet but installable and functional. 
>  chitose (Python): new, not stable 
>  BlueSky.Net (.NET) new, WIP. Available to download in Nuget 
>  nanoatp (Python): new, not stable 
>  psychonaut (Python): async with Pydantic models for lexicon enforcement. WIP/unstable 
>  atproto (Python): new, not stable 
>  
>  Clients 
>  Web Clients 
>  
>  Bluesky (developed by Bluesky PBLLC):
>  
>  site: https://staging.bsky.app/ 
>  
>  
>  Flat:
>  
>  app: flat-bs.vercel.app 
>  repo: github.com/sabigara/flat 
>  
>  
>  Kite 🪁
>  
>  app: Kite 
>  repo: github.com/callmearta/kite 
>  
>  
>  Bsky
>  
>  app: bsky.syui.cf 
>  repo: github.com/syui/bsky-web 
>  
>  
>  Bsky Wrapper
>  
>  site: blue.amazingca.dev 
>  repo: https://github.com/Amazingca/BSKY-Wrapper 
>  
>  
>  Skylight
>  
>  site: https://penpenpng.github.io/skylight 
>  repo: https://github.com/penpenpng/skylight 
>  
>  
>  Skylight Bluesky Style
>  
>  site: https://skylight.louis-c-novel.com/#/ 
>  repo: https://github.com/louiscnovel2/skylight-bluesky-style 
>  
>  
>  Redsky
>  
>  site: https://redsky.pages.dev/ 
>  repo: https://github.com/akanoren/redsky 
>  
>  
>  TOKIMEKI Bluesky
>  
>  site: https://tokimekibluesky.vercel.app 
>  repo: https://github.com/spuithori/tokimekibluesky 
>  
>  
>  The Blue
>  
>  site: https://the-blue.shino3.net 
>  repo: https://github.com/ShinoharaTa/AozoraWebClient 
>  
>  
>  Klearsky
>  
>  site: https://klearsky.pages.dev/ 
>  repo: https://github.com/mimonelu/klearsky 
>  
>  
>  Skyline
>  
>  site: https://skyline.gay/ 
>  repo: https://github.com/louislva/skyline 
>  
>  
>  Firesky: Real-time Bluesky firehose
>  
>  site: https://firesky.tv 
>  
>  
>  Sunrise
>  
>  site: https://sunrise.li/ 
>  
>  
>  Connectsky (Web &amp; extension based ATProto Client)
>  
>  repo: https://github.com/Nester-xyz/Connectsky 
>  
>  
>  
>  Android Clients 
>  
>  Bluesky (developed by Bluesky PBLLC)
>  
>  app: Play Store 
>  site: bsky.app 
>  
>  
>  Seiun
>  
>  app: Google Play Store 
>  repo: https://github.com/akiomik/seiun 
>  
>  
>  Ozone
>  
>  app: 🚧 TBD 
>  repo: https://github.com/christiandeange/ozone 
>  
>  
>  
>  iOS Clients 
>  
>  Bluesky (developed by Bluesky PBLLC)
>  
>  app: App Store 
>  site: bsky.app 
>  
>  
>  Graysky
>  
>  app: App Store 
>  repo: bsky.app 
>  
>  
>  
>  MacOS Clients 
>  
>  swiftsky (Swift) 
>  Bluesky for Raycast : A Bluesky client for Raycast . 
>  
>  CLI Clients 
>  
>  adenosine-cli (Rust) 
>  gosky (Golang)(developed by Bluesky PBLLC) 
>  bsky (Golang) 
>  gomoderate (Golang) 
>  atr (Rust) 
>  bluesky_cli (Dart)
>  
>  repo: bluesky_cli 
>  site: pub.dev 
>  
>  
>  bluesky_ex (Elixir): new, not stable
>  
>  repo: bluesky_ex (Elixir): new, not stable 
>  site: hexdocs 
>  
>  
>  blue-sky-cli (Typescript) 
>  gokyuzu (Python) 
>  pBsky (Python-based BlueSky Client for the Linux Command Line) 
>  
>  Other Tools 
>  
>  twitter-to-bsky Import a Twitter archive into Bluesky. (may spam timeline!) 
>  bluesky-post A tool to post from GitHub Actions to Bluesky Social on your behalf.
>  
>  site: GitHub Marketplace 
>  
>  
>  Bsky Tooling – Cache and follow tons of repos and users.
>  
>  site: blue.amazingca.dev/tools 
>  repo: https://github.com/Amazingca/BSKY-Wrapper/blob/main/tools.html 
>  
>  
>  Bluestream: RSS feed generator for Bluesky.
>  
>  site: Bluestream 
>  repo: https://github.com/kawarimidoll/bluestream 
>  
>  
>  blueskyfirehose (Golang) Tool to view a firehose of all posts coming from bsky.social 
>  Bluesky Overhaul Browser extension that improves UX on the web app
>  
>  Chrome Web Store 
>  Mozilla Add-ons 
>  
>  
>  SkyLink A simple web extension that detects if the current website is connected to a Bluesky user.
>  
>  Chrome Web Store 
>  Mozilla Add-ons 
>  
>  
>  granary (Python, REST API) converts app.bsky objects to/from ActivityStreams, RSS, Atom, HTML, and more 
>  Bridgy Fed (Python) includes implementations of the AT Protocol Merkle search tree and com.atproto.sync 
>  bsky-link-preview : Generate an embeddable link preview for a Bluesky post. 
>  bluesky-esphome : Basic ESPHOME / ESP32 configuration to display Bluesky data. 
>  bluesky-api-client : (Java, REST API) Providing interesting methods(checking followers automatically) and helper methods for authentication, fetching likes list, timelines etc... 
>  socialweb/atproto-lexicon (PHP, Lexicon parser): Parses and resolves Lexicon schemas; useful for code generation and more. 
>  w3igg-crossposter : Tool used currently for web3isgoinggreat to x-post to Twitter, Mastodon, and Bluesky simultaneously
> 
> @atproto/pds: Personal Data Server (PDS) 
>  TypeScript reference implementation of an atproto PDS. 
>  
>  
>  If you are interested in self-hosting a PDS, you probably want this repository instead, which has a thin service wrapper, documentation, a Dockerfile, etc: https://github.com/bluesky-social/pds 
>  License 
>  This project is dual-licensed under MIT and Apache 2.0 terms: 
>  
>  MIT license ( LICENSE-MIT.txt or http://opensource.org/licenses/MIT ) 
>  Apache License, Version 2.0, ( LICENSE-APACHE.txt or http://www.apache.org/licenses/LICENSE-2.0 ) 
>  
>  Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> Skip to content 
>  
>  
>  
>  
>  Navigation Menu 
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Actions 
> Automate any workflow
>  
>  
>  
>  
>  
>  Packages 
> Host and manage packages
>  
>  
>  
>  
>  
>  Security 
> Find and fix vulnerabilities
>  
>  
>  
>  
>  
>  Codespaces 
> Instant dev environments
>  
>  
>  
>  
>  
>  GitHub Copilot 
> Write better code with AI
>  
>  
>  
>  
>  
>  Code review 
> Manage code changes
>  
>  
>  
>  
>  
>  Issues 
> Plan and track work
>  
>  
>  
>  
>  
>  Discussions 
> Collaborate outside of code
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  GitHub Sponsors 
> Fund open source developers
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  The ReadME Project 
> GitHub community articles
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  
>  Enterprise platform 
> AI-powered developer platform
>  
>  
>  
>  
>  
>  
>  Pricing 
>  
>  
>  
>  
>  
> Sign up
> 
> Bluesky Social is an upstart social network in the style of Twitter. However, "Bluesky" and the Bluesky client is just a proof of concept for what the Bluesky Team is really building - the AT Protocol. The AT Protocol, or "ATProto" for short, is an attempt to create a decentralized social network protocol that solves some of the problems that competitors like ActivityPub have - namely, account portability and a "big world" architecture that allows global aggregation. 
>  
>  AT Protocol is meant to stand for "Authenticated Transfer Protocol", but we all know that's just a backronym that Paul came up with. 
>  
>  What makes this so interesting it that the APIs used to build Bluesky are completely open! Anyone can build a Bluesky client, and the official client uses exactly the same APIs that Graysky or any other client uses. Even better, there's an NPM package called @atproto/api that provides a simple typesafe interface to the ATProto APIs. 
>  In this blog post, we're going to go through the process of building a super simple Bluesky client using the @atproto/api package. We'll be using Next.js for this tutorial, but you can use any framework you like - the @atproto/api package is framework agnostic. This tutorial will assume you have some familiarity with JavaScript. 
>  While you need an invite code to make a Bluesky account, you do not need an account to use a fair number of the ATProto APIs. Rather than connecting to a Personal Data Server, or PDS, you can connect directly to the "AppView", which does not need an account to view. 
>  
>  For a better understanding of these terms, check out the Federation Architecture Overview . 
>  
>  Getting started 
>  Let's make a new Next.js app: 
>  1 pnpm create next-app --tailwind --eslint --src-dir --ts --app --import-alias= "~/*" my-bsky-app 
>  
>  I'm using pnpm here, but you can use npm or yarn if you prefer. 
>  
>  Open up the project in your favorite editor, and let's get started! 
>  Setting up the API client 
>  The first thing we need to do is install the @atproto/api package. 
>  Before we do anything else, quickly remove all the garbage CSS that comes with the Next.js template by setting src/app/globals.css to the following: 
>  1 /* src/app/globals.css */ 2 @tailwind base; 3 @tailwind components; 4 @tailwind utilities; 
>  Next, let's make a new file called src/lib/api.ts and add the following code: 
>  1 // src/lib/api.ts 2 import { BskyAgent } from "@atproto/api" ; 3 4 export const agent = new BskyAgent ({ 5 // This is the AppView URL 6 service: "https://public.api.bsky.app" , 7 // If you were making an authenticated client, you would 8 // use the PDS URL here instead - the main one is bsky.social 9 // service: "https://bsky.social", 10 }); 
>  This is our API client we can use to make requests to the AppView. Let's make the homepage ( src/app/page.tsx ) list the top 10 custom feeds. 
>  1 // src/app/page.tsx 2 import { agent } from "~/lib/api" ; 3 4 export default async function Homepage () { 5 const feeds = await agent.app.bsky.unspecced. getPopularFeedGenerators ({ 6 limit: 10 , 7 }); 8 9 return ( 10 &lt; div className = "container mx-auto" &gt; 11 &lt; h1 className = "font-bold text-xl my-4" &gt; Top Feeds &lt;/ h1 &gt; 12 &lt; ul &gt; 13 { feeds . data . feeds . map (( feed ) =&gt; ( 14 &lt; li key = {feed.displayName} &gt; {feed.displayName} &lt;/ li &gt; 15 ))} 16 &lt;/ ul &gt; 17 &lt;/ div &gt; 18 ); 19 } 
>  If you run pnpm dev and go to http://localhost:3000 , you should see a list of the top 10 feeds on Bluesky! 
>  If it worked, congrats! You've made your first Bluesky client! If not, make sure you followed all the steps correctly. 
>  Viewing a post 
>  Let's make a new page that shows a post. For the time being, let's just hard-code the post URI. The post we will use is this one: 
>  1 const EXAMPLE_POST = 2 "at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3karfx5vrvv23" ; 
>  
>  This is an AT URI, composed of a DID (which are how users are uniquely identified), the type of record (in this case, a post), and the rkey of the post. We could also use the user's handle to identify the post, but that risks breaking things if the user changes their handle. DIDs are permanent, so they're a better choice. 
>  
>  We'll use app.bsky.feed.getPostThread to get the post and its replies. Let's just display the post author's name. 
>  1 // src/app/page.tsx 2 import { agent } from "~/lib/api" ; 3 4 const EXAMPLE_POST = 5 "at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3karfx5vrvv23" ; 6 7 export default function Homepage () { 8 const thread = await agent.app.bsky.feed. getPostThread ({ 9 uri: EXAMPLE_POST , 10 }) 11 12 return ( 13 &lt; div className = "container mx-auto" &gt; 14 &lt; p &gt; { thread.data.thread.post.author.displayName } &lt;/ p &gt; 15 &lt;/ div &gt; 16 ); 17 } 
>  Oh no! Type error! That's because the thread's main post might be deleted, or blocked. Let's fix this by checking what kind of view we're getting back, and error if it's been deleted or blocked. @atproto/api provides a handy set of type guards for this purpose. 
>  1 // src/app/page.tsx 2 import { AppBskyFeedDefs } from "@atproto/api" ; 3 4 import { agent } from "~/lib/api" ; 5 6 const EXAMPLE_POST = 7 "at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3karfx5vrvv23" ; 8 9 export default async function Homepage () { 10 const thread = await agent.app.bsky.feed. getPostThread ({ 11 uri: EXAMPLE_POST , 12 }); 13 14 if ( ! AppBskyFeedDefs. isThreadViewPost (thread.data.thread)) 15 throw new Error ( "Expected a thread view post" ); 16 17 return ( 18 &lt; div className = "container mx-auto" &gt; 19 &lt; p &gt; { thread.data.thread.post.author.displayName } &lt;/ p &gt; 20 &lt;/ div &gt; 21 ); 22 } 
>  Now we can see the post author's display name! Let's also display the post content. We'll need to use another type guard for the post content. While we're at it, let's also display author's handle, and avatar. 
>  1 // src/app/page.tsx 2 import { AppBskyFeedDefs, AppBskyFeedPost } from "@atproto/api" ; 3 4 import { agent } from "~/lib/api" ; 5 6 const EXAMPLE_POST = 7 "at://did:plc:vwzwgnygau7ed7b7wt5ux7y2/app.bsky.feed.post/3karfx5vrvv23" ; 8 9 export default async function Homepage () { 10 const thread = await agent.app.bsky.feed. getPostThread ({ 11 uri: EXAMPLE_POST , 12 }); 13 14 if ( ! AppBskyFeedDefs. isThreadViewPost (thread.data.thread)) 15 throw new Error ( "Expected a thread view post" ); 16 17 const post = thread.data.thread.post; 18 19 if ( ! AppBskyFeedPost. isRecord (post.record)) 20 throw new Error ( "Expected a post with a record" ); 21 22 return ( 23 &lt; div className = "grid min-h-screen place-items-center" &gt; 24 &lt; div className = "w-full max-w-sm" &gt; 25 &lt; div className = "flex flex-row items-center" &gt; 26 &lt; img 27 src ={ post.author.avatar } 28 alt ={ post.author.handle } 29 className = "h-12 w-12 rounded-full" 30 /&gt; 31 &lt; div className = "ml-4" &gt; 32 &lt; p className = "text-lg font-medium" &gt; { post.author.displayName } &lt;/ p &gt; 33 &lt; p &gt;@ { post.author.handle } &lt;/ p &gt; 34 &lt;/ div &gt; 35 &lt;/ div &gt; 36 &lt; div className = "mt-4" &gt; 37 &lt; p &gt; { post.record.text } &lt;/ p &gt; 38 &lt;/ div &gt; 39 &lt;/ div &gt; 40 &lt;/ div &gt; 41 ); 42 } 
>  You should now be able to see @retr0.id 's post! 
>  Viewing any post 
>  Let's now set up routing, so that we can view any post via the URL. The URL will be in the format /profile/:handle/post/:rkey . We'll take the two dynamic sections to construct the AT URI, and then use that to fetch the post thread like we did befire. Since we're using the Next.js App Routing, we'll need to make a folder structure like this: 
>  1 app 2 ├── layout.tsx 3 ├── page.tsx 4 └── profile 5 └── [handle] 6 └── post 7 └── [rkey] 8 └── page.tsx 
>  Let's then get these dynamic sections and use it to construct the AT URI. Make sure to decode params.handle - a DID contains : characters, which get URL encoded automatically. 
>  1 // src/app/profile/[handle]/post/[rkey]/page.tsx 2 3 interface Props { 4 params : { 5 handle : string ; 6 rkey : string ; 7 }; 8 } 9 10 export default function PostView ({ params } : Props) { 11 const uri = `at://${ decodeURIComponent ( params . handle )}/app.bsky.feed.post/${ 12 params . rkey 13 }` ; 14 15 return &lt; p &gt; { uri } &lt;/ p &gt;; 16 } 
>  Now, we can use this URI to get the post and display it. Copy paste the code from src/app/page.tsx into src/app/profile/[handle]/post/[rkey]/page.tsx , and replace EXAMPLE_POST with uri . 
>  1 // src/app/profile/[handle]/post/[rkey]/page.tsx 2 import { AppBskyFeedDefs, AppBskyFeedPost } from "@atproto/api" ; 3 4 import { agent } from "~/lib/api" ; 5 6 interface Props { 7 params : { 8 handle : string ; 9 rkey : string ; 10 }; 11 } 12 13 export default async function PostView ({ params } : Props) { 14 const uri = `at://${ decodeURIComponent ( params . handle )}/app.bsky.feed.post/${ 15 params . rkey 16 }` ; 17 18 const thread = await agent.app.bsky.feed. getPostThread ({ uri }); 19 20 if ( ! AppBskyFeedDefs. isThreadViewPost (thread.data.thread)) 21 throw new Error ( "Expected a thread view post" ); 22 23 const post = thread.data.thread.post; 24 25 if ( ! AppBskyFeedPost. isRecord (post.record)) 26 throw new Error ( "Expected a post with a record" ); 27 28 return ( 29 &lt; div className = "grid min-h-screen place-items-center" &gt; 30 &lt; div className = "w-full max-w-sm" &gt; 31 &lt; div className = "flex flex-row items-center" &gt; 32 &lt; img 33 src ={ post.author.avatar } 34 alt ={ post.author.handle } 35 className = "h-12 w-12 rounded-full" 36 /&gt; 37 &lt; div className = "ml-4" &gt; 38 &lt; p className = "text-lg font-medium" &gt; { post.author.displayName } &lt;/ p &gt; 39 &lt; p &gt;@ { post.author.handle } &lt;/ p &gt; 40 &lt;/ div &gt; 41 &lt;/ div &gt; 42 &lt; div className = "mt-4" &gt; 43 &lt; p &gt; { post.record.text } &lt;/ p &gt; 44 &lt;/ div &gt; 45 &lt;/ div &gt; 46 &lt;/ div &gt; 47 ); 48 } 
>  Now, if you go to http://localhost:3000/profile/did:plc:vwzwgnygau7ed7b7wt5ux7y2/post/3karfx5vrvv23 , you should see the same post as before! 
>  Here are some other posts you can look at: 
>  
>  http://localhost:3000/profile/did:plc:iwr4qf7c7ew7nm5l26ful6uo/post/3k7a3sxclmb2w 
>  http://localhost:3000/profile/did:plc:fpruhuo22xkm5o7ttr2ktxdo/post/3k27cy5if2m2o 
>  http://localhost:3000/profile/did:plc:oky5czdrnfjpqslsw2a5iclo/post/3jxvznajs7m2h 
>  
>  
>  If you want to be able to use a handle as well as a DID, as the official app does, check to see if param.handle starts with did: , and if not, use agent.resolveHandle({ handle: param.handle }) to get the DID of the user. 
>  
>  Next steps 
>  Now that you've got a basic client up and running, you can start to build out more features. Here are some ideas: 
>  Make a &lt;Post /&gt; component 
>  There are loads of things in the post that we're not displaying, such as the number of likes, reposts, and replies, the timestamp, and any embeds the post might have. Take what we have already and make a reusable post component! It should take a post prop with the type AppBskyFeedDefs.PostView . 
>  Embeds 
>  There are 4 types of embeds - images, external link, record (a.k.a a quote post), or a record + the other two types. Use type guards to differentiate between them, and display them accordingly. 
>  Rich text 
>  Posts can have mentions, hyperlinks, and hashtags, using "facets" to indicate what part of the source text has extra information. Use the RichText helper to help display these. Here's a rough guide on how you'd use it: 
>  1 import { RichText } from "@atproto/api" ; 2 3 const rt = new RichText ({ 4 text: post.record.text, 5 facets: post.record.facets, 6 }); 7 8 const text = []; 9 10 for ( const segment of rt. segments ()) { 11 if (segment. isMention ()) { 12 text. push ( 13 &lt; a className = "text-blue-500" href ={ `/profile/${ segment . mention ?. did }` } &gt; 14 { segment.text } 15 &lt;/ a &gt;, 16 ); 17 } else if (segment. isLink ()) { 18 text. push ( 19 &lt; a className = "text-blue-500" href ={ segment.link?.uri } &gt; 20 { segment.text } 21 &lt;/ a &gt;, 22 ); 23 } else if (segment. isTag ()) { 24 text. push (&lt; span className = "text-blue-500" &gt; { segment.text } &lt;/ span &gt;); 25 } else { 26 text. push (segment.text); 27 } 28 } 
>  A little tricker, but agent.getPostThread() returns all the post's replies in a recursive data structure. You can use this to display the replies to a post. Same applies to a post's parents, if it itself is a reply. Link them all together to let you browse through a thread! 
>  View a user's profile 
>  You can view a user's profile using agent.getProfile() , and see a user's posts using agent.getActorFeed() . 
>  View a custom feed 
>  Using the list of feeds we made in the beginning, you could could link to each respective feed and display the posts, using agent.app.bsky.feed.getFeed({ feed: feed.uri }) . You can add infinite scrolling to this by using the cursor . 
>  
>  Pro tip: @tanstack/react-query makes this 100x easier to manage! 
>  
>  Logging in 
>  Use https://bsky.social when making the session agent, and use agent.login() to log in. This unlocks the rest of the APIs - you can like posts and follow people, for example. Then then sky's the limit - you can do anything the official app can do, and more! 
>  Conclusion 
>  I hope this tutorial has been helpful! If you have any questions, feel free to ask on Bluesky . If you want to see the full code, you can find it on GitHub . You can also see this app live here . 
>  If you want to see how a full-featured third-party client works, check out Graysky on GitHub ! 
>  Happy hacking! 
>  - Samuel ( @mozzius.dev )
> 
> ## Welcome to the Atmosphere
> 
> The AT Protocol is an open, decentralized network for building social applications.
> 
> ### Quickstart
> 
> Create an application and start building.
> 
> [Read more](/guides/applications)
> 
> ### Self-host
> 
> Learn how to set up your own personal data server.
> 
> [Read more](/guides/self-hosting)
> 
> ### Glossary
> 
> Definitions for all the terminology used in AT Protocol.
> 
> [Read more](/guides/glossary)
> 
> ### FAQ
> 
> Frequently Asked Questions about the Atmosphere.
> 
> [Read more](/guides/faq)
> 
> ### [Repository](/specs/repository)
> 
> Self-authenticating storage for public account content.
> 
> ### [Lexicon](/specs/lexicon)
> 
> A schema definition language for ATProto.
> 
> ### [URI Scheme](/specs/at-uri-scheme)
> 
> A URI scheme for addressing ATProto repository data.
> 
> Guide
> 
> What's a PDS? an AppView? a DID? If you're feeling a little bowled over by new concepts, give this glossary a look.
> 
> [Keep reading](/guides/glossary)
> 
> Guide
> 
> In this guide, we build a simple multi-user app that publishes your current "status" as an emoji.
> 
> [Keep reading](/guides/applications)
> 
> Article
> 
> In this article we explore AT Proto from the perspective of distributed backend engineering.
> 
> [Keep reading](/articles/atproto-for-distsys-engineers)
> 
> Guide
> 
> This guide will introduce you to Lexicon and get you started with building your own schemas.
> 
> [Keep reading](/guides/lexicon)
> 
> Go to [docs.bsky.app](https://docs.bsky.app/) for Bluesky-specific documentation.
> 
> ## AT Protocol Reference Implementation (TypeScript)
> 
> [](#at-protocol-reference-implementation-typescript)
> 
> Welcome friends!
> 
> This repository contains Bluesky's reference implementation of AT Protocol, and of the `app.bsky` microblogging application service backend.
> 
> ## What is in here?
> 
> [](#what-is-in-here)
> 
> **TypeScript Packages:**
> 
> | Package                                                                     | Docs                                                                       | NPM                                                                                                                                                                                                                                                                  |
> | --------------------------------------------------------------------------- | -------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
> | @atproto/api: client library                                                | [README](/bluesky-social/atproto/blob/main/packages/api/README.md)         | [![NPM](https://camo.githubusercontent.com/6327031e34807d5a06ce855d6d0e41383d3b6078e86dfad37d05b27db130ec99/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f617069)](https://www.npmjs.com/package/@atproto/api)                         |
> | @atproto/common-web: shared code and helpers which can run in web browsers  | [README](/bluesky-social/atproto/blob/main/packages/common-web/README.md)  | [![NPM](https://camo.githubusercontent.com/70d89e009507817dbf8da9d1c540817ee9b40f2a771b4aa9de10e0b9ce93ff56/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f636f6d6d6f6e2d776562)](https://www.npmjs.com/package/@atproto/common-web)    |
> | @atproto/common: shared code and helpers which doesn't work in web browsers | [README](/bluesky-social/atproto/blob/main/packages/common/README.md)      | [![NPM](https://camo.githubusercontent.com/a4254843e8a1ea731e231d395ce7dd3189e5eaf9456d456fd1cb73e0a7441435/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f636f6d6d6f6e)](https://www.npmjs.com/package/@atproto/common)                |
> | @atproto/crypto: cryptographic signing and key serialization                | [README](/bluesky-social/atproto/blob/main/packages/crypto/README.md)      | [![NPM](https://camo.githubusercontent.com/925a4f571cce4e38c30a609a50bbe95dadaceb69f57e823e2999b578a30d701b/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f63727970746f)](https://www.npmjs.com/package/@atproto/crypto)                |
> | @atproto/identity: DID and handle resolution                                | [README](/bluesky-social/atproto/blob/main/packages/identity/README.md)    | [![NPM](https://camo.githubusercontent.com/ad1ac05d36585c99e31447f39c8dabc228e2e417345330a19e7fdb151f79ee8f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f6964656e74697479)](https://www.npmjs.com/package/@atproto/identity)          |
> | @atproto/lexicon: schema definition language                                | [README](/bluesky-social/atproto/blob/main/packages/lexicon/README.md)     | [![NPM](https://camo.githubusercontent.com/e9cbd3c2860d659dc6459b84232144765ab12870470f36e2c916b462a81957b0/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f6c657869636f6e)](https://www.npmjs.com/package/@atproto/lexicon)             |
> | @atproto/repo: data storage structure, including MST                        | [README](/bluesky-social/atproto/blob/main/packages/repo/README.md)        | [![NPM](https://camo.githubusercontent.com/539b08001d75662650ad8e13e2c7d3a0b3d01e8f9de005e7e549f79757794e26/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f7265706f)](https://www.npmjs.com/package/@atproto/repo)                      |
> | @atproto/syntax: string parsers for identifiers                             | [README](/bluesky-social/atproto/blob/main/packages/syntax/README.md)      | [![NPM](https://camo.githubusercontent.com/21be3b53af18c9b5378e9bf17c2cf477fa9a87efa0a2bfdc510e8513f58c7902/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f73796e746178)](https://www.npmjs.com/package/@atproto/syntax)                |
> | @atproto/xrpc: client-side HTTP API helpers                                 | [README](/bluesky-social/atproto/blob/main/packages/xrpc/README.md)        | [![NPM](https://camo.githubusercontent.com/c34b17f0a5b255f0951a320171f339cdfcb4a520329f0bef5b787ec65a1f2f0f/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f78727063)](https://www.npmjs.com/package/@atproto/xrpc)                      |
> | @atproto/xrpc-server: server-side HTTP API helpers                          | [README](/bluesky-social/atproto/blob/main/packages/xrpc-server/README.md) | [![NPM](https://camo.githubusercontent.com/4519890d16577ab0840d6975df83df18ea39e63ee6963eb2f71df9951d435d65/68747470733a2f2f696d672e736869656c64732e696f2f6e706d2f762f40617470726f746f2f787270632d736572766572)](https://www.npmjs.com/package/@atproto/xrpc-server) |
> 
> **TypeScript Services:**
> 
> * `pds`: "Personal Data Server", hosting repo content for atproto accounts. Most implementation code in `packages/pds`, with runtime wrapper in `services/pds`. See [bluesky-social/pds](https://github.com/bluesky-social/pds) for directions on self-hosting.
> * `bsky`: AppView implementation of the `app.bsky.*` API endpoints. Running on main network at `api.bsky.app`. Most implementation code in `packages/bsky`, with runtime wrapper in `services/bsky`.
> 
> **Lexicons:** for both the `com.atproto.*` and `app.bsky.*` are canonically versioned in this repo, for now, under `./lexicons/`. These are JSON files in the [Lexicon schema definition language](https://atproto.com/specs/lexicon), similar to JSON Schema or OpenAPI.
> 
> **Interoperability Test Data:** the language-neutral test files in `./interop-test-files/` may be useful for other protocol implementations to ensure that they follow the specification correctly
> 
> The source code for the Bluesky Social client app (for web and mobile) can be found at [bluesky-social/social-app](https://github.com/bluesky-social/social-app).
> 
> Go programming language source code is in [bluesky-social/indigo](https://github.com/bluesky-social/indigo), including the BGS implementation.
> 
> ## Developer Quickstart
> 
> [](#developer-quickstart)
> 
> We recommend [nvm](https://github.com/nvm-sh/nvm) for managing Node.js installs. This project requires Node.js version 18\. `pnpm` is used to manage the workspace of multiple packages. You can install it with `npm install --global pnpm`.
> 
> There is a Makefile which can help with basic development tasks:
> 
> # use existing nvm to install node 18 and pnpm
> make nvm-setup
> 
> # pull dependencies and build all local packages
> make deps
> make build
> 
> # run the tests, using Docker services as needed
> make test
> 
> # run a local PDS and AppView with fake test accounts and data
> # (this requires a global installation of `jq` and `docker`)
> make run-dev-env
> 
> # show all other commands
> make help
> 
> ## About AT Protocol
> 
> [](#about-at-protocol)
> 
> The Authenticated Transfer Protocol ("ATP" or "atproto") is a decentralized social media protocol, developed by [Bluesky PBC](https://bsky.social/). Learn more at:
> 
> * [Overview and Guides](https://atproto.com/guides/overview) 👈 Best starting point
> * [Github Discussions](https://github.com/bluesky-social/atproto/discussions) 👈 Great place to ask questions
> * [Protocol Specifications](https://atproto.com/specs/atp)
> * [Blogpost on self-authenticating data structures](https://bsky.social/about/blog/3-6-2022-a-self-authenticating-social-protocol)
> 
> The Bluesky Social application encompasses a set of schemas and APIs built in the overall AT Protocol framework. The namespace for these "Lexicons" is `app.bsky.*`.
> 
> ## Contributions
> 
> [](#contributions)
> 
> > While we do accept contributions, we prioritize high quality issues and pull requests. Adhering to the below guidelines will ensure a more timely review.
> 
> **Rules:**
> 
> * We may not respond to your issue or PR.
> * We may close an issue or PR without much feedback.
> * We may lock discussions or contributions if our attention is getting DDOSed.
> * We do not provide support for build issues.
> 
> **Guidelines:**
> 
> * Check for existing issues before filing a new one, please.
> * Open an issue and give some time for discussion before submitting a PR.
> * If submitting a PR that includes a lexicon change, please get sign off on the lexicon change _before_ doing the implementation.
> * Issues are for bugs & feature requests related to the TypeScript implementation of atproto and related services.  
>    * For high-level discussions, please use the [Discussion Forum](https://github.com/bluesky-social/atproto/discussions).  
>    * For client issues, please use the relevant [social-app](https://github.com/bluesky-social/social-app) repo.
> * Stay away from PRs that:  
>    * Refactor large parts of the codebase  
>    * Add entirely new features without prior discussion  
>    * Change the tooling or frameworks used without prior discussion  
>    * Introduce new unnecessary dependencies
> 
> Remember, we serve a wide community of users. Our day-to-day involves us constantly asking "which top priority is our top priority." If you submit well-written PRs that solve problems concisely, that's an awesome contribution. Otherwise, as much as we'd love to accept your ideas and contributions, we really don't have the bandwidth.
> 
> ## Are you a developer interested in building on atproto?
> 
> [](#are-you-a-developer-interested-in-building-on-atproto)
> 
> Bluesky is an open social network built on the AT Protocol, a flexible technology that will never lock developers out of the ecosystems that they help build. With atproto, third-party can be as seamless as first-party through custom feeds, federated services, clients, and more.
> 
> ## Security disclosures
> 
> [](#security-disclosures)
> 
> If you discover any security issues, please send an email to [security@bsky.app](mailto:security@bsky.app). The email is automatically CCed to the entire team, and we'll respond promptly. See [SECURITY.md](https://github.com/bluesky-social/atproto/blob/main/SECURITY.md) for more info.
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> ## ATP API
> 
> [](#atp-api)
> 
> This API is a client for ATProtocol servers. It communicates using HTTP. It includes:
> 
> * ✔️ APIs for ATProto and Bluesky.
> * ✔️ Validation and complete typescript types.
> * ✔️ Session management.
> * ✔️ A RichText library.
> 
> ## Getting started
> 
> [](#getting-started)
> 
> First install the package:
> 
> Then in your application:
> 
> import { AtpAgent } from '@atproto/api'
> 
> const agent = new AtpAgent({ service: 'https://example.com' })
> 
> ## Usage
> 
> [](#usage)
> 
> ### Session management
> 
> [](#session-management)
> 
> You'll need an authenticated session for most API calls. There are two ways to manage sessions:
> 
> 1. [App password based session management](#app-password-based-session-management)
> 2. [OAuth based session management](#oauth-based-session-management)
> 
> #### App password based session management
> 
> [](#app-password-based-session-management)
> 
> Username / password based authentication can be performed using the `AtpAgent`class.
> 
> Caution
> 
> This method is deprecated in favor of OAuth based session management. It is recommended to use OAuth based session management (through the`@atproto/oauth-client-*` packages).
> 
> import { AtpAgent, AtpSessionEvent, AtpSessionData } from '@atproto/api'
> 
> // configure connection to the server, without account authentication
> const agent = new AtpAgent({
>   service: 'https://example.com',
>   persistSession: (evt: AtpSessionEvent, sess?: AtpSessionData) => {
>     // store the session-data for reuse
>   },
> })
> 
> // Change the agent state to an authenticated state either by:
> 
> // 1) creating a new account on the server.
> await agent.createAccount({
>   email: 'alice@mail.com',
>   password: 'hunter2',
>   handle: 'alice.example.com',
>   inviteCode: 'some-code-12345-abcde',
> })
> 
> // 2) if an existing session was securely stored previously, then reuse that to resume the session.
> await agent.resumeSession(savedSessionData)
> 
> // 3) if no old session was available, create a new one by logging in with password (App Password)
> await agent.login({
>   identifier: 'alice@mail.com',
>   password: 'hunter2',
> })
> 
> #### OAuth based session management
> 
> [](#oauth-based-session-management)
> 
> Depending on the environment used by your application, different OAuth clients are available:
> 
> * [@atproto/oauth-client-browser](https://www.npmjs.com/package/@atproto/oauth-client-browser): for the browser.
> * [@atproto/oauth-client-node](https://www.npmjs.com/package/@atproto/oauth-client-node): for Node.js.
> * [@atproto/oauth-client](https://www.npmjs.com/package/@atproto/oauth-client): Lower level; compatible with most JS engines.
> 
> Every `@atproto/oauth-client-*` implementation has a different way to obtain an`OAuthSession` instance that can be used to instantiate an `Agent` (from`@atproto/api`). Here is an example restoring a previously saved session:
> 
> import { Agent } from '@atproto/api'
> import { OAuthClient } from '@atproto/oauth-client'
> 
> const oauthClient = new OAuthClient({
>   // ...
> })
> 
> const oauthSession = await oauthClient.restore('did:plc:123')
> 
> // Instantiate the api Agent using an OAuthSession
> const agent = new Agent(oauthSession)
> 
> ### API calls
> 
> [](#api-calls)
> 
> The agent includes methods for many common operations, including:
> 
> // The DID of the user currently authenticated (or undefined)
> agent.did
> agent.accountDid // Throws if the user is not authenticated
> 
> // Feeds and content
> await agent.getTimeline(params, opts)
> await agent.getAuthorFeed(params, opts)
> await agent.getPostThread(params, opts)
> await agent.getPost(params)
> await agent.getPosts(params, opts)
> await agent.getLikes(params, opts)
> await agent.getRepostedBy(params, opts)
> await agent.post(record)
> await agent.deletePost(postUri)
> await agent.like(uri, cid)
> await agent.deleteLike(likeUri)
> await agent.repost(uri, cid)
> await agent.deleteRepost(repostUri)
> await agent.uploadBlob(data, opts)
> 
> // Social graph
> await agent.getFollows(params, opts)
> await agent.getFollowers(params, opts)
> await agent.follow(did)
> await agent.deleteFollow(followUri)
> 
> // Actors
> await agent.getProfile(params, opts)
> await agent.upsertProfile(updateFn)
> await agent.getProfiles(params, opts)
> await agent.getSuggestions(params, opts)
> await agent.searchActors(params, opts)
> await agent.searchActorsTypeahead(params, opts)
> await agent.mute(did)
> await agent.unmute(did)
> await agent.muteModList(listUri)
> await agent.unmuteModList(listUri)
> await agent.blockModList(listUri)
> await agent.unblockModList(listUri)
> 
> // Notifications
> await agent.listNotifications(params, opts)
> await agent.countUnreadNotifications(params, opts)
> await agent.updateSeenNotifications()
> 
> // Identity
> await agent.resolveHandle(params, opts)
> await agent.updateHandle(params, opts)
> 
> // Legacy: Session management should be performed through the SessionManager
> // rather than the Agent instance.
> if (agent instanceof AtpAgent) {
>   // AtpAgent instances support using different sessions during their lifetime
>   await agent.createAccount({ ... }) // session a
>   await agent.login({ ... }) // session b
>   await agent.resumeSession(savedSession) // session c
> }
> 
> ### Validation and types
> 
> [](#validation-and-types)
> 
> The package includes a complete types system which includes validation and type-guards. For example, to validate a post record:
> 
> import { AppBskyFeedPost } from '@atproto/api'
> 
> const post = {...}
> if (AppBskyFeedPost.isRecord(post)) {
>   // typescript now recognizes `post` as a AppBskyFeedPost.Record
>   // however -- we still need to validate it
>   const res = AppBskyFeedPost.validateRecord(post)
>   if (res.success) {
>     // a valid record
>   } else {
>     // something is wrong
>     console.log(res.error)
>   }
> }
> 
> ### Rich text
> 
> [](#rich-text)
> 
> Some records (ie posts) use the `app.bsky.richtext` lexicon. At the moment richtext is only used for links and mentions, but it will be extended over time to include bold, italic, and so on.
> 
> ℹ️ It is **strongly** recommended to use this package's `RichText` library. Javascript encodes strings in utf16 while the protocol (and most other programming environments) use utf8\. Converting between the two is challenging, but `RichText` handles that for you.
> 
> import { RichText } from '@atproto/api'
> 
> // creating richtext
> const rt = new RichText({
>   text: 'Hello @alice.com, check out this link: https://example.com',
> })
> await rt.detectFacets(agent) // automatically detects mentions and links
> const postRecord = {
>   $type: 'app.bsky.feed.post',
>   text: rt.text,
>   facets: rt.facets,
>   createdAt: new Date().toISOString(),
> }
> 
> // rendering as markdown
> let markdown = ''
> for (const segment of rt.segments()) {
>   if (segment.isLink()) {
>     markdown += `[${segment.text}](${segment.link?.uri})`
>   } else if (segment.isMention()) {
>     markdown += `[${segment.text}](https://my-bsky-app.com/user/${segment.mention?.did})`
>   } else {
>     markdown += segment.text
>   }
> }
> 
> // calculating string lengths
> const rt2 = new RichText({ text: 'Hello' })
> console.log(rt2.length) // => 5
> console.log(rt2.graphemeLength) // => 5
> const rt3 = new RichText({ text: '👨‍👩‍👧‍👧' })
> console.log(rt3.length) // => 25
> console.log(rt3.graphemeLength) // => 1
> 
> ### Moderation
> 
> [](#moderation)
> 
> Applying the moderation system is a challenging task, but we've done our best to simplify it for you. The Moderation API helps handle a wide range of tasks, including:
> 
> * Moderator labeling
> * User muting (including mutelists)
> * User blocking
> * Mutewords
> * Hidden posts
> 
> For more information, see the [Moderation Documentation](/bluesky-social/atproto/blob/main/packages/api/docs/moderation.md).
> 
> import { moderatePost } from '@atproto/api'
> 
> // First get the user's moderation prefs and their label definitions
> // =
> 
> const prefs = await agent.getPreferences()
> const labelDefs = await agent.getLabelDefinitions(prefs)
> 
> // We call the appropriate moderation function for the content
> // =
> 
> const postMod = moderatePost(postView, {
>   userDid: agent.session.did,
>   moderationPrefs: prefs.moderationPrefs,
>   labelDefs,
> })
> 
> // We then use the output to decide how to affect rendering
> // =
> 
> // in feeds
> if (postMod.ui('contentList').filter) {
>   // don't include in feeds
> }
> if (postMod.ui('contentList').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentList').blurs to explain)
>   if (postMod.ui('contentList').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> if (postMod.ui('contentList').alert || postMod.ui('contentList').inform) {
>   // render warnings on the post
>   // find the warnings in postMod.ui('contentList').alerts and postMod.ui('contentList').informs
> }
> 
> // viewed directly
> if (postMod.ui('contentView').filter) {
>   // don't include in feeds
> }
> if (postMod.ui('contentView').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentView').blurs to explain)
>   if (postMod.ui('contentView').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> if (postMod.ui('contentView').alert || postMod.ui('contentView').inform) {
>   // render warnings on the post
>   // find the warnings in postMod.ui('contentView').alerts and postMod.ui('contentView').informs
> }
> 
> // post embeds in all contexts
> if (postMod.ui('contentMedia').blur) {
>   // render the whole object behind a cover (use postMod.ui('contentMedia').blurs to explain)
>   if (postMod.ui('contentMedia').noOverride) {
>     // do not allow the cover the be removed
>   }
> }
> 
> ## Advanced
> 
> [](#advanced)
> 
> ### Advanced API calls
> 
> [](#advanced-api-calls)
> 
> The methods above are convenience wrappers. It covers most but not all available methods.
> 
> The AT Protocol identifies methods and records with reverse-DNS names. You can use them on the agent as well:
> 
> const res1 = await agent.com.atproto.repo.createRecord({
>   did: alice.did,
>   collection: 'app.bsky.feed.post',
>   record: {
>     $type: 'app.bsky.feed.post',
>     text: 'Hello, world!',
>     createdAt: new Date().toISOString(),
>   },
> })
> const res2 = await agent.com.atproto.repo.listRecords({
>   repo: alice.did,
>   collection: 'app.bsky.feed.post',
> })
> 
> const res3 = await agent.app.bsky.feed.post.create(
>   { repo: alice.did },
>   {
>     text: 'Hello, world!',
>     createdAt: new Date().toISOString(),
>   },
> )
> const res4 = await agent.app.bsky.feed.post.list({ repo: alice.did })
> 
> ### Non-browser configuration
> 
> [](#non-browser-configuration)
> 
> If your environment doesn't have a built-in `fetch` implementation, you'll need to provide one. This will typically be done through a polyfill.
> 
> ### Bring your own fetch
> 
> [](#bring-your-own-fetch)
> 
> If you want to provide your own `fetch` implementation, you can do so by instantiating the sessionManager with a custom fetch implementation:
> 
> import { AtpAgent } from '@atproto/api'
> 
> const myFetch = (input: RequestInfo | URL, init?: RequestInit) => {
>   console.log('requesting', input)
>   const response = await globalThis.fetch(input, init)
>   console.log('got response', response)
>   return response
> }
> 
> const agent = new AtpAgent({
>   service: 'https://example.com',
>   fetch: myFetch,
> })
> 
> ## License
> 
> [](#license)
> 
> This project is dual-licensed under MIT and Apache 2.0 terms:
> 
> * MIT license ([LICENSE-MIT.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-MIT.txt) or <http://opensource.org/licenses/MIT>)
> * Apache License, Version 2.0, ([LICENSE-APACHE.txt](https://github.com/bluesky-social/atproto/blob/main/LICENSE-APACHE.txt) or <http://www.apache.org/licenses/LICENSE-2.0>)
> 
> Downstream projects and end users may chose either license individually, or both together, at their discretion. The motivation for this dual-licensing is the additional software patent assurance provided by Apache 2.0.
> 
> (Depending on compiler options) Does "exports" exist? No.
> Does "typesVersions" exist? Yes.
> Is the TypeScript version <4.0? Yes. Remember the mapping "index.d.ts": ["index.v3.d.ts"].
> Are we resolving a subpath after the package name? No, just the root "pkg".
> Does "types" exist? Yes.
> Does any key in "typesVersions" match ./index.d.ts? Yes, "index.d.ts" matches.
> Does the path ./index.v3.d.ts have a recognized TypeScript file extension? Yes, so don’t use extension substitution.
> 
> (Depending on compiler options) Does "exports" exist? No.
> Does "typesVersions" exist? Yes.
> Is the TypeScript version <4.0? Yes. Remember the mapping "index.d.ts": ["index.v3.d.ts"].
> Are we resolving a subpath after the package name? No, just the root "pkg".
> Does "types" exist? Yes.
> Does any key in "typesVersions" match ./index.d.ts? Yes, "index.d.ts" matches.
> Does the path ./index.v3.d.ts have a recognized TypeScript file extension? Yes, so don’t use extension substitution.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> Here we’ll try to focus on how TypeScript supports it.With TypeScript’s original Node support, it would look for a "main" field, and then look for declaration files that corresponded to that entry.
> For example, if "main" pointed to ./lib/index.js, TypeScript would look for a file called ./lib/index.d.ts.
> A package author could override this by specifying a separate field called "types" (e.g. "types": "./types/index.d.ts").The new support works similarly with import conditions.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> TypeScript 3.6 now exposes two sets of APIs to operate on project references and incremental program building.For creating incremental builds, users can leverage the createIncrementalProgram and createIncrementalCompilerHost APIs.
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> This variation allows package authors to write "imports" and "exports" fields that reference only the compilation outputs that will be published to npm, while still allowing local development to use the original TypeScript source files.Example: local project with conditionsScenario: "/src/main.mts" imports "#utils" with conditions ["types", "node", "import"] (determined by moduleResolution setting and the context that triggered the module resolution request) in a project directory with a tsconfig.json and package.json:json// tsconfig.json{  "compilerOptions": {    "moduleResolution": "node16",    "resolvePackageJsonImports": true,    "rootDir": "./src",    "outDir": "./dist"  }}json// package.json{  "name": "pkg",  "imports": {    "#utils": {      "import": "./dist/utils.d.mts",      "require": "./dist/utils.d.cts"    }  }}Resolution process:
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Let’s start out with a new directory.
> We’ll name it proj for now, but you can change it to whatever you want.shellmkdir projcd projTo start, we’re going to structure our project in the following way:proj/
>    ├─ src/
>    └─ dist/TypeScript files will start out in your src folder, run through the TypeScript compiler and end up in dist.Let’s scaffold this out:shellmkdir srcmkdir distInitialize the projectNow we’ll turn this folder into an npm package.shellnpm initYou’ll be given a series of prompts.
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> Uses
> Type
> Description
> JConsolePlugin
> 
> A JConsole plugin class.
> 
> com.sun.source.tree.Tree.Kind.RECORD
> 16
> 
> Used for instances of ClassTree representing records.
> 
> com.sun.source.tree.Tree.Kind.SWITCH_EXPRESSION
> 12
> 
> Used for instances of SwitchExpressionTree.
> 
> com.sun.source.tree.Tree.Kind.YIELD
> 13
> 
> Used for instances of YieldTree.
> 
> java.lang.annotation.ElementType.RECORD_COMPONENT
> 16
> 
> Record component
> 
> java.lang.Character.UnicodeScript.CHORASMIAN
> 15
> 
> Unicode script "Chorasmian".
> 
> java.lang.Character.UnicodeScript.CYPRO_MINOAN
> 19
> 
> Unicode script "Cypro Minoan".
> 
> a reliable source, like a classfile.
> 
> java.lang.constant.ClassDesc
> 12
> 
> A nominal descriptor for a
>  Class constant.
> 
> java.lang.constant.Constable
> 12
> 
> Represents a type which is constable.
> 
> java.lang.constant.ConstantDesc
> 12
> 
> A nominal descriptor for a loadable
>  constant value, as defined in JVMS 4.4.
> 
> java.lang.constant.DirectMethodHandleDesc
> 12
> 
> A nominal descriptor for a direct
>  MethodHandle.
> 
> java.lang.constant.MethodHandleDesc
> 12
> 
> A nominal descriptor for a
>  MethodHandle constant.
> 
> Java Cryptography Architecture (JCA) Reference Guide
> 
>    PKCS #8: Private-Key Information Syntax Standard, Version 1.2,
>      November 1993
> 
>    
>      Java Security Standard Algorithm Names Specification
>      
>  
> 
>  For further documentation, please see:
>  
>     Java Security Overview 
> 
>     How to Implement a Provider in the Java Cryptography Architecture
> 
>     Default Policy Implementation and Policy File Syntax
> 
>     Permissions in the Java Development Kit (JDK)
> 
> Provides
> Type
> Description
> Provider
> 
> This class represents a "provider" for the
>  Java Security API, where a provider implements some or all parts of
>  Java Security.
> 
> Provides
> Type
> Description
> Provider
> 
> This class represents a "provider" for the
>  Java Security API, where a provider implements some or all parts of
>  Java Security.
> 
> javax.lang.model.SourceVersion.RELEASE_14
> 14
> 
> The version introduced by the Java Platform, Standard Edition
>  14.
> 
> javax.lang.model.SourceVersion.RELEASE_15
> 15
> 
> The version introduced by the Java Platform, Standard Edition
>  15.
> 
> javax.lang.model.SourceVersion.RELEASE_16
> 16
> 
> The version introduced by the Java Platform, Standard Edition
>  16.
> 
> javax.lang.model.SourceVersion.RELEASE_17
> 17
> 
> The version introduced by the Java Platform, Standard Edition
>  17.
> 
> javax.lang.model.SourceVersion.RELEASE_18
> 
> The Applet API is deprecated, no replacement.
> 
> java.awt.Event
> 9
> 
> It is recommended that AWTEvent and its subclasses be
>              used instead
> 
> java.io.LineNumberInputStream
> 
> 
> This class incorrectly assumes that bytes adequately represent
>              characters.  As of JDK 1.1, the preferred way to operate on
>              character streams is via the new character-stream classes, which
>              include a class for counting line numbers.
> 
> java.io.StringBufferInputStream
> 
> java.xml
> javax.xml javax.xml.catalog javax.xml.datatype javax.xml.namespace javax.xml.parsers javax.xml.stream javax.xml.stream.events javax.xml.stream.util javax.xml.transform javax.xml.transform.dom javax.xml.transform.sax javax.xml.transform.stax javax.xml.transform.stream javax.xml.validation javax.xml.xpath org.w3c.dom org.w3c.dom.bootstrap org.w3c.dom.events org.w3c.dom.ls org.w3c.dom.ranges org.w3c.dom.traversal org.w3c.dom.views org.xml.sax org.xml.sax.ext org.xml.sax.helpers
> 
> A builder for creating a platform Thread or ThreadFactory
>  that creates platform threads.
> 
> java.lang.Thread.Builder.OfVirtual
> 21
> 
> A builder for creating a virtual Thread or ThreadFactory
>  that creates virtual threads.
> 
> java.net.spi.InetAddressResolver
> 18
> 
> This interface defines operations for looking up host names and IP addresses.
> 
> java.net.spi.InetAddressResolverProvider.Configuration
> 18
> 
> A Configuration object is supplied to the
>  InetAddressResolverProvider.get(Configuration) method when
> 
> An abstract class for service providers that
>  provide concrete implementations of the
>  NumberFormat class.
> 
> Provider
> 
> This class represents a "provider" for the
>  Java Security API, where a provider implements some or all parts of
>  Java Security.
> 
> ResourceBundleControlProvider
> 
> An interface for service providers that provide implementations of ResourceBundle.Control.
> 
> ResourceBundleProvider
> 
> ResourceBundleProvider is a service provider interface for
>  resource bundles.
> 
> SelectorProvider
> 
> Exports
> 
> Package
> Description
> java.util.logging
> 
> Provides the classes and interfaces of
>  the Java 2 platform's core logging facilities.
> 
> component of a record class.
> 
> java.lang.runtime.ObjectMethods
> 16
> 
> Bootstrap methods for state-driven implementations of core methods,
>  including Object.equals(Object), Object.hashCode(), and
>  Object.toString().
> 
> java.lang.runtime.SwitchBootstraps
> 21
> 
> Bootstrap methods for linking invokedynamic call sites that implement
>  the selection functionality of the switch statement.
> 
> java.lang.runtime.TemplateRuntimePREVIEW
> 21
> 
> Manages string template bootstrap methods.
> 
> java.lang.ScopedValuePREVIEW
> 21
> 
> javax.xml javax.xml.catalog javax.xml.datatype javax.xml.namespace javax.xml.parsers javax.xml.stream javax.xml.stream.events javax.xml.stream.util javax.xml.transform javax.xml.transform.dom javax.xml.transform.sax javax.xml.transform.stax javax.xml.transform.stream javax.xml.validation javax.xml.xpath org.w3c.dom org.w3c.dom.bootstrap org.w3c.dom.events org.w3c.dom.ls org.w3c.dom.ranges org.w3c.dom.traversal org.w3c.dom.views org.xml.sax org.xml.sax.ext org.xml.sax.helpers
> java.xml.crypto
> 
> java.beans.Beans.instantiate(ClassLoader, String, BeanContext, AppletInitializer)
> 9
> 
> It is recommended to use
>  Beans.instantiate(ClassLoader, String, BeanContext),
>  because the Applet API is deprecated. See the
>   java.applet package
>  documentation for further information.
> 
> java.lang.Boolean(boolean)
> 9
> 
> It is rarely appropriate to use this constructor. The static factory
>  Boolean.valueOf(boolean) is generally a better choice, as it is
> 
> Java Native Interface (JNI) 
>                                             
>                                             			  JVM Tool Interface (JVM TI) 
>                                             
>                                             			  Serialization 
>                                             
>                                             			  Java Debug Wire Protocol (JDWP)
> 
> Summary of Tools for Java Platform Security
>      (for example keytool and jarsigner),
> 
> API Documentation 
>                                             
>                                             			  Language and VM 
>                                             
>                                             			  JAR
> 
> Java SE API Documentation
>       JavaFX API Documentation
>       
>       Developer Guides
>       Java Language and Virtual Machine Specifications
>       Java SE Tools Reference for UNIX
>       Java SE Tools Reference for Windows
> 
> String constructors that take a Charset, charset name,
>  or that use the default charset.
> 
> java.net.Socket(String, int, boolean)
> 
> 
> Use DatagramSocket instead for UDP transport.
> 
> java.net.Socket(InetAddress, int, boolean)
> 
> 
> Use DatagramSocket instead for UDP transport.
> 
> java.net.URL(String)
> 20
> 
> Use URI.toURL() to construct an instance of URL. See the note on
>  constructor deprecation for more
>  details.
> 
> java.net.URL(String, String, int, String)
> 20
> 
> Use URI.toURL() to construct an instance of URL. See the note on
>  constructor deprecation for more
>  details.
> 
> java.net.URL(String, String, int, String, URLStreamHandler)
> 20
> 
> Use URL.of(URI, URLStreamHandler) to construct an instance of URL
>  associated with a custom protocol handler.
>  See the note on constructor deprecation
>  for more details.
> 
> java.net.URL(String, String, String)
> 20
> 
> Use URI.toURL() to construct an instance of URL. See the note on
>  constructor deprecation for more
>  details.
> 
> java.net.URL(URL, String)
> 20
> 
> Use URI.toURL() to construct an instance of URL. See the note on
>  constructor deprecation for more
>  details.
> 
> java.net.URL(URL, String, URLStreamHandler)
> 20
> 
> Use URL.of(URI, URLStreamHandler) to construct an instance of URL
>  associated with a custom protocol handler.
>  See the note on constructor deprecation
>  for more details.
> 
> java.rmi.RMISecurityException(String)
> 
> 
> no replacement
> 
> java.rmi.RMISecurityException(String, String)
> 
> 
> no replacement
> 
> java.io.ObjectStreamException(String, Throwable)
> 19
> 
> Create an ObjectStreamException with the specified message and
>  cause.
> 
> java.io.ObjectStreamException(Throwable)
> 19
> 
> Create an ObjectStreamException with the specified cause.
> 
> java.lang.IndexOutOfBoundsException(long)
> 16
> 
> Constructs a new IndexOutOfBoundsException class with an
>  argument indicating the illegal index.
> 
> java.net.ServerSocket(SocketImpl)
> 12
> 
> Creates a server socket with a user-specified SocketImpl.
> 
> Exports
> 
> Package
> Description
> jdk.net
> 
> Platform specific socket options for the java.net and java.nio.channels
>  socket classes.
> 
> jdk.nio
> 
> Defines JDK-specific channel APIs.
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> javax.swing.plaf.synth.SynthLookAndFeel.load(URL)
> 21
> 
> Use SynthLookAndFeel.load(InputStream, Class) or
>  setStyleFactory(SynthStyleFactory) instead
> 
> javax.swing.RepaintManager.addDirtyRegion(Applet, int, int, int, int)
> 9
> 
> The Applet API is deprecated. See the
>   java.applet package
>  documentation for further information.
> 
> jdk.net.Sockets.supportedOptions(Class<?>)
> 16
> 
> use Socket.supportedOptions(), ServerSocket.supportedOptions(),
>              or DatagramSocket.supportedOptions() instead.
> 
> Requires
> Modifier
> Module
> Description
> transitive
> java.desktop
> 
> Defines the AWT and Swing user interface toolkits, plus APIs for
>  accessibility, audio, imaging, printing, and JavaBeans.
> 
> transitive
> java.management
> 
> Defines the Java Management Extensions (JMX) API.
> 
> Indirect Requires
> Modifier
> Module
> Description
> transitive
> java.datatransfer
> 
> Defines the API for transferring data between and within applications.
> 
> transitive
> java.xml
> 
> Defines the Java APIs for XML Processing (JAXP).
> 
> constant pool entries or invokedynamic call sites.
> 
> java.lang.runtime
> 14
> 
> The java.lang.runtime package provides low-level runtime support
>  for the Java language.
> 
> java.util.random
> 17
> 
> This package contains classes and interfaces that support a generic API
>  for random number generation.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Interfaces
> 
> 
> 
> 
> 
> 
> com.sun.net.httpserver.Request
> 18
> 
> A view of the immutable request state of an HTTP exchange.
> 
> com.sun.source.doctree.EscapeTree
> 21
> 
> Modules
> Packages
> Interfaces
> Classes
> Enum Classes
> Exception Classes
> Record Classes
> Annotation Interfaces
> Fields
> Methods
> Constructors
> Enum Constants
> 
> 
> 
> 
> New Modules
> 
> 
> 
> 
> 
> 
> jdk.jpackage
> 16
> 
> Defines the Java Packaging tool, jpackage.
> 
> jdk.nio.mapmode
> 14
> 
> Defines JDK-specific file mapping modes.
> 
> 
> 
> 
> 
> 
> 
> 
> 
> New Packages
> 
> 
> 
> 
> 
> 
> java.lang.constant
> 12
> 
> Classes and interfaces to represent nominal descriptors for run-time
>  entities such as classes or method handles, and classfile entities such as
> 
> 18
> 
> The version introduced by the Java Platform, Standard Edition
>  18.
> 
> javax.lang.model.SourceVersion.RELEASE_19
> 19
> 
> The version introduced by the Java Platform, Standard Edition
>  19.
> 
> javax.lang.model.SourceVersion.RELEASE_20
> 20
> 
> The version introduced by the Java Platform, Standard Edition
>  20.
> 
> javax.lang.model.SourceVersion.RELEASE_21
> 21
> 
> The version introduced by the Java Platform, Standard Edition
>  21.
> 
> jdk.jshell.Snippet.SubKind.RECORD_SUBKIND
> 14
> 
> A record declaration.
> 
> Use the above documentation to answer the following question. You should not reference anything outside of what is shown, unless it is a commonly known concept. Reference URLs whenever possible using markdown formatting. If there isn't enough information to answer the question, suggest where the user might look to learn more.
> 
> URL: https://atproto.com/ URL: https://github.com/bluesky-social/atproto URL: https://github.com/bluesky-social/atproto/tree/main/packages/api Typescript NodeJS 
> Java 21 LTS I want to build a Java implementation of Bluesky's ATProtocol. The goal is to build a package JAR file that anyone can use as a base to build a Java program from. I want to utilize the official Typescript imlementation as a reference to preferably port their code to Java, or to build my own version from.
> Create a file tree of this project using the supplied Typescript implementation as an example. Maintain the naming conventions found in the Typescript code so long as they remain compatible with Java 21. Also keep in mind common ways on how Java libraries are structured. I do not want to use any additional libraries outside of the Java 21 SDK if at all possible (keep it as "pure Java" as possible). For any tests found in their repo, assume that I will be using JUnit in my project.
> Present to me as complete of a file tree as possible for me to build from.

#### _Assistant_

> Okay, here's a proposed file tree structure for a Java-based AT Protocol library, mirroring the structure and concepts of the TypeScript reference implementation (`@atproto/api` specifically), while adhering to Java conventions and aiming for a "pure Java" approach (using only the Java 21 SDK where possible).
> 
> ```
> atproto-java/
> ├── src/
> │   ├── main/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │       ├── api/
> │   │   │   │       │    ├── AtpAgent.java       (Main client class, like BskyAgent)
> │   │   │   │       │    ├── AtpResponse.java    (Generic response wrapper)
> │   │   │   │       │    ├── AtpSession.java        (Handles session data. No equivalent to persistSession since it's pure Java)
> │   │   │   │       │    ├── xrpc/
> │   │   │   │       │    │    ├── XrpcClient.java    (Low-level XRPC handling)
> │   │   │   │       │    │    ├── XrpcRequest.java
> │   │   │   │       │    │    ├── XrpcResponse.java
> │   │   │   │       │    │    ├── XrpcException.java
> │                │       │    │    ├── Params.java (Interface for Client Query parameters.)
> │   │   │   │       │    ├── models/            (Equivalent to *.lexicon files, but as Java classes)
> │   │   │   │       │    │    ├── com/
> │   │   │   │       │    │    │   ├── atproto/
> │   │   │   │       │    │    │   │   ├── repo/
> │   │   │   │       │    │    │   │   │   ├── CreateRecordRequest.java
> │   │   │   │       │    │    │   │   │   ├── CreateRecordResponse.java
> │   │   │   │       │    │    │   │   │   ├── ListRecordsRequest.java
> │   │   │   │       │    │    │   │   │   ├── ListRecordsResponse.java
> │   │   │   │       │    │    │   │   │   └── ... (Other com.atproto.* models)
> │   │   │   │       │    │    │   ├── bsky/
> │   │   │   │       │    │    │   │    ├── feed/
> │   │   │   │       │    │    │   │    │    ├── GetTimelineRequest.java
> │   │   │   │       │    │    │   │    │    ├── GetTimelineResponse.java
> │   │   │   │       │    │    │   │    │    ├── Post.java          (Representing app.bsky.feed.post)
> │   │   │   │       │    │    │   │    │    └── ... (Other app.bsky.* models)
> │   │   │   │       │    │    └── ...
> │   │   │   │       │    ├── identifiers/
> │   │   │   │       │    │   ├── AtUri.java
> │   │   │   │       │    │   ├── Did.java
> │   │   │   │       │    │   ├── Handle.java
> │   │   │   │       │    │   └── ...
> │   │   │   │       │    ├── moderation/           (Moderation related functionality)
> │   │   │   │       │	     ├── ModerationAction.java		 
> │   │   │   │       │    ├── RichText.java  (RichText processing utility)
> │   │   │   │       │    ├── typeguards/    (Type guard functionality.  Consider using instanceof checks and helper methods)
> │   │   │   │       │    │    ├── AppBskyFeedDefs.java
> │   │   │   │       │    │    ├── AppBskyFeedPost.java
> │   │   │   │       │    │    └── ...
> │   │   │   │       │    ├── util/
> │   │   │   │       │ 	     ├── HttpUtil.java (If needed for abstracting HTTP calls for testing)
> │   │   │   │       │        └── ... (Other utilities)
> │       │            │
> │       │            ├── common/         (Shared code and helpers)
> │       │            │     ├── AtProtoException.java   (Base exception class)
> │  	   │            │     └── ...
> │       │            ├── crypto/        (Cryptographic functions.  Likely a simplified version)
> │       │            │     ├── SigningUtil.java
> │       │            │     └── KeySerialization.java
> │       │            └── identity/      (DID and handle resolution)
> │       │                  ├── IdentityResolver.java
> │       │                 └── ...
> │       │
> │       └── lexicon    (No direct equivalent if you use Java classes for models)
> │   ├── test/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │   │    ├── api/
> │   │   │   │   │    │   ├── AtpAgentTest.java     (JUnit tests for AtpAgent)
> │   │   │   │   │    │   ├── xrpc/
> │   │   │   │   │    │   │   └── XrpcClientTest.java  (JUnit tests for XrpcClient)
> │   │   │   │   │    ├── models/
> │   │   │   │   │    │   ├── ... (Tests for model classes)
> │         │            │   │   
> │         │            │   ├── moderation/ (Moderation related functionality)
> │   │   │   │       │	     ├── ModerationActionTest.java		 
> │   │   │   │   │    └── ...
> │   │   │   │    ├── identifiers/
> │   │   │   │	     ├── AtUriTest.java
> │         │
> │   └── resources/               (Test resources, if any)
> │
> ├── build.gradle.kts (or pom.xml if using Maven)
> ├── README.md
> └── LICENSE
> 
> ```
> 
> Key Considerations and Explanations:
> 
> *   **Package Structure:**  The Java convention is to use reverse domain name notation for packages (e.g., `com.atproto`).  This helps avoid naming conflicts.  I've mirrored the TypeScript structure within this, creating subpackages for `api`, `models`, `xrpc`, `identifiers`, etc.
> *   **`AtpAgent`:** This is your primary entry point, analogous to `BskyAgent` in TypeScript.  It will handle session management (using `AtpSession`) and provide methods for the various AT Protocol API calls.
> *   **`models` Package:**  Instead of Lexicon files, you'll define Java classes (likely using records in Java 21 for immutable data objects) to represent the data structures of the AT Protocol (e.g., `Post`, `GetTimelineResponse`).  This is *crucially* important for type safety and ease of use in Java.  Subpackages within `models` (like `com.atproto.repo`, `app.bsky.feed`) mirror the Lexicon namespaces.  The models are organized by the namespaces they belong too, following how it is layed out in atproto/api's README ([https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md](https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md))
> *   **`xrpc` Package:**  This contains the lower-level HTTP communication logic.  Java 21 has a built-in `HttpClient` (in `java.net.http`), which you should use.  `XrpcClient` would handle creating requests, sending them, and parsing responses.  `XrpcRequest` and `XrpcResponse` would encapsulate the request/response details. `XrpcException` would model any errors in comuncation.
> *	**`Params` Interface:** XprcClient uses the Params interface to represent client query parameters.
> *   **`identifiers` Package:** Classes like `AtUri`, `Did`, and `Handle` to represent and parse the various identifier types used in the AT Protocol.
> *   **`RichText`:**  A Java class to handle the rich text processing (facets, links, mentions).  This would be similar in spirit to the TypeScript `RichText` class, but adapted for Java's string handling.
> *   **Type Guards:** TypeScript's type guards don't have a direct equivalent in Java.  You'll use a combination of `instanceof` checks and helper methods (e.g., static methods on `AppBskyFeedDefs` like `isThreadViewPost(Object obj)`) to achieve similar type safety.
> *   **`util` Package:** A place for any utility functions that don't fit neatly elsewhere. This might include things like date/time formatting helpers specific to AT Protocol.
> *   **`HttpUtil` (Optional):** *If* you find you need to abstract the HTTP calls for testing purposes (e.g., to mock responses), you *could* create an `HttpUtil` class.  But try to avoid this if possible, as `HttpClient` is already quite testable.
> * **`ModerationAction.java`** This encapsulates the outputs needed for the moderation system.
> *	**`ModerationActionTest.java`** Tests for the moderation sytem functionality.
> *   **`crypto` (Simplified):** The TypeScript implementation has a `@atproto/crypto` package.  You likely *won't* need to reimplement all of this.  You *will* need to handle signature verification for responses.  You might be able to use classes from `java.security` for this, but you might need to implement some specific cryptographic algorithms if they're not directly available. Focus initially on just what's *essential* for the API client.
> *   **`identity`:**  This mirrors `@atproto/identity` and handles DID and handle resolution.
> *    **No `persistSession` needed:** In atproto/api, The `AtpAgent` includes a `persistSession` variable to manage client sessions (url connection to the personal data server) through App passwords or OAuth. Because you are only building an API with pure Java, there should be no need to persist the session through this variable. ([https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md](https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md))
> *   **Tests (`src/test/java`):**  Use JUnit (a standard Java testing framework) for your unit tests.  The structure mirrors the `src/main/java` structure.
> *   **Build System:**  I've included `build.gradle.kts` (for Gradle with Kotlin DSL) and `pom.xml` (for Maven) as placeholders.  Choose whichever build system you prefer.  These files will define your project's dependencies (if any) and build process.
> *   **No Lexicon Files:** Since you're using Java classes to represent the data models, you won't have separate Lexicon files. The Java classes *themselves* serve as the schema definitions.
> 
> This structure provides a solid foundation. You'll need to fill in the implementation details, paying close attention to the TypeScript code and the AT Protocol specifications ([https://atproto.com/specs/atp](https://atproto.com/specs/atp)). Remember to start with the core functionality (e.g., basic XRPC communication, handling a few key API endpoints) and gradually expand. Good luck!
> 

#### _User_

> Why is the xrpc package named xrpc? I don't see anything mentioning xrpc verbatim in the Typescript code.

#### _Assistant_

> You are correct that "xrpc" isn't explicitly spelled out as a full name within the `@atproto/api` TypeScript code itself. However, "XRPC" is a core concept within the AT Protocol, and the `xrpc` package in the TypeScript library (and the proposed Java structure) directly implements this concept.
> 
> Here's the breakdown:
> 
> 1.  **XRPC stands for "Cross-Repository Procedure Call."**  It's the communication protocol used by AT Protocol for most interactions between clients and servers (both PDS and AppView).  It's essentially a simplified, JSON-based RPC (Remote Procedure Call) mechanism built on top of HTTP. You can find a description of XRPC in the AT Protocol specifications: [https://atproto.com/specs/xrpc](https://atproto.com/specs/xrpc)
> 
> 2.  **The `@atproto/xrpc` and `@atproto/xrpc-server` packages implement XRPC.** The TypeScript reference implementation has two packages dedicated to XRPC:
> 
>     *   `@atproto/xrpc`: ([https://github.com/bluesky-social/atproto/tree/main/packages/xrpc](https://github.com/bluesky-social/atproto/tree/main/packages/xrpc)) This is the *client-side* implementation. It provides the tools to construct XRPC requests, send them over HTTP, and handle the responses. This is the package most relevant to your Java API client.
>     *   `@atproto/xrpc-server`: ([https://github.com/bluesky-social/atproto/tree/main/packages/xrpc-server](https://github.com/bluesky-social/atproto/tree/main/packages/xrpc-server)) This is the *server-side* implementation, used for building services that *respond* to XRPC requests (like a PDS or AppView).
> 
> 3.  **Why "xrpc" and not "XRPC"?** It's a common practice in package naming, both in the JavaScript/TypeScript ecosystem and in Java, to use lowercase, concise names. "xrpc" is simply a shorter, more package-friendly version of "XRPC." It avoids capitalization issues and potential confusion with acronyms written in all caps. It's analogous to how many libraries use abbreviations or shorter forms of longer names (e.g., "http" instead of "HTTP").
> 
> In summary: The `xrpc` package, both in the TypeScript reference implementation and in the proposed Java structure, is named after the XRPC protocol that it implements. The name is a lowercase abbreviation for "Cross-Repository Procedure Call," reflecting common naming conventions for libraries. The core functionality of this package will involve making HTTP requests and handling responses according to the XRPC specification.
> 

#### _User_

> Under the xrpc folder in api, there's a params.java file that looks like it should be in its own folder by how the file tree is structured. Is it in xprc or a subfolder?

#### _Assistant_

> You are absolutely correct to point that out. Based on the established pattern and Java conventions, `Params.java` *should* be in its own subfolder, likely within a `models` or `types` subdirectory inside `xrpc`.
> 
> Here's the corrected and more consistent file tree structure, along with the reasoning:
> 
> ```
> atproto-java/
> ├── src/
> │   ├── main/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │       ├── api/
> │   │   │   │       │    ├── ... (other files)
> │   │   │   │       │    ├── xrpc/
> │   │   │   │       │    │    ├── XrpcClient.java
> │   │   │   │       │    │    ├── XrpcRequest.java
> │   │   │   │       │    │    ├── XrpcResponse.java
> │   │   │   │       │    │    ├── XrpcException.java
> │   │   │   │       │    │    ├── types/  // OR models/ - see explanation below
> │   │   │   │       │    │    │    └── Params.java   // Now correctly placed
> │   │   │   │       │    └── ...
> │   │   │   │       └── ...
> └── ...
> ```
> 
> **Reasoning:**
> 
> 1.  **Consistency:** The file tree establishes a clear pattern:
>     *   Top-level API functionality (like `AtpAgent`) resides directly under `api`.
>     *   Specific sub-protocols or components (like `xrpc`) have their own subfolders.
>     *   Data structures and models generally live within a `models` or `types` subfolder *within* their relevant component folder.
> 
> 2.  **`Params.java` as a Data Structure:** The `Params` interface, as described, represents the structure for query parameters used in XRPC requests.  It's essentially a data model defining the shape of these parameters, *not* core XRPC client logic. Thus it should not be a top level file within xrpc.
> 
> 3.  **`models` vs. `types` Subfolder:**
>     *   **`models` is more common in Java:**  The most common convention in Java projects is to use a `models` subfolder for classes that represent data structures (like DTOs - Data Transfer Objects).
>     *   **`types`  is acceptable, but less common:** While `types` is perfectly valid (and used in the TypeScript AT Protocol code), it's slightly less idiomatic in the Java world.
> 
>     Either `models` or `types` would work fine, consistency is key. I put types in the tree since you indicated that mirroring the organization as found in the Typescript ATProto implementation.
> 
> **Recommendation:**
> 
> Place `Params.java` within a `com.atproto.api.xrpc.models` package (and thus in a `models` subfolder, using the more conventional Java style). This makes the structure clearly organized and easy to understand.
> 
> ```
> atproto-java/
> ├── src/
> │   ├── main/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │       ├── api/
> │   │   │   │       │    ├── xrpc/
> │   │   │   │       │    │    ├── models/
> │   │   │   │       │    │    │   └── Params.java
> ...
> ```
> 
> The corrected placement of `Params.java` improves the organization and maintainability of your project. It clearly signals that `Params` is a data structure related to XRPC, rather than a core part of the XRPC client's logic.
> 

#### _User_

> Why do I need to create the com/atpro structure again in the models folder?

#### _Assistant_

> You're asking a great question about the nested `com/atproto` structure within the `models` folder. Here's the breakdown of why it's necessary and how it relates to both Java conventions and the structure of the AT Protocol itself:
> 
> **1. Java Package Naming Conventions and Collision Avoidance**
> 
> *   **Reverse Domain Name Notation:** Java's standard package naming convention uses reverse domain name notation (e.g., `com.example.myapp`). This is crucial for:
>     *   **Uniqueness:** It prevents naming conflicts between different libraries and projects. Imagine if two different libraries both had a `models.User` class; the package structure is the only way to tell them apart.
>     *   **Organization:** It provides a clear, hierarchical structure that reflects the ownership and purpose of the code.
> 
> *   **Your Project's Root:** In your `atproto-java` project, `com.atproto` is effectively your project's root package. *Everything* you create within that project should reside within this root package.
> 
> **2. Mirroring Lexicon Namespaces**
> 
> *   **Lexicon Structure:** The AT Protocol uses Lexicons to define its data schemas. These Lexicons are organized into namespaces, primarily `com.atproto.*` and `app.bsky.*`.  For example:
>     *   `com.atproto.repo.createRecord`
>     *   `app.bsky.feed.post`
> 
> *   **Direct Mapping to Java Packages:** The nested `com/atproto` (and eventually `app/bsky`) structure within your `models` folder is designed to *directly* map to these Lexicon namespaces. This mapping has several benefits:
> 
>     *   **Clarity:** It makes it immediately obvious which Lexicon a particular model class corresponds to. If you see a class `com.atproto.api.models.com.atproto.repo.CreateRecordRequest`, you know it's related to the `com.atproto.repo.createRecord` Lexicon.
>     *   **Maintainability:** If the Lexicon structure changes (e.g., a new namespace is added), you can easily reflect those changes in your Java code by simply adding the corresponding package.
>     *   **Consistency:** It keeps your Java code closely aligned with the structure and naming conventions of the AT Protocol itself, making it easier for developers familiar with the protocol to understand your code.
>     *    **Future-proofing:** Should there be code generation created from lexicon files, having the namespace be part of the models would make the generation much easier.
> 
> **3. Avoiding Package Clutter at the `api.models` Level**
> 
> *   **Too Many Classes:** If you *didn't* have the nested structure, your `com.atproto.api.models` package would become extremely cluttered.  You'd have classes from *all* the different Lexicon namespaces (`repo`, `feed`, `identity`, etc.) mixed together in a single, flat package. This would make it hard to find things and understand the relationships between classes.
> 
> **Example:**
> 
> Consider these two options:
> 
> *   **Option 1 (Nested - Recommended):**
> 
>     ```java
>     // File: src/main/java/com/atproto/api/models/com/atproto/repo/CreateRecordRequest.java
>     package com.atproto.api.models.com.atproto.repo;
> 
>     public record CreateRecordRequest(...) { ... }
>     ```
> 
>     ```java
>     // File: src/main/java/com/atproto/api/models/app/bsky/feed/Post.java
>     package com.atproto.api.models.app.bsky.feed;
> 
>     public record Post(...) { ... }
>     ```
> 
> *   **Option 2 (Flat - Not Recommended):**
> 
>     ```java
>     // File: src/main/java/com/atproto/api/models/CreateRecordRequest.java
>     package com.atproto.api.models;
> 
>     public record CreateRecordRequest(...) { ... }
>     ```
> 
>     ```java
>     // File: src/main/java/com/atproto/api/models/Post.java
>     package com.atproto.api.models;
> 
>     public record Post(...) { ... }
>     ```
> 
> In Option 2, you have no easy way to tell, just from the package, that `CreateRecordRequest` is related to the `com.atproto.repo` Lexicon and `Post` is related to `app.bsky.feed`. Option 1 makes this relationship crystal clear.
> 
> **In Summary:**
> 
> The nested `com/atproto` (and `app/bsky`) structure within your `models` folder is *not* redundant. It's a crucial part of adhering to Java package naming conventions, preventing naming collisions, providing a clear and organized structure, and directly mirroring the namespace structure of the AT Protocol Lexicons. It's a best practice that significantly improves the maintainability and understandability of your code.
> 

#### _User_

> The bottom half of that file table readout is confusing me. Where should the common, crypto, and identity folders be?

#### _Assistant_

> You're right to point out the ambiguity! I apologize for the confusion in the previous response regarding the placement of `common`, `crypto`, and `identity`. I'll clarify their locations and why, providing a corrected and complete file tree.
> 
> **Corrected File Tree:**
> 
> ```
> atproto-java/
> ├── src/
> │   ├── main/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │       ├── api/        // API-specific code (client logic, XRPC)
> │   │   │   │       │    ├── AtpAgent.java
> │   │   │   │       │    ├── AtpResponse.java
> │   │   │   │       │    ├── AtpSession.java
> │   │   │   │       │    ├── xrpc/
> │   │   │   │       │    │    ├── XrpcClient.java
> │   │   │   │       │    │    ├── XrpcRequest.java
> │   │   │   │       │    │    ├── XrpcResponse.java
> │   │   │   │       │    │    ├── XrpcException.java
> │   │   │   │       │    │    ├── models/
> │   │   │   │       │    │    │    └── Params.java
> │   │   │   │       │    └── ...
> │   │   │   │       ├── common/      // Shared code and utilities, *not* API-specific
> │   │   │   │       │    ├── AtProtoException.java
> │   │   │   │       │    └── ...
> │   │   │   │       ├── crypto/      // Cryptographic utilities (simplified)
> │   │   │   │       │    ├── SigningUtil.java
> │   │   │   │       │    └── KeySerialization.java
> │   │   │   │       ├── identity/    // DID and handle resolution
> │   │   │   │       │    ├── IdentityResolver.java
> │   │   │   │       │    └── ...
> │   │   │   │       ├── models/      // Data models (mirroring Lexicon namespaces)
> │   │   │   │       │    ├── com/
> │   │   │   │       │    │   ├── atproto/
> │   │   │   │       │    │   │   ├── repo/
> │   │   │   │       │    │   │   │   ├── CreateRecordRequest.java
> │   │   │   │       │    │   │   │   └── ...
> │   │   │   │       │    │   │   └── ...
> │   │   │   │       │    │   └── ...
> │   │   │   │       │    ├── app/
> │   │   │   │       │    │   ├── bsky/
> │   │   │   │       │    │   │    ├── feed/
> │   │   │   │       │    │   │    │    └── Post.java
> │   │   │   │       │    │   │    └── ...
> │   │   │   │       │    │   └── ...
> │   │   │   │        │    └── ...
> │   │   │   │       ├── RichText.java    // RichText processing (could also go in common or a separate util package)
> │   │   │    	   ├── moderation/
> │   │   │   │	   │         └── ModerationAction.java
> │   │   │   │       └── typeguards/
> │   │   │   │            ├── AppBskyFeedDefs.java
> │   │   │   │            ├── AppBskyFeedPost.java
> │   │   │   │            └── ...
> │   │   ├── test/
> │   │   │   ├── ... (Test code mirroring the main structure)
> │   └── resources/
> └── ...
> ```
> 
> **Explanation and Key Changes:**
> 
> 1.  **`common`, `crypto`, and `identity` are *sibling* directories to `api` and `models`, not subdirectories of `api`.**  This is the most important correction.  These folders contain code that is *not* specific to the API client itself. They provide supporting functionality that could potentially be used by other parts of an AT Protocol implementation (e.g., a server implementation, a different client, etc.).
> 
> 2.  **`api` Folder:** Contains only the code directly related to the API *client* functionality.  This includes:
>     *   `AtpAgent`: The main client class.
>     *   `AtpSession`: Session management.
>     *   `xrpc`: The XRPC implementation.
> 
> 3.  **`models` Folder:** This folder now resides *outside* of `api`, at the same level.  This is because models (data structures) are used throughout the project, not just within the API client.  The internal structure of `models` (with the nested `com/atproto` and `app/bsky`) mirrors the Lexicon namespaces, as discussed previously. All lexicon-based objects are stored here.
> 
> 4.  **`common` Folder:** This contains shared code and utilities that are used across multiple parts of the project.  `AtProtoException` is a good example – it's a base exception class that could be used by the API client, the XRPC implementation, or any other part of the code.
> 
> 5.  **`crypto` Folder:** This contains any cryptographic utilities needed.  Keep this minimal, relying on Java's built-in `java.security` and `java.crypto` packages as much as possible. In Atproto's Typescript implementation, it is used for cryptographic signing and key serialization ([https://github.com/bluesky-social/atproto?tab=readme-ov-file#typescript-packages](https://github.com/bluesky-social/atproto?tab=readme-ov-file#typescript-packages)).
> 
> 6.  **`identity` Folder:**  This handles DID and handle resolution, as described before, using the `IdentityResolver` class.  It's separate because identity resolution is a distinct concern from API communication. In Atproto's Typescript implementation, it is used for DID and handle resolution. ([https://github.com/bluesky-social/atproto?tab=readme-ov-file#typescript-packages](https://github.com/bluesky-social/atproto?tab=readme-ov-file#typescript-packages)).
> 
> 7. **`RichText.java` Placement** Placing `RichText.java` outside models, crypto, identity, and common allows it to exist as its own component within the projected.
> 
> 8.  **`moderation` Folder:**  Contains logic for handling moderation systems outputs.
> 
> 9. **`typeguards` Folder:** This folder includes classes that act as type guards which are equivalent to those found in the Typescript implementation ([https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md](https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md)).
> 
> **Why This Structure is Better:**
> 
> *   **Separation of Concerns:** It clearly separates the API client code (`api`) from the data models (`models`), shared utilities (`common`), cryptographic functions (`crypto`), and identity resolution (`identity`).  This makes the code easier to understand, test, and maintain.
> *   **Reusability:**  The code in `common`, `crypto`, and `identity` is potentially reusable in other contexts.  For example, if you later decided to build a server-side component, you could reuse the `identity` package.
> *   **Standard Java Practices:** This structure aligns more closely with typical Java project layouts, making it more familiar to Java developers.
> 
> This revised structure provides a much clearer and more organized foundation for your Java AT Protocol library. It emphasizes separation of concerns and reusability, making your project easier to develop and maintain.
> 

#### _User_

> Double check the where the params.java file should be. Should it be in xrpc/models or should it be at the root atproto directory?

#### _Assistant_

> You are right to double-check! My apologies for the continued back-and-forth. Let's definitively nail down the correct location for `Params.java` and explain *why* with absolute clarity.
> 
> **The correct location for `Params.java` is within the `xrpc/models` folder:**
> 
> ```
> atproto-java/
> ├── src/
> │   ├── main/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │       ├── api/
> │   │   │   │       │    ├── xrpc/
> │   │   │   │       │    │    ├── models/  // Correct location
> │   │   │   │       │    │    │    └── Params.java
> ...
> ```
> 
> **Here's the definitive reasoning, addressing all previous points and potential confusion:**
> 
> 1.  **`Params.java` Defines Data, Not Logic:** The `Params.java` interface specifically defines the *structure* of query parameters for XRPC requests. It's purely a data definition; it doesn't contain any logic for *making* XRPC requests or handling responses. This makes it a *model*.
> 
> 2.  **Specific to XRPC:** The `Params` interface is *exclusively* used within the context of XRPC requests. It's not a general-purpose utility or a model that's shared across different parts of the AT Protocol implementation. It's tightly coupled to the XRPC mechanism.
> 
> 3.  **Not a Top-Level Model:**  While it's a model, it's not a top-level AT Protocol data model like `Post`, `CreateRecordRequest`, etc., which represent entities defined by the Lexicons.  Those top-level models live in the main `models` directory, organized by their Lexicon namespaces (`com/atproto`, `app/bsky`). `Params.java` is an internal detail of the *XRPC implementation*, not a core AT Protocol concept.
> 
> 4.  **Consistency with `xrpc` Package:** The `xrpc` package is responsible for *all* aspects of XRPC communication.  Keeping `Params.java` *within* the `xrpc` package, but clearly separated as a *model*, maintains this encapsulation:
> 
>     *   **`xrpc/XrpcClient.java`:**  Contains the logic for making requests and handling responses (the "client" behavior).
>     *   **`xrpc/models/Params.java`:** Defines the *data structure* for request parameters.
>     *   **`xrpc/XrpcRequest.java, XrpcResponse.java, XrpcException.java`:** Other supporting classes for the XRPC mechanism.
> 
> 5.  **Avoids Root Clutter:** Placing `Params.java` directly in the root `com/atproto` or `com/atproto/api` directory would be incorrect. The root `com/atproto` directory is your top-level project namespace. The `api` directory is for API *client* functionality.  `Params.java` is neither of these; it's an internal detail of the XRPC implementation.
> 
> **In summary:**
> 
> *   `Params.java` is a *model* because it defines data.
> *   It's an *XRPC-specific* model.
> *   Therefore, it belongs within the `xrpc/models` folder.
> 
> This placement is the most accurate, consistent, and maintainable option.  It clearly reflects the purpose and scope of `Params.java` within the overall project structure. I apologize again for any previous confusion; this explanation should be definitive.
> 

#### _User_

> What does the src/main/java/lexicon folder do? Do we really need it in the context of a Java program?

#### _Assistant_

> You're absolutely right to question the `lexicon` folder in the context of a Java project. In the original TypeScript project structure, the `lexicon` folder holds JSON files that define the schemas for the AT Protocol data structures. However, in our Java implementation, we're using Java classes (and records) to represent these schemas *directly*.
> 
> **Therefore, we do *not* need a `src/main/java/lexicon` folder in the Java project.**
> 
> Here's a detailed explanation:
> 
> 1.  **TypeScript and Lexicons:** In the TypeScript reference implementation, the `@atproto/lexicon` package and the `./lexicons` directory serve a specific purpose:
> 
>     *   **`@atproto/lexicon` Package:** This package provides tools for *working with* Lexicon schemas. It includes utilities for parsing, validating, and compiling Lexicon files.
>     *   **`./lexicons` Directory:** This directory contains the actual `.json` files that define the Lexicon schemas themselves (e.g., `app.bsky.feed.post.json`). These files are *data*, not code. TypeScript code then *uses* these Lexicon files (with the help of the `@atproto/lexicon` package) to generate types, validate data, etc.
> 
> 2.  **Java's Approach: Classes as Schemas:** In our Java implementation, we're taking a different, more idiomatic Java approach:
> 
>     *   **Java Classes as Schemas:** We are using Java classes (and specifically Java records where appropriate) to *directly* represent the data structures defined by the Lexicons. For example, instead of a separate `app.bsky.feed.post.json` file, we have a `Post.java` record in the `com.atproto.api.models.app.bsky.feed` package.
>     *   **No Separate Lexicon Files:** We *don't* have separate `.json` files defining the schemas. The Java classes *themselves* serve as the schema definitions. This is a common and powerful approach in Java.
>     * **Compile-Time Type Safety:** Instead of using types that must refer to a set of lexicon files, using classes means the compiler can check to see if the models are valid at compile-time.
> 
> 3.  **Implications for the `lexicon` Folder:**
> 
>     *   **No `src/main/java/lexicon`:** Since our Java classes are the schemas, we don't need a folder to hold separate Lexicon definition files.
>     *   **No Equivalent to `@atproto/lexicon` Package:** We also don't need a direct Java equivalent to the `@atproto/lexicon` *package* in its original form. The functionality that package provides (parsing, validating, compiling Lexicons) is *not* needed because we're not working with external Lexicon files.
>     *   **Potential Validation Utilities:** We *might* still have some utility classes related to *validation*, but these would be part of our `util` package (e.g., `com.atproto.util.ValidationUtil`) and would operate directly on our Java model classes, *not* on external Lexicon files. This is analogous to the `validateRecord` in the Typescript, as shown in the `@atproto/api` readme. ([https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md](https://github.com/bluesky-social/atproto/blob/main/packages/api/README.md))
> 
> **In short:** The Java approach of using classes directly as schema definitions eliminates the need for a separate `lexicon` folder and the associated tooling for processing external Lexicon files. This is a more natural and efficient way to work with schemas in Java. The `models` folder, organized by Lexicon namespaces, is where all the schema-related code (i.e., the Java classes/records) resides.
> 

#### _User_

> Show me the file tree as it should be currently.

#### _Assistant_

> ```
> atproto-java/
> ├── src/
> │   ├── main/
> │   │   ├── java/
> │   │   │   ├── com/
> │   │   │   │   ├── atproto/
> │   │   │   │       ├── api/        // API-specific code (client logic, XRPC)
> │   │   │   │       │    ├── AtpAgent.java
> │   │   │   │       │    ├── AtpResponse.java
> │   │   │   │       │    ├── AtpSession.java
> │   │   │   │       │    ├── xrpc/
> │   │   │   │       │    │    ├── XrpcClient.java
> │   │   │   │       │    │    ├── XrpcRequest.java
> │   │   │   │       │    │    ├── XrpcResponse.java
> │   │   │   │       │    │    ├── XrpcException.java
> │   │   │   │       │    │    ├── models/
> │   │   │   │       │    │    │    └── Params.java
> │   │   │   │       │    └── ...
> │   │   │   │       ├── common/      // Shared code and utilities
> │   │   │   │       │    ├── AtProtoException.java
> │   │   │   │       │    └── ...
> │   │   │   │       ├── crypto/      // Cryptographic utilities (simplified)
> │   │   │   │       │    ├── SigningUtil.java
> │   │   │   │       │    └── KeySerialization.java
> │   │   │   │       ├── identity/    // DID and handle resolution
> │   │   │   │       │    ├── IdentityResolver.java
> │   │   │   │       │    └── ...
> │   │   │   │       ├── models/      // Data models (mirroring Lexicon namespaces)
> │   │   │   │       │    ├── com/
> │   │   │   │       │    │   ├── atproto/
> │   │   │   │       │    │   │   ├── repo/
> │   │   │   │       │    │   │   │   ├── CreateRecordRequest.java
> │   │   │   │       │    │   │   │   └── ...
> │   │   │   │       │    │   │   └── ...
> │   │   │   │       │    │   └── ...
> │   │   │   │       │    ├── app/
> │   │   │   │       │    │   ├── bsky/
> │   │   │   │       │    │   │    ├── feed/
> │   │   │   │       │    │   │    │    └── Post.java
> │   │   │   │       │    │   │    └── ...
> │   │   │   │       │    │   └── ...
> │   │   │   │        │    └── ...
> │   │   │   │       ├── RichText.java    // RichText processing
> │   │   │    	   ├── moderation/
> │   │   │   │	   │         └── ModerationAction.java
> │   │   │   │       └── typeguards/
> │   │   │   │            ├── AppBskyFeedDefs.java
> │   │   │   │            ├── AppBskyFeedPost.java
> │   │   │   │            └── ...
> │   │   ├── test/
> │   │   │   ├── java/
> │   │   │   │  ├── com/
> │   │   │   │  │   ├── atproto/
> │   │   │   │  │       ├── api/
> │   │   │   │  │       │   ├── AtpAgentTest.java
> │   │   │   │  │       │   ├── xrpc/
> │   │   │   │  │       │   │   ├── models/
> │   │   │   │  │       │   │   │   └── ParamsTest.java
> │   │   │   │  │       │   │   └── XrpcClientTest.java
> │   │   │   │  │       ├── common/
> │   │   │   │  │       ├── crypto/
> │   │   │   │  │       ├── identity/
> │   │   │   │  │       ├── models/
> │   │   │   │  │       │    ├── com/
> │   │   │   │  │       │    │   └── ...  // Tests for model classes
> │   │   │   │  │       │    └── ...
> │   │   │   │	     ├── moderation/ (Moderation related functionality)
> │   │   │   │       │	     ├── ModerationActionTest.java	
> │   │   │   │       └── ... // Other test classes
> │   └── resources/  // (Test resources, if any)
> │
> ├── build.gradle.kts (or pom.xml)
> ├── README.md
> └── LICENSE
> ```
> 
> Key Changes and Confirmations:
> 
> *   **No `lexicon` folder:** Confirmed removal.
> *   **`Params.java` location:** Confirmed in `api/xrpc/models`.
> *   **Test Folder:** Added a basic `test` folder structure mirroring `main`, and included example test files (`AtpAgentTest.java`, `ParamsTest.java`, `XrpcClientTest.java`).  This is *essential* for any real project.
> *  **Top Level Folders:** Maintained the crucial separation of `api`, `common`, `crypto`, `identity`, and `models`.
> *   **models folder:** The subfolders inside models represent the structure of the com.atproto and app.bsky namespaces.
> 
> This file tree represents the best-practice structure for a Java-based AT Protocol client library, directly addressing all previous points of confusion and incorporating Java conventions. It's ready for you to start implementing the core components.
> 

#### _User_

> /share 